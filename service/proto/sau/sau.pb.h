// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sau.proto

#ifndef PROTOBUF_sau_2eproto__INCLUDED
#define PROTOBUF_sau_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace cowa {
namespace sau {
class Block;
class BlockDefaultTypeInternal;
extern BlockDefaultTypeInternal _Block_default_instance_;
class Command;
class CommandDefaultTypeInternal;
extern CommandDefaultTypeInternal _Command_default_instance_;
class FallbackResult;
class FallbackResultDefaultTypeInternal;
extern FallbackResultDefaultTypeInternal _FallbackResult_default_instance_;
class FileInfo;
class FileInfoDefaultTypeInternal;
extern FileInfoDefaultTypeInternal _FileInfo_default_instance_;
class InstallControl;
class InstallControlDefaultTypeInternal;
extern InstallControlDefaultTypeInternal _InstallControl_default_instance_;
class InstallNotify;
class InstallNotifyDefaultTypeInternal;
extern InstallNotifyDefaultTypeInternal _InstallNotify_default_instance_;
class InstallPackages;
class InstallPackagesDefaultTypeInternal;
extern InstallPackagesDefaultTypeInternal _InstallPackages_default_instance_;
class InstallResult;
class InstallResultDefaultTypeInternal;
extern InstallResultDefaultTypeInternal _InstallResult_default_instance_;
class InstallVersion;
class InstallVersionDefaultTypeInternal;
extern InstallVersionDefaultTypeInternal _InstallVersion_default_instance_;
class PackageInfo;
class PackageInfoDefaultTypeInternal;
extern PackageInfoDefaultTypeInternal _PackageInfo_default_instance_;
class PackageUpdate;
class PackageUpdateDefaultTypeInternal;
extern PackageUpdateDefaultTypeInternal _PackageUpdate_default_instance_;
class PushFile;
class PushFileDefaultTypeInternal;
extern PushFileDefaultTypeInternal _PushFile_default_instance_;
class SubFileAck;
class SubFileAckDefaultTypeInternal;
extern SubFileAckDefaultTypeInternal _SubFileAck_default_instance_;
}  // namespace sau
}  // namespace cowa

namespace cowa {
namespace sau {

namespace protobuf_sau_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_sau_2eproto

enum CmdId {
  CMD_ID_INVALID = 0,
  CMD_ID_NOTIFY_IDENTITY = 1,
  CMD_ID_NOTIFY_INSTALLED_VERSIONS = 2,
  CMD_ID_REQ_IDENTITY = 3,
  CMD_ID_REQ_VERSION = 4,
  CMD_ID_PUB_PACKAGE_ACK = 5,
  CMD_ID_INSTALL_CONTROL = 6,
  CMD_ID_INSTALL_STATUS = 7,
  CMD_ID_FALLBACK_CONTROL = 16,
  CMD_ID_FALLBACK_STATUS = 17,
  CMD_ID_PROCESS_EXIT = 32,
  CMD_ID_NOTIFY_DOWNLOAD_VERSIONS = 48,
  CMD_ID_REQ_DOWNLOAD_VERSIONS = 49,
  CMD_ID_CONFIRM_INSTALL = 50,
  CmdId_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CmdId_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CmdId_IsValid(int value);
const CmdId CmdId_MIN = CMD_ID_INVALID;
const CmdId CmdId_MAX = CMD_ID_CONFIRM_INSTALL;
const int CmdId_ARRAYSIZE = CmdId_MAX + 1;

const ::google::protobuf::EnumDescriptor* CmdId_descriptor();
inline const ::std::string& CmdId_Name(CmdId value) {
  return ::google::protobuf::internal::NameOfEnum(
    CmdId_descriptor(), value);
}
inline bool CmdId_Parse(
    const ::std::string& name, CmdId* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CmdId>(
    CmdId_descriptor(), name, value);
}
enum InstallState {
  INSTALL_STATE_UNKNOW = 0,
  INSTALL_STATE_NORMAL = 1,
  INSTALL_STATE_PROCESSING = 2,
  INSTALL_STATE_FINISH = 3,
  INSTALL_STATE_ERROR = 4,
  InstallState_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  InstallState_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool InstallState_IsValid(int value);
const InstallState InstallState_MIN = INSTALL_STATE_UNKNOW;
const InstallState InstallState_MAX = INSTALL_STATE_ERROR;
const int InstallState_ARRAYSIZE = InstallState_MAX + 1;

const ::google::protobuf::EnumDescriptor* InstallState_descriptor();
inline const ::std::string& InstallState_Name(InstallState value) {
  return ::google::protobuf::internal::NameOfEnum(
    InstallState_descriptor(), value);
}
inline bool InstallState_Parse(
    const ::std::string& name, InstallState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InstallState>(
    InstallState_descriptor(), name, value);
}
enum InstallControlCmd {
  INSTALL_START = 0,
  INSTALL_STOP = 1,
  InstallControlCmd_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  InstallControlCmd_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool InstallControlCmd_IsValid(int value);
const InstallControlCmd InstallControlCmd_MIN = INSTALL_START;
const InstallControlCmd InstallControlCmd_MAX = INSTALL_STOP;
const int InstallControlCmd_ARRAYSIZE = InstallControlCmd_MAX + 1;

const ::google::protobuf::EnumDescriptor* InstallControlCmd_descriptor();
inline const ::std::string& InstallControlCmd_Name(InstallControlCmd value) {
  return ::google::protobuf::internal::NameOfEnum(
    InstallControlCmd_descriptor(), value);
}
inline bool InstallControlCmd_Parse(
    const ::std::string& name, InstallControlCmd* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InstallControlCmd>(
    InstallControlCmd_descriptor(), name, value);
}
enum FallbackState {
  FALLBACK_STATE_UNKNOWN = 0,
  FALLBACK_STATE_PROCESSING = 1,
  FALLBACK_STATE_OK = 2,
  FALLBACK_STATE_ERROR = 3,
  FallbackState_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  FallbackState_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool FallbackState_IsValid(int value);
const FallbackState FallbackState_MIN = FALLBACK_STATE_UNKNOWN;
const FallbackState FallbackState_MAX = FALLBACK_STATE_ERROR;
const int FallbackState_ARRAYSIZE = FallbackState_MAX + 1;

const ::google::protobuf::EnumDescriptor* FallbackState_descriptor();
inline const ::std::string& FallbackState_Name(FallbackState value) {
  return ::google::protobuf::internal::NameOfEnum(
    FallbackState_descriptor(), value);
}
inline bool FallbackState_Parse(
    const ::std::string& name, FallbackState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FallbackState>(
    FallbackState_descriptor(), name, value);
}
// ===================================================================

class InstallResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cowa.sau.InstallResult) */ {
 public:
  InstallResult();
  virtual ~InstallResult();

  InstallResult(const InstallResult& from);

  inline InstallResult& operator=(const InstallResult& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstallResult& default_instance();

  static inline const InstallResult* internal_default_instance() {
    return reinterpret_cast<const InstallResult*>(
               &_InstallResult_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(InstallResult* other);

  // implements Message ----------------------------------------------

  inline InstallResult* New() const PROTOBUF_FINAL { return New(NULL); }

  InstallResult* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const InstallResult& from);
  void MergeFrom(const InstallResult& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(InstallResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string package = 2;
  void clear_package();
  static const int kPackageFieldNumber = 2;
  const ::std::string& package() const;
  void set_package(const ::std::string& value);
  #if LANG_CXX11
  void set_package(::std::string&& value);
  #endif
  void set_package(const char* value);
  void set_package(const char* value, size_t size);
  ::std::string* mutable_package();
  ::std::string* release_package();
  void set_allocated_package(::std::string* package);

  // string reason = 3;
  void clear_reason();
  static const int kReasonFieldNumber = 3;
  const ::std::string& reason() const;
  void set_reason(const ::std::string& value);
  #if LANG_CXX11
  void set_reason(::std::string&& value);
  #endif
  void set_reason(const char* value);
  void set_reason(const char* value, size_t size);
  ::std::string* mutable_reason();
  ::std::string* release_reason();
  void set_allocated_reason(::std::string* reason);

  // .cowa.sau.InstallState code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::cowa::sau::InstallState code() const;
  void set_code(::cowa::sau::InstallState value);

  // @@protoc_insertion_point(class_scope:cowa.sau.InstallResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr package_;
  ::google::protobuf::internal::ArenaStringPtr reason_;
  int code_;
  mutable int _cached_size_;
  friend struct protobuf_sau_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PackageInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cowa.sau.PackageInfo) */ {
 public:
  PackageInfo();
  virtual ~PackageInfo();

  PackageInfo(const PackageInfo& from);

  inline PackageInfo& operator=(const PackageInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PackageInfo& default_instance();

  static inline const PackageInfo* internal_default_instance() {
    return reinterpret_cast<const PackageInfo*>(
               &_PackageInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(PackageInfo* other);

  // implements Message ----------------------------------------------

  inline PackageInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  PackageInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PackageInfo& from);
  void MergeFrom(const PackageInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PackageInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string device = 3;
  void clear_device();
  static const int kDeviceFieldNumber = 3;
  const ::std::string& device() const;
  void set_device(const ::std::string& value);
  #if LANG_CXX11
  void set_device(::std::string&& value);
  #endif
  void set_device(const char* value);
  void set_device(const char* value, size_t size);
  ::std::string* mutable_device();
  ::std::string* release_device();
  void set_allocated_device(::std::string* device);

  // @@protoc_insertion_point(class_scope:cowa.sau.PackageInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr device_;
  mutable int _cached_size_;
  friend struct protobuf_sau_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InstallControl : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cowa.sau.InstallControl) */ {
 public:
  InstallControl();
  virtual ~InstallControl();

  InstallControl(const InstallControl& from);

  inline InstallControl& operator=(const InstallControl& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstallControl& default_instance();

  static inline const InstallControl* internal_default_instance() {
    return reinterpret_cast<const InstallControl*>(
               &_InstallControl_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(InstallControl* other);

  // implements Message ----------------------------------------------

  inline InstallControl* New() const PROTOBUF_FINAL { return New(NULL); }

  InstallControl* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const InstallControl& from);
  void MergeFrom(const InstallControl& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(InstallControl* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string package = 2;
  void clear_package();
  static const int kPackageFieldNumber = 2;
  const ::std::string& package() const;
  void set_package(const ::std::string& value);
  #if LANG_CXX11
  void set_package(::std::string&& value);
  #endif
  void set_package(const char* value);
  void set_package(const char* value, size_t size);
  ::std::string* mutable_package();
  ::std::string* release_package();
  void set_allocated_package(::std::string* package);

  // string version = 3;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // .cowa.sau.InstallControlCmd control = 1;
  void clear_control();
  static const int kControlFieldNumber = 1;
  ::cowa::sau::InstallControlCmd control() const;
  void set_control(::cowa::sau::InstallControlCmd value);

  // @@protoc_insertion_point(class_scope:cowa.sau.InstallControl)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr package_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  int control_;
  mutable int _cached_size_;
  friend struct protobuf_sau_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InstallVersion : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cowa.sau.InstallVersion) */ {
 public:
  InstallVersion();
  virtual ~InstallVersion();

  InstallVersion(const InstallVersion& from);

  inline InstallVersion& operator=(const InstallVersion& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstallVersion& default_instance();

  static inline const InstallVersion* internal_default_instance() {
    return reinterpret_cast<const InstallVersion*>(
               &_InstallVersion_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(InstallVersion* other);

  // implements Message ----------------------------------------------

  inline InstallVersion* New() const PROTOBUF_FINAL { return New(NULL); }

  InstallVersion* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const InstallVersion& from);
  void MergeFrom(const InstallVersion& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(InstallVersion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .cowa.sau.PackageInfo packages = 2;
  int packages_size() const;
  void clear_packages();
  static const int kPackagesFieldNumber = 2;
  const ::cowa::sau::PackageInfo& packages(int index) const;
  ::cowa::sau::PackageInfo* mutable_packages(int index);
  ::cowa::sau::PackageInfo* add_packages();
  ::google::protobuf::RepeatedPtrField< ::cowa::sau::PackageInfo >*
      mutable_packages();
  const ::google::protobuf::RepeatedPtrField< ::cowa::sau::PackageInfo >&
      packages() const;

  // string device = 1;
  void clear_device();
  static const int kDeviceFieldNumber = 1;
  const ::std::string& device() const;
  void set_device(const ::std::string& value);
  #if LANG_CXX11
  void set_device(::std::string&& value);
  #endif
  void set_device(const char* value);
  void set_device(const char* value, size_t size);
  ::std::string* mutable_device();
  ::std::string* release_device();
  void set_allocated_device(::std::string* device);

  // @@protoc_insertion_point(class_scope:cowa.sau.InstallVersion)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::cowa::sau::PackageInfo > packages_;
  ::google::protobuf::internal::ArenaStringPtr device_;
  mutable int _cached_size_;
  friend struct protobuf_sau_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Command : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cowa.sau.Command) */ {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command& default_instance();

  static inline const Command* internal_default_instance() {
    return reinterpret_cast<const Command*>(
               &_Command_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Command* other);

  // implements Message ----------------------------------------------

  inline Command* New() const PROTOBUF_FINAL { return New(NULL); }

  Command* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Command* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string device = 2;
  void clear_device();
  static const int kDeviceFieldNumber = 2;
  const ::std::string& device() const;
  void set_device(const ::std::string& value);
  #if LANG_CXX11
  void set_device(::std::string&& value);
  #endif
  void set_device(const char* value);
  void set_device(const char* value, size_t size);
  ::std::string* mutable_device();
  ::std::string* release_device();
  void set_allocated_device(::std::string* device);

  // string module = 3;
  void clear_module();
  static const int kModuleFieldNumber = 3;
  const ::std::string& module() const;
  void set_module(const ::std::string& value);
  #if LANG_CXX11
  void set_module(::std::string&& value);
  #endif
  void set_module(const char* value);
  void set_module(const char* value, size_t size);
  ::std::string* mutable_module();
  ::std::string* release_module();
  void set_allocated_module(::std::string* module);

  // string data = 4;
  void clear_data();
  static const int kDataFieldNumber = 4;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const char* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // .cowa.sau.CmdId id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::cowa::sau::CmdId id() const;
  void set_id(::cowa::sau::CmdId value);

  // @@protoc_insertion_point(class_scope:cowa.sau.Command)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr device_;
  ::google::protobuf::internal::ArenaStringPtr module_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  int id_;
  mutable int _cached_size_;
  friend struct protobuf_sau_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Block : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cowa.sau.Block) */ {
 public:
  Block();
  virtual ~Block();

  Block(const Block& from);

  inline Block& operator=(const Block& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Block& default_instance();

  static inline const Block* internal_default_instance() {
    return reinterpret_cast<const Block*>(
               &_Block_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Block* other);

  // implements Message ----------------------------------------------

  inline Block* New() const PROTOBUF_FINAL { return New(NULL); }

  Block* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Block& from);
  void MergeFrom(const Block& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Block* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes data = 3;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // uint32 counter = 1;
  void clear_counter();
  static const int kCounterFieldNumber = 1;
  ::google::protobuf::uint32 counter() const;
  void set_counter(::google::protobuf::uint32 value);

  // uint32 index = 2;
  void clear_index();
  static const int kIndexFieldNumber = 2;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:cowa.sau.Block)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::uint32 counter_;
  ::google::protobuf::uint32 index_;
  mutable int _cached_size_;
  friend struct protobuf_sau_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FileInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cowa.sau.FileInfo) */ {
 public:
  FileInfo();
  virtual ~FileInfo();

  FileInfo(const FileInfo& from);

  inline FileInfo& operator=(const FileInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FileInfo& default_instance();

  static inline const FileInfo* internal_default_instance() {
    return reinterpret_cast<const FileInfo*>(
               &_FileInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(FileInfo* other);

  // implements Message ----------------------------------------------

  inline FileInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  FileInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FileInfo& from);
  void MergeFrom(const FileInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FileInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string md5 = 3;
  void clear_md5();
  static const int kMd5FieldNumber = 3;
  const ::std::string& md5() const;
  void set_md5(const ::std::string& value);
  #if LANG_CXX11
  void set_md5(::std::string&& value);
  #endif
  void set_md5(const char* value);
  void set_md5(const char* value, size_t size);
  ::std::string* mutable_md5();
  ::std::string* release_md5();
  void set_allocated_md5(::std::string* md5);

  // string package = 6;
  void clear_package();
  static const int kPackageFieldNumber = 6;
  const ::std::string& package() const;
  void set_package(const ::std::string& value);
  #if LANG_CXX11
  void set_package(::std::string&& value);
  #endif
  void set_package(const char* value);
  void set_package(const char* value, size_t size);
  ::std::string* mutable_package();
  ::std::string* release_package();
  void set_allocated_package(::std::string* package);

  // uint32 size = 4;
  void clear_size();
  static const int kSizeFieldNumber = 4;
  ::google::protobuf::uint32 size() const;
  void set_size(::google::protobuf::uint32 value);

  // bool mainifest = 5;
  void clear_mainifest();
  static const int kMainifestFieldNumber = 5;
  bool mainifest() const;
  void set_mainifest(bool value);

  // @@protoc_insertion_point(class_scope:cowa.sau.FileInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr md5_;
  ::google::protobuf::internal::ArenaStringPtr package_;
  ::google::protobuf::uint32 size_;
  bool mainifest_;
  mutable int _cached_size_;
  friend struct protobuf_sau_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PushFile : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cowa.sau.PushFile) */ {
 public:
  PushFile();
  virtual ~PushFile();

  PushFile(const PushFile& from);

  inline PushFile& operator=(const PushFile& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PushFile& default_instance();

  static inline const PushFile* internal_default_instance() {
    return reinterpret_cast<const PushFile*>(
               &_PushFile_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(PushFile* other);

  // implements Message ----------------------------------------------

  inline PushFile* New() const PROTOBUF_FINAL { return New(NULL); }

  PushFile* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PushFile& from);
  void MergeFrom(const PushFile& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PushFile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string target = 1;
  void clear_target();
  static const int kTargetFieldNumber = 1;
  const ::std::string& target() const;
  void set_target(const ::std::string& value);
  #if LANG_CXX11
  void set_target(::std::string&& value);
  #endif
  void set_target(const char* value);
  void set_target(const char* value, size_t size);
  ::std::string* mutable_target();
  ::std::string* release_target();
  void set_allocated_target(::std::string* target);

  // .cowa.sau.FileInfo file = 2;
  bool has_file() const;
  void clear_file();
  static const int kFileFieldNumber = 2;
  const ::cowa::sau::FileInfo& file() const;
  ::cowa::sau::FileInfo* mutable_file();
  ::cowa::sau::FileInfo* release_file();
  void set_allocated_file(::cowa::sau::FileInfo* file);

  // .cowa.sau.Block block = 3;
  bool has_block() const;
  void clear_block();
  static const int kBlockFieldNumber = 3;
  const ::cowa::sau::Block& block() const;
  ::cowa::sau::Block* mutable_block();
  ::cowa::sau::Block* release_block();
  void set_allocated_block(::cowa::sau::Block* block);

  // @@protoc_insertion_point(class_scope:cowa.sau.PushFile)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr target_;
  ::cowa::sau::FileInfo* file_;
  ::cowa::sau::Block* block_;
  mutable int _cached_size_;
  friend struct protobuf_sau_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SubFileAck : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cowa.sau.SubFileAck) */ {
 public:
  SubFileAck();
  virtual ~SubFileAck();

  SubFileAck(const SubFileAck& from);

  inline SubFileAck& operator=(const SubFileAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubFileAck& default_instance();

  static inline const SubFileAck* internal_default_instance() {
    return reinterpret_cast<const SubFileAck*>(
               &_SubFileAck_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(SubFileAck* other);

  // implements Message ----------------------------------------------

  inline SubFileAck* New() const PROTOBUF_FINAL { return New(NULL); }

  SubFileAck* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SubFileAck& from);
  void MergeFrom(const SubFileAck& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SubFileAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // bool success = 2;
  void clear_success();
  static const int kSuccessFieldNumber = 2;
  bool success() const;
  void set_success(bool value);

  // @@protoc_insertion_point(class_scope:cowa.sau.SubFileAck)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  bool success_;
  mutable int _cached_size_;
  friend struct protobuf_sau_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FallbackResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cowa.sau.FallbackResult) */ {
 public:
  FallbackResult();
  virtual ~FallbackResult();

  FallbackResult(const FallbackResult& from);

  inline FallbackResult& operator=(const FallbackResult& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FallbackResult& default_instance();

  static inline const FallbackResult* internal_default_instance() {
    return reinterpret_cast<const FallbackResult*>(
               &_FallbackResult_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(FallbackResult* other);

  // implements Message ----------------------------------------------

  inline FallbackResult* New() const PROTOBUF_FINAL { return New(NULL); }

  FallbackResult* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FallbackResult& from);
  void MergeFrom(const FallbackResult& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FallbackResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string reason = 3;
  void clear_reason();
  static const int kReasonFieldNumber = 3;
  const ::std::string& reason() const;
  void set_reason(const ::std::string& value);
  #if LANG_CXX11
  void set_reason(::std::string&& value);
  #endif
  void set_reason(const char* value);
  void set_reason(const char* value, size_t size);
  ::std::string* mutable_reason();
  ::std::string* release_reason();
  void set_allocated_reason(::std::string* reason);

  // .cowa.sau.PackageInfo pkginfo = 1;
  bool has_pkginfo() const;
  void clear_pkginfo();
  static const int kPkginfoFieldNumber = 1;
  const ::cowa::sau::PackageInfo& pkginfo() const;
  ::cowa::sau::PackageInfo* mutable_pkginfo();
  ::cowa::sau::PackageInfo* release_pkginfo();
  void set_allocated_pkginfo(::cowa::sau::PackageInfo* pkginfo);

  // .cowa.sau.FallbackState state = 2;
  void clear_state();
  static const int kStateFieldNumber = 2;
  ::cowa::sau::FallbackState state() const;
  void set_state(::cowa::sau::FallbackState value);

  // @@protoc_insertion_point(class_scope:cowa.sau.FallbackResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr reason_;
  ::cowa::sau::PackageInfo* pkginfo_;
  int state_;
  mutable int _cached_size_;
  friend struct protobuf_sau_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PackageUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cowa.sau.PackageUpdate) */ {
 public:
  PackageUpdate();
  virtual ~PackageUpdate();

  PackageUpdate(const PackageUpdate& from);

  inline PackageUpdate& operator=(const PackageUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PackageUpdate& default_instance();

  static inline const PackageUpdate* internal_default_instance() {
    return reinterpret_cast<const PackageUpdate*>(
               &_PackageUpdate_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(PackageUpdate* other);

  // implements Message ----------------------------------------------

  inline PackageUpdate* New() const PROTOBUF_FINAL { return New(NULL); }

  PackageUpdate* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PackageUpdate& from);
  void MergeFrom(const PackageUpdate& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PackageUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string new_version = 2;
  void clear_new_version();
  static const int kNewVersionFieldNumber = 2;
  const ::std::string& new_version() const;
  void set_new_version(const ::std::string& value);
  #if LANG_CXX11
  void set_new_version(::std::string&& value);
  #endif
  void set_new_version(const char* value);
  void set_new_version(const char* value, size_t size);
  ::std::string* mutable_new_version();
  ::std::string* release_new_version();
  void set_allocated_new_version(::std::string* new_version);

  // string old_version = 3;
  void clear_old_version();
  static const int kOldVersionFieldNumber = 3;
  const ::std::string& old_version() const;
  void set_old_version(const ::std::string& value);
  #if LANG_CXX11
  void set_old_version(::std::string&& value);
  #endif
  void set_old_version(const char* value);
  void set_old_version(const char* value, size_t size);
  ::std::string* mutable_old_version();
  ::std::string* release_old_version();
  void set_allocated_old_version(::std::string* old_version);

  // @@protoc_insertion_point(class_scope:cowa.sau.PackageUpdate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr new_version_;
  ::google::protobuf::internal::ArenaStringPtr old_version_;
  mutable int _cached_size_;
  friend struct protobuf_sau_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InstallPackages : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cowa.sau.InstallPackages) */ {
 public:
  InstallPackages();
  virtual ~InstallPackages();

  InstallPackages(const InstallPackages& from);

  inline InstallPackages& operator=(const InstallPackages& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstallPackages& default_instance();

  static inline const InstallPackages* internal_default_instance() {
    return reinterpret_cast<const InstallPackages*>(
               &_InstallPackages_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(InstallPackages* other);

  // implements Message ----------------------------------------------

  inline InstallPackages* New() const PROTOBUF_FINAL { return New(NULL); }

  InstallPackages* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const InstallPackages& from);
  void MergeFrom(const InstallPackages& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(InstallPackages* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .cowa.sau.PackageUpdate pkgs = 4;
  int pkgs_size() const;
  void clear_pkgs();
  static const int kPkgsFieldNumber = 4;
  const ::cowa::sau::PackageUpdate& pkgs(int index) const;
  ::cowa::sau::PackageUpdate* mutable_pkgs(int index);
  ::cowa::sau::PackageUpdate* add_pkgs();
  ::google::protobuf::RepeatedPtrField< ::cowa::sau::PackageUpdate >*
      mutable_pkgs();
  const ::google::protobuf::RepeatedPtrField< ::cowa::sau::PackageUpdate >&
      pkgs() const;

  // string version_cur = 1;
  void clear_version_cur();
  static const int kVersionCurFieldNumber = 1;
  const ::std::string& version_cur() const;
  void set_version_cur(const ::std::string& value);
  #if LANG_CXX11
  void set_version_cur(::std::string&& value);
  #endif
  void set_version_cur(const char* value);
  void set_version_cur(const char* value, size_t size);
  ::std::string* mutable_version_cur();
  ::std::string* release_version_cur();
  void set_allocated_version_cur(::std::string* version_cur);

  // string version_new = 2;
  void clear_version_new();
  static const int kVersionNewFieldNumber = 2;
  const ::std::string& version_new() const;
  void set_version_new(const ::std::string& value);
  #if LANG_CXX11
  void set_version_new(::std::string&& value);
  #endif
  void set_version_new(const char* value);
  void set_version_new(const char* value, size_t size);
  ::std::string* mutable_version_new();
  ::std::string* release_version_new();
  void set_allocated_version_new(::std::string* version_new);

  // .cowa.sau.InstallState state = 3;
  void clear_state();
  static const int kStateFieldNumber = 3;
  ::cowa::sau::InstallState state() const;
  void set_state(::cowa::sau::InstallState value);

  // @@protoc_insertion_point(class_scope:cowa.sau.InstallPackages)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::cowa::sau::PackageUpdate > pkgs_;
  ::google::protobuf::internal::ArenaStringPtr version_cur_;
  ::google::protobuf::internal::ArenaStringPtr version_new_;
  int state_;
  mutable int _cached_size_;
  friend struct protobuf_sau_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InstallNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cowa.sau.InstallNotify) */ {
 public:
  InstallNotify();
  virtual ~InstallNotify();

  InstallNotify(const InstallNotify& from);

  inline InstallNotify& operator=(const InstallNotify& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstallNotify& default_instance();

  static inline const InstallNotify* internal_default_instance() {
    return reinterpret_cast<const InstallNotify*>(
               &_InstallNotify_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(InstallNotify* other);

  // implements Message ----------------------------------------------

  inline InstallNotify* New() const PROTOBUF_FINAL { return New(NULL); }

  InstallNotify* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const InstallNotify& from);
  void MergeFrom(const InstallNotify& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(InstallNotify* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool update = 1;
  void clear_update();
  static const int kUpdateFieldNumber = 1;
  bool update() const;
  void set_update(bool value);

  // @@protoc_insertion_point(class_scope:cowa.sau.InstallNotify)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool update_;
  mutable int _cached_size_;
  friend struct protobuf_sau_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// InstallResult

// .cowa.sau.InstallState code = 1;
inline void InstallResult::clear_code() {
  code_ = 0;
}
inline ::cowa::sau::InstallState InstallResult::code() const {
  // @@protoc_insertion_point(field_get:cowa.sau.InstallResult.code)
  return static_cast< ::cowa::sau::InstallState >(code_);
}
inline void InstallResult::set_code(::cowa::sau::InstallState value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:cowa.sau.InstallResult.code)
}

// string package = 2;
inline void InstallResult::clear_package() {
  package_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InstallResult::package() const {
  // @@protoc_insertion_point(field_get:cowa.sau.InstallResult.package)
  return package_.GetNoArena();
}
inline void InstallResult::set_package(const ::std::string& value) {
  
  package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cowa.sau.InstallResult.package)
}
#if LANG_CXX11
inline void InstallResult::set_package(::std::string&& value) {
  
  package_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cowa.sau.InstallResult.package)
}
#endif
inline void InstallResult::set_package(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cowa.sau.InstallResult.package)
}
inline void InstallResult::set_package(const char* value, size_t size) {
  
  package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cowa.sau.InstallResult.package)
}
inline ::std::string* InstallResult::mutable_package() {
  
  // @@protoc_insertion_point(field_mutable:cowa.sau.InstallResult.package)
  return package_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InstallResult::release_package() {
  // @@protoc_insertion_point(field_release:cowa.sau.InstallResult.package)
  
  return package_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InstallResult::set_allocated_package(::std::string* package) {
  if (package != NULL) {
    
  } else {
    
  }
  package_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), package);
  // @@protoc_insertion_point(field_set_allocated:cowa.sau.InstallResult.package)
}

// string reason = 3;
inline void InstallResult::clear_reason() {
  reason_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InstallResult::reason() const {
  // @@protoc_insertion_point(field_get:cowa.sau.InstallResult.reason)
  return reason_.GetNoArena();
}
inline void InstallResult::set_reason(const ::std::string& value) {
  
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cowa.sau.InstallResult.reason)
}
#if LANG_CXX11
inline void InstallResult::set_reason(::std::string&& value) {
  
  reason_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cowa.sau.InstallResult.reason)
}
#endif
inline void InstallResult::set_reason(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cowa.sau.InstallResult.reason)
}
inline void InstallResult::set_reason(const char* value, size_t size) {
  
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cowa.sau.InstallResult.reason)
}
inline ::std::string* InstallResult::mutable_reason() {
  
  // @@protoc_insertion_point(field_mutable:cowa.sau.InstallResult.reason)
  return reason_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InstallResult::release_reason() {
  // @@protoc_insertion_point(field_release:cowa.sau.InstallResult.reason)
  
  return reason_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InstallResult::set_allocated_reason(::std::string* reason) {
  if (reason != NULL) {
    
  } else {
    
  }
  reason_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reason);
  // @@protoc_insertion_point(field_set_allocated:cowa.sau.InstallResult.reason)
}

// -------------------------------------------------------------------

// PackageInfo

// string name = 1;
inline void PackageInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PackageInfo::name() const {
  // @@protoc_insertion_point(field_get:cowa.sau.PackageInfo.name)
  return name_.GetNoArena();
}
inline void PackageInfo::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cowa.sau.PackageInfo.name)
}
#if LANG_CXX11
inline void PackageInfo::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cowa.sau.PackageInfo.name)
}
#endif
inline void PackageInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cowa.sau.PackageInfo.name)
}
inline void PackageInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cowa.sau.PackageInfo.name)
}
inline ::std::string* PackageInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:cowa.sau.PackageInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PackageInfo::release_name() {
  // @@protoc_insertion_point(field_release:cowa.sau.PackageInfo.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PackageInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:cowa.sau.PackageInfo.name)
}

// string version = 2;
inline void PackageInfo::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PackageInfo::version() const {
  // @@protoc_insertion_point(field_get:cowa.sau.PackageInfo.version)
  return version_.GetNoArena();
}
inline void PackageInfo::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cowa.sau.PackageInfo.version)
}
#if LANG_CXX11
inline void PackageInfo::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cowa.sau.PackageInfo.version)
}
#endif
inline void PackageInfo::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cowa.sau.PackageInfo.version)
}
inline void PackageInfo::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cowa.sau.PackageInfo.version)
}
inline ::std::string* PackageInfo::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:cowa.sau.PackageInfo.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PackageInfo::release_version() {
  // @@protoc_insertion_point(field_release:cowa.sau.PackageInfo.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PackageInfo::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:cowa.sau.PackageInfo.version)
}

// string device = 3;
inline void PackageInfo::clear_device() {
  device_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PackageInfo::device() const {
  // @@protoc_insertion_point(field_get:cowa.sau.PackageInfo.device)
  return device_.GetNoArena();
}
inline void PackageInfo::set_device(const ::std::string& value) {
  
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cowa.sau.PackageInfo.device)
}
#if LANG_CXX11
inline void PackageInfo::set_device(::std::string&& value) {
  
  device_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cowa.sau.PackageInfo.device)
}
#endif
inline void PackageInfo::set_device(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cowa.sau.PackageInfo.device)
}
inline void PackageInfo::set_device(const char* value, size_t size) {
  
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cowa.sau.PackageInfo.device)
}
inline ::std::string* PackageInfo::mutable_device() {
  
  // @@protoc_insertion_point(field_mutable:cowa.sau.PackageInfo.device)
  return device_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PackageInfo::release_device() {
  // @@protoc_insertion_point(field_release:cowa.sau.PackageInfo.device)
  
  return device_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PackageInfo::set_allocated_device(::std::string* device) {
  if (device != NULL) {
    
  } else {
    
  }
  device_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device);
  // @@protoc_insertion_point(field_set_allocated:cowa.sau.PackageInfo.device)
}

// -------------------------------------------------------------------

// InstallControl

// .cowa.sau.InstallControlCmd control = 1;
inline void InstallControl::clear_control() {
  control_ = 0;
}
inline ::cowa::sau::InstallControlCmd InstallControl::control() const {
  // @@protoc_insertion_point(field_get:cowa.sau.InstallControl.control)
  return static_cast< ::cowa::sau::InstallControlCmd >(control_);
}
inline void InstallControl::set_control(::cowa::sau::InstallControlCmd value) {
  
  control_ = value;
  // @@protoc_insertion_point(field_set:cowa.sau.InstallControl.control)
}

// string package = 2;
inline void InstallControl::clear_package() {
  package_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InstallControl::package() const {
  // @@protoc_insertion_point(field_get:cowa.sau.InstallControl.package)
  return package_.GetNoArena();
}
inline void InstallControl::set_package(const ::std::string& value) {
  
  package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cowa.sau.InstallControl.package)
}
#if LANG_CXX11
inline void InstallControl::set_package(::std::string&& value) {
  
  package_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cowa.sau.InstallControl.package)
}
#endif
inline void InstallControl::set_package(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cowa.sau.InstallControl.package)
}
inline void InstallControl::set_package(const char* value, size_t size) {
  
  package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cowa.sau.InstallControl.package)
}
inline ::std::string* InstallControl::mutable_package() {
  
  // @@protoc_insertion_point(field_mutable:cowa.sau.InstallControl.package)
  return package_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InstallControl::release_package() {
  // @@protoc_insertion_point(field_release:cowa.sau.InstallControl.package)
  
  return package_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InstallControl::set_allocated_package(::std::string* package) {
  if (package != NULL) {
    
  } else {
    
  }
  package_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), package);
  // @@protoc_insertion_point(field_set_allocated:cowa.sau.InstallControl.package)
}

// string version = 3;
inline void InstallControl::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InstallControl::version() const {
  // @@protoc_insertion_point(field_get:cowa.sau.InstallControl.version)
  return version_.GetNoArena();
}
inline void InstallControl::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cowa.sau.InstallControl.version)
}
#if LANG_CXX11
inline void InstallControl::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cowa.sau.InstallControl.version)
}
#endif
inline void InstallControl::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cowa.sau.InstallControl.version)
}
inline void InstallControl::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cowa.sau.InstallControl.version)
}
inline ::std::string* InstallControl::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:cowa.sau.InstallControl.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InstallControl::release_version() {
  // @@protoc_insertion_point(field_release:cowa.sau.InstallControl.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InstallControl::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:cowa.sau.InstallControl.version)
}

// -------------------------------------------------------------------

// InstallVersion

// string device = 1;
inline void InstallVersion::clear_device() {
  device_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InstallVersion::device() const {
  // @@protoc_insertion_point(field_get:cowa.sau.InstallVersion.device)
  return device_.GetNoArena();
}
inline void InstallVersion::set_device(const ::std::string& value) {
  
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cowa.sau.InstallVersion.device)
}
#if LANG_CXX11
inline void InstallVersion::set_device(::std::string&& value) {
  
  device_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cowa.sau.InstallVersion.device)
}
#endif
inline void InstallVersion::set_device(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cowa.sau.InstallVersion.device)
}
inline void InstallVersion::set_device(const char* value, size_t size) {
  
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cowa.sau.InstallVersion.device)
}
inline ::std::string* InstallVersion::mutable_device() {
  
  // @@protoc_insertion_point(field_mutable:cowa.sau.InstallVersion.device)
  return device_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InstallVersion::release_device() {
  // @@protoc_insertion_point(field_release:cowa.sau.InstallVersion.device)
  
  return device_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InstallVersion::set_allocated_device(::std::string* device) {
  if (device != NULL) {
    
  } else {
    
  }
  device_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device);
  // @@protoc_insertion_point(field_set_allocated:cowa.sau.InstallVersion.device)
}

// repeated .cowa.sau.PackageInfo packages = 2;
inline int InstallVersion::packages_size() const {
  return packages_.size();
}
inline void InstallVersion::clear_packages() {
  packages_.Clear();
}
inline const ::cowa::sau::PackageInfo& InstallVersion::packages(int index) const {
  // @@protoc_insertion_point(field_get:cowa.sau.InstallVersion.packages)
  return packages_.Get(index);
}
inline ::cowa::sau::PackageInfo* InstallVersion::mutable_packages(int index) {
  // @@protoc_insertion_point(field_mutable:cowa.sau.InstallVersion.packages)
  return packages_.Mutable(index);
}
inline ::cowa::sau::PackageInfo* InstallVersion::add_packages() {
  // @@protoc_insertion_point(field_add:cowa.sau.InstallVersion.packages)
  return packages_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::cowa::sau::PackageInfo >*
InstallVersion::mutable_packages() {
  // @@protoc_insertion_point(field_mutable_list:cowa.sau.InstallVersion.packages)
  return &packages_;
}
inline const ::google::protobuf::RepeatedPtrField< ::cowa::sau::PackageInfo >&
InstallVersion::packages() const {
  // @@protoc_insertion_point(field_list:cowa.sau.InstallVersion.packages)
  return packages_;
}

// -------------------------------------------------------------------

// Command

// .cowa.sau.CmdId id = 1;
inline void Command::clear_id() {
  id_ = 0;
}
inline ::cowa::sau::CmdId Command::id() const {
  // @@protoc_insertion_point(field_get:cowa.sau.Command.id)
  return static_cast< ::cowa::sau::CmdId >(id_);
}
inline void Command::set_id(::cowa::sau::CmdId value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:cowa.sau.Command.id)
}

// string device = 2;
inline void Command::clear_device() {
  device_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Command::device() const {
  // @@protoc_insertion_point(field_get:cowa.sau.Command.device)
  return device_.GetNoArena();
}
inline void Command::set_device(const ::std::string& value) {
  
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cowa.sau.Command.device)
}
#if LANG_CXX11
inline void Command::set_device(::std::string&& value) {
  
  device_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cowa.sau.Command.device)
}
#endif
inline void Command::set_device(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cowa.sau.Command.device)
}
inline void Command::set_device(const char* value, size_t size) {
  
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cowa.sau.Command.device)
}
inline ::std::string* Command::mutable_device() {
  
  // @@protoc_insertion_point(field_mutable:cowa.sau.Command.device)
  return device_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Command::release_device() {
  // @@protoc_insertion_point(field_release:cowa.sau.Command.device)
  
  return device_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Command::set_allocated_device(::std::string* device) {
  if (device != NULL) {
    
  } else {
    
  }
  device_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device);
  // @@protoc_insertion_point(field_set_allocated:cowa.sau.Command.device)
}

// string module = 3;
inline void Command::clear_module() {
  module_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Command::module() const {
  // @@protoc_insertion_point(field_get:cowa.sau.Command.module)
  return module_.GetNoArena();
}
inline void Command::set_module(const ::std::string& value) {
  
  module_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cowa.sau.Command.module)
}
#if LANG_CXX11
inline void Command::set_module(::std::string&& value) {
  
  module_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cowa.sau.Command.module)
}
#endif
inline void Command::set_module(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  module_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cowa.sau.Command.module)
}
inline void Command::set_module(const char* value, size_t size) {
  
  module_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cowa.sau.Command.module)
}
inline ::std::string* Command::mutable_module() {
  
  // @@protoc_insertion_point(field_mutable:cowa.sau.Command.module)
  return module_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Command::release_module() {
  // @@protoc_insertion_point(field_release:cowa.sau.Command.module)
  
  return module_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Command::set_allocated_module(::std::string* module) {
  if (module != NULL) {
    
  } else {
    
  }
  module_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), module);
  // @@protoc_insertion_point(field_set_allocated:cowa.sau.Command.module)
}

// string data = 4;
inline void Command::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Command::data() const {
  // @@protoc_insertion_point(field_get:cowa.sau.Command.data)
  return data_.GetNoArena();
}
inline void Command::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cowa.sau.Command.data)
}
#if LANG_CXX11
inline void Command::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cowa.sau.Command.data)
}
#endif
inline void Command::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cowa.sau.Command.data)
}
inline void Command::set_data(const char* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cowa.sau.Command.data)
}
inline ::std::string* Command::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:cowa.sau.Command.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Command::release_data() {
  // @@protoc_insertion_point(field_release:cowa.sau.Command.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Command::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:cowa.sau.Command.data)
}

// -------------------------------------------------------------------

// Block

// uint32 counter = 1;
inline void Block::clear_counter() {
  counter_ = 0u;
}
inline ::google::protobuf::uint32 Block::counter() const {
  // @@protoc_insertion_point(field_get:cowa.sau.Block.counter)
  return counter_;
}
inline void Block::set_counter(::google::protobuf::uint32 value) {
  
  counter_ = value;
  // @@protoc_insertion_point(field_set:cowa.sau.Block.counter)
}

// uint32 index = 2;
inline void Block::clear_index() {
  index_ = 0u;
}
inline ::google::protobuf::uint32 Block::index() const {
  // @@protoc_insertion_point(field_get:cowa.sau.Block.index)
  return index_;
}
inline void Block::set_index(::google::protobuf::uint32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:cowa.sau.Block.index)
}

// bytes data = 3;
inline void Block::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Block::data() const {
  // @@protoc_insertion_point(field_get:cowa.sau.Block.data)
  return data_.GetNoArena();
}
inline void Block::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cowa.sau.Block.data)
}
#if LANG_CXX11
inline void Block::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cowa.sau.Block.data)
}
#endif
inline void Block::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cowa.sau.Block.data)
}
inline void Block::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cowa.sau.Block.data)
}
inline ::std::string* Block::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:cowa.sau.Block.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Block::release_data() {
  // @@protoc_insertion_point(field_release:cowa.sau.Block.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Block::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:cowa.sau.Block.data)
}

// -------------------------------------------------------------------

// FileInfo

// string name = 1;
inline void FileInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileInfo::name() const {
  // @@protoc_insertion_point(field_get:cowa.sau.FileInfo.name)
  return name_.GetNoArena();
}
inline void FileInfo::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cowa.sau.FileInfo.name)
}
#if LANG_CXX11
inline void FileInfo::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cowa.sau.FileInfo.name)
}
#endif
inline void FileInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cowa.sau.FileInfo.name)
}
inline void FileInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cowa.sau.FileInfo.name)
}
inline ::std::string* FileInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:cowa.sau.FileInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileInfo::release_name() {
  // @@protoc_insertion_point(field_release:cowa.sau.FileInfo.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:cowa.sau.FileInfo.name)
}

// string version = 2;
inline void FileInfo::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileInfo::version() const {
  // @@protoc_insertion_point(field_get:cowa.sau.FileInfo.version)
  return version_.GetNoArena();
}
inline void FileInfo::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cowa.sau.FileInfo.version)
}
#if LANG_CXX11
inline void FileInfo::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cowa.sau.FileInfo.version)
}
#endif
inline void FileInfo::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cowa.sau.FileInfo.version)
}
inline void FileInfo::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cowa.sau.FileInfo.version)
}
inline ::std::string* FileInfo::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:cowa.sau.FileInfo.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileInfo::release_version() {
  // @@protoc_insertion_point(field_release:cowa.sau.FileInfo.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileInfo::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:cowa.sau.FileInfo.version)
}

// string md5 = 3;
inline void FileInfo::clear_md5() {
  md5_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileInfo::md5() const {
  // @@protoc_insertion_point(field_get:cowa.sau.FileInfo.md5)
  return md5_.GetNoArena();
}
inline void FileInfo::set_md5(const ::std::string& value) {
  
  md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cowa.sau.FileInfo.md5)
}
#if LANG_CXX11
inline void FileInfo::set_md5(::std::string&& value) {
  
  md5_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cowa.sau.FileInfo.md5)
}
#endif
inline void FileInfo::set_md5(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cowa.sau.FileInfo.md5)
}
inline void FileInfo::set_md5(const char* value, size_t size) {
  
  md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cowa.sau.FileInfo.md5)
}
inline ::std::string* FileInfo::mutable_md5() {
  
  // @@protoc_insertion_point(field_mutable:cowa.sau.FileInfo.md5)
  return md5_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileInfo::release_md5() {
  // @@protoc_insertion_point(field_release:cowa.sau.FileInfo.md5)
  
  return md5_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileInfo::set_allocated_md5(::std::string* md5) {
  if (md5 != NULL) {
    
  } else {
    
  }
  md5_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), md5);
  // @@protoc_insertion_point(field_set_allocated:cowa.sau.FileInfo.md5)
}

// uint32 size = 4;
inline void FileInfo::clear_size() {
  size_ = 0u;
}
inline ::google::protobuf::uint32 FileInfo::size() const {
  // @@protoc_insertion_point(field_get:cowa.sau.FileInfo.size)
  return size_;
}
inline void FileInfo::set_size(::google::protobuf::uint32 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:cowa.sau.FileInfo.size)
}

// bool mainifest = 5;
inline void FileInfo::clear_mainifest() {
  mainifest_ = false;
}
inline bool FileInfo::mainifest() const {
  // @@protoc_insertion_point(field_get:cowa.sau.FileInfo.mainifest)
  return mainifest_;
}
inline void FileInfo::set_mainifest(bool value) {
  
  mainifest_ = value;
  // @@protoc_insertion_point(field_set:cowa.sau.FileInfo.mainifest)
}

// string package = 6;
inline void FileInfo::clear_package() {
  package_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileInfo::package() const {
  // @@protoc_insertion_point(field_get:cowa.sau.FileInfo.package)
  return package_.GetNoArena();
}
inline void FileInfo::set_package(const ::std::string& value) {
  
  package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cowa.sau.FileInfo.package)
}
#if LANG_CXX11
inline void FileInfo::set_package(::std::string&& value) {
  
  package_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cowa.sau.FileInfo.package)
}
#endif
inline void FileInfo::set_package(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cowa.sau.FileInfo.package)
}
inline void FileInfo::set_package(const char* value, size_t size) {
  
  package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cowa.sau.FileInfo.package)
}
inline ::std::string* FileInfo::mutable_package() {
  
  // @@protoc_insertion_point(field_mutable:cowa.sau.FileInfo.package)
  return package_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileInfo::release_package() {
  // @@protoc_insertion_point(field_release:cowa.sau.FileInfo.package)
  
  return package_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileInfo::set_allocated_package(::std::string* package) {
  if (package != NULL) {
    
  } else {
    
  }
  package_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), package);
  // @@protoc_insertion_point(field_set_allocated:cowa.sau.FileInfo.package)
}

// -------------------------------------------------------------------

// PushFile

// string target = 1;
inline void PushFile::clear_target() {
  target_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PushFile::target() const {
  // @@protoc_insertion_point(field_get:cowa.sau.PushFile.target)
  return target_.GetNoArena();
}
inline void PushFile::set_target(const ::std::string& value) {
  
  target_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cowa.sau.PushFile.target)
}
#if LANG_CXX11
inline void PushFile::set_target(::std::string&& value) {
  
  target_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cowa.sau.PushFile.target)
}
#endif
inline void PushFile::set_target(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  target_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cowa.sau.PushFile.target)
}
inline void PushFile::set_target(const char* value, size_t size) {
  
  target_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cowa.sau.PushFile.target)
}
inline ::std::string* PushFile::mutable_target() {
  
  // @@protoc_insertion_point(field_mutable:cowa.sau.PushFile.target)
  return target_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PushFile::release_target() {
  // @@protoc_insertion_point(field_release:cowa.sau.PushFile.target)
  
  return target_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PushFile::set_allocated_target(::std::string* target) {
  if (target != NULL) {
    
  } else {
    
  }
  target_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target);
  // @@protoc_insertion_point(field_set_allocated:cowa.sau.PushFile.target)
}

// .cowa.sau.FileInfo file = 2;
inline bool PushFile::has_file() const {
  return this != internal_default_instance() && file_ != NULL;
}
inline void PushFile::clear_file() {
  if (GetArenaNoVirtual() == NULL && file_ != NULL) delete file_;
  file_ = NULL;
}
inline const ::cowa::sau::FileInfo& PushFile::file() const {
  // @@protoc_insertion_point(field_get:cowa.sau.PushFile.file)
  return file_ != NULL ? *file_
                         : *::cowa::sau::FileInfo::internal_default_instance();
}
inline ::cowa::sau::FileInfo* PushFile::mutable_file() {
  
  if (file_ == NULL) {
    file_ = new ::cowa::sau::FileInfo;
  }
  // @@protoc_insertion_point(field_mutable:cowa.sau.PushFile.file)
  return file_;
}
inline ::cowa::sau::FileInfo* PushFile::release_file() {
  // @@protoc_insertion_point(field_release:cowa.sau.PushFile.file)
  
  ::cowa::sau::FileInfo* temp = file_;
  file_ = NULL;
  return temp;
}
inline void PushFile::set_allocated_file(::cowa::sau::FileInfo* file) {
  delete file_;
  file_ = file;
  if (file) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cowa.sau.PushFile.file)
}

// .cowa.sau.Block block = 3;
inline bool PushFile::has_block() const {
  return this != internal_default_instance() && block_ != NULL;
}
inline void PushFile::clear_block() {
  if (GetArenaNoVirtual() == NULL && block_ != NULL) delete block_;
  block_ = NULL;
}
inline const ::cowa::sau::Block& PushFile::block() const {
  // @@protoc_insertion_point(field_get:cowa.sau.PushFile.block)
  return block_ != NULL ? *block_
                         : *::cowa::sau::Block::internal_default_instance();
}
inline ::cowa::sau::Block* PushFile::mutable_block() {
  
  if (block_ == NULL) {
    block_ = new ::cowa::sau::Block;
  }
  // @@protoc_insertion_point(field_mutable:cowa.sau.PushFile.block)
  return block_;
}
inline ::cowa::sau::Block* PushFile::release_block() {
  // @@protoc_insertion_point(field_release:cowa.sau.PushFile.block)
  
  ::cowa::sau::Block* temp = block_;
  block_ = NULL;
  return temp;
}
inline void PushFile::set_allocated_block(::cowa::sau::Block* block) {
  delete block_;
  block_ = block;
  if (block) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cowa.sau.PushFile.block)
}

// -------------------------------------------------------------------

// SubFileAck

// string name = 1;
inline void SubFileAck::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SubFileAck::name() const {
  // @@protoc_insertion_point(field_get:cowa.sau.SubFileAck.name)
  return name_.GetNoArena();
}
inline void SubFileAck::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cowa.sau.SubFileAck.name)
}
#if LANG_CXX11
inline void SubFileAck::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cowa.sau.SubFileAck.name)
}
#endif
inline void SubFileAck::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cowa.sau.SubFileAck.name)
}
inline void SubFileAck::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cowa.sau.SubFileAck.name)
}
inline ::std::string* SubFileAck::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:cowa.sau.SubFileAck.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubFileAck::release_name() {
  // @@protoc_insertion_point(field_release:cowa.sau.SubFileAck.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubFileAck::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:cowa.sau.SubFileAck.name)
}

// bool success = 2;
inline void SubFileAck::clear_success() {
  success_ = false;
}
inline bool SubFileAck::success() const {
  // @@protoc_insertion_point(field_get:cowa.sau.SubFileAck.success)
  return success_;
}
inline void SubFileAck::set_success(bool value) {
  
  success_ = value;
  // @@protoc_insertion_point(field_set:cowa.sau.SubFileAck.success)
}

// -------------------------------------------------------------------

// FallbackResult

// .cowa.sau.PackageInfo pkginfo = 1;
inline bool FallbackResult::has_pkginfo() const {
  return this != internal_default_instance() && pkginfo_ != NULL;
}
inline void FallbackResult::clear_pkginfo() {
  if (GetArenaNoVirtual() == NULL && pkginfo_ != NULL) delete pkginfo_;
  pkginfo_ = NULL;
}
inline const ::cowa::sau::PackageInfo& FallbackResult::pkginfo() const {
  // @@protoc_insertion_point(field_get:cowa.sau.FallbackResult.pkginfo)
  return pkginfo_ != NULL ? *pkginfo_
                         : *::cowa::sau::PackageInfo::internal_default_instance();
}
inline ::cowa::sau::PackageInfo* FallbackResult::mutable_pkginfo() {
  
  if (pkginfo_ == NULL) {
    pkginfo_ = new ::cowa::sau::PackageInfo;
  }
  // @@protoc_insertion_point(field_mutable:cowa.sau.FallbackResult.pkginfo)
  return pkginfo_;
}
inline ::cowa::sau::PackageInfo* FallbackResult::release_pkginfo() {
  // @@protoc_insertion_point(field_release:cowa.sau.FallbackResult.pkginfo)
  
  ::cowa::sau::PackageInfo* temp = pkginfo_;
  pkginfo_ = NULL;
  return temp;
}
inline void FallbackResult::set_allocated_pkginfo(::cowa::sau::PackageInfo* pkginfo) {
  delete pkginfo_;
  pkginfo_ = pkginfo;
  if (pkginfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cowa.sau.FallbackResult.pkginfo)
}

// .cowa.sau.FallbackState state = 2;
inline void FallbackResult::clear_state() {
  state_ = 0;
}
inline ::cowa::sau::FallbackState FallbackResult::state() const {
  // @@protoc_insertion_point(field_get:cowa.sau.FallbackResult.state)
  return static_cast< ::cowa::sau::FallbackState >(state_);
}
inline void FallbackResult::set_state(::cowa::sau::FallbackState value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:cowa.sau.FallbackResult.state)
}

// string reason = 3;
inline void FallbackResult::clear_reason() {
  reason_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FallbackResult::reason() const {
  // @@protoc_insertion_point(field_get:cowa.sau.FallbackResult.reason)
  return reason_.GetNoArena();
}
inline void FallbackResult::set_reason(const ::std::string& value) {
  
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cowa.sau.FallbackResult.reason)
}
#if LANG_CXX11
inline void FallbackResult::set_reason(::std::string&& value) {
  
  reason_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cowa.sau.FallbackResult.reason)
}
#endif
inline void FallbackResult::set_reason(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cowa.sau.FallbackResult.reason)
}
inline void FallbackResult::set_reason(const char* value, size_t size) {
  
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cowa.sau.FallbackResult.reason)
}
inline ::std::string* FallbackResult::mutable_reason() {
  
  // @@protoc_insertion_point(field_mutable:cowa.sau.FallbackResult.reason)
  return reason_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FallbackResult::release_reason() {
  // @@protoc_insertion_point(field_release:cowa.sau.FallbackResult.reason)
  
  return reason_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FallbackResult::set_allocated_reason(::std::string* reason) {
  if (reason != NULL) {
    
  } else {
    
  }
  reason_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reason);
  // @@protoc_insertion_point(field_set_allocated:cowa.sau.FallbackResult.reason)
}

// -------------------------------------------------------------------

// PackageUpdate

// string name = 1;
inline void PackageUpdate::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PackageUpdate::name() const {
  // @@protoc_insertion_point(field_get:cowa.sau.PackageUpdate.name)
  return name_.GetNoArena();
}
inline void PackageUpdate::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cowa.sau.PackageUpdate.name)
}
#if LANG_CXX11
inline void PackageUpdate::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cowa.sau.PackageUpdate.name)
}
#endif
inline void PackageUpdate::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cowa.sau.PackageUpdate.name)
}
inline void PackageUpdate::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cowa.sau.PackageUpdate.name)
}
inline ::std::string* PackageUpdate::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:cowa.sau.PackageUpdate.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PackageUpdate::release_name() {
  // @@protoc_insertion_point(field_release:cowa.sau.PackageUpdate.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PackageUpdate::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:cowa.sau.PackageUpdate.name)
}

// string new_version = 2;
inline void PackageUpdate::clear_new_version() {
  new_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PackageUpdate::new_version() const {
  // @@protoc_insertion_point(field_get:cowa.sau.PackageUpdate.new_version)
  return new_version_.GetNoArena();
}
inline void PackageUpdate::set_new_version(const ::std::string& value) {
  
  new_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cowa.sau.PackageUpdate.new_version)
}
#if LANG_CXX11
inline void PackageUpdate::set_new_version(::std::string&& value) {
  
  new_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cowa.sau.PackageUpdate.new_version)
}
#endif
inline void PackageUpdate::set_new_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  new_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cowa.sau.PackageUpdate.new_version)
}
inline void PackageUpdate::set_new_version(const char* value, size_t size) {
  
  new_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cowa.sau.PackageUpdate.new_version)
}
inline ::std::string* PackageUpdate::mutable_new_version() {
  
  // @@protoc_insertion_point(field_mutable:cowa.sau.PackageUpdate.new_version)
  return new_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PackageUpdate::release_new_version() {
  // @@protoc_insertion_point(field_release:cowa.sau.PackageUpdate.new_version)
  
  return new_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PackageUpdate::set_allocated_new_version(::std::string* new_version) {
  if (new_version != NULL) {
    
  } else {
    
  }
  new_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), new_version);
  // @@protoc_insertion_point(field_set_allocated:cowa.sau.PackageUpdate.new_version)
}

// string old_version = 3;
inline void PackageUpdate::clear_old_version() {
  old_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PackageUpdate::old_version() const {
  // @@protoc_insertion_point(field_get:cowa.sau.PackageUpdate.old_version)
  return old_version_.GetNoArena();
}
inline void PackageUpdate::set_old_version(const ::std::string& value) {
  
  old_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cowa.sau.PackageUpdate.old_version)
}
#if LANG_CXX11
inline void PackageUpdate::set_old_version(::std::string&& value) {
  
  old_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cowa.sau.PackageUpdate.old_version)
}
#endif
inline void PackageUpdate::set_old_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  old_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cowa.sau.PackageUpdate.old_version)
}
inline void PackageUpdate::set_old_version(const char* value, size_t size) {
  
  old_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cowa.sau.PackageUpdate.old_version)
}
inline ::std::string* PackageUpdate::mutable_old_version() {
  
  // @@protoc_insertion_point(field_mutable:cowa.sau.PackageUpdate.old_version)
  return old_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PackageUpdate::release_old_version() {
  // @@protoc_insertion_point(field_release:cowa.sau.PackageUpdate.old_version)
  
  return old_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PackageUpdate::set_allocated_old_version(::std::string* old_version) {
  if (old_version != NULL) {
    
  } else {
    
  }
  old_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), old_version);
  // @@protoc_insertion_point(field_set_allocated:cowa.sau.PackageUpdate.old_version)
}

// -------------------------------------------------------------------

// InstallPackages

// string version_cur = 1;
inline void InstallPackages::clear_version_cur() {
  version_cur_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InstallPackages::version_cur() const {
  // @@protoc_insertion_point(field_get:cowa.sau.InstallPackages.version_cur)
  return version_cur_.GetNoArena();
}
inline void InstallPackages::set_version_cur(const ::std::string& value) {
  
  version_cur_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cowa.sau.InstallPackages.version_cur)
}
#if LANG_CXX11
inline void InstallPackages::set_version_cur(::std::string&& value) {
  
  version_cur_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cowa.sau.InstallPackages.version_cur)
}
#endif
inline void InstallPackages::set_version_cur(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_cur_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cowa.sau.InstallPackages.version_cur)
}
inline void InstallPackages::set_version_cur(const char* value, size_t size) {
  
  version_cur_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cowa.sau.InstallPackages.version_cur)
}
inline ::std::string* InstallPackages::mutable_version_cur() {
  
  // @@protoc_insertion_point(field_mutable:cowa.sau.InstallPackages.version_cur)
  return version_cur_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InstallPackages::release_version_cur() {
  // @@protoc_insertion_point(field_release:cowa.sau.InstallPackages.version_cur)
  
  return version_cur_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InstallPackages::set_allocated_version_cur(::std::string* version_cur) {
  if (version_cur != NULL) {
    
  } else {
    
  }
  version_cur_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version_cur);
  // @@protoc_insertion_point(field_set_allocated:cowa.sau.InstallPackages.version_cur)
}

// string version_new = 2;
inline void InstallPackages::clear_version_new() {
  version_new_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InstallPackages::version_new() const {
  // @@protoc_insertion_point(field_get:cowa.sau.InstallPackages.version_new)
  return version_new_.GetNoArena();
}
inline void InstallPackages::set_version_new(const ::std::string& value) {
  
  version_new_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cowa.sau.InstallPackages.version_new)
}
#if LANG_CXX11
inline void InstallPackages::set_version_new(::std::string&& value) {
  
  version_new_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cowa.sau.InstallPackages.version_new)
}
#endif
inline void InstallPackages::set_version_new(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_new_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cowa.sau.InstallPackages.version_new)
}
inline void InstallPackages::set_version_new(const char* value, size_t size) {
  
  version_new_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cowa.sau.InstallPackages.version_new)
}
inline ::std::string* InstallPackages::mutable_version_new() {
  
  // @@protoc_insertion_point(field_mutable:cowa.sau.InstallPackages.version_new)
  return version_new_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InstallPackages::release_version_new() {
  // @@protoc_insertion_point(field_release:cowa.sau.InstallPackages.version_new)
  
  return version_new_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InstallPackages::set_allocated_version_new(::std::string* version_new) {
  if (version_new != NULL) {
    
  } else {
    
  }
  version_new_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version_new);
  // @@protoc_insertion_point(field_set_allocated:cowa.sau.InstallPackages.version_new)
}

// .cowa.sau.InstallState state = 3;
inline void InstallPackages::clear_state() {
  state_ = 0;
}
inline ::cowa::sau::InstallState InstallPackages::state() const {
  // @@protoc_insertion_point(field_get:cowa.sau.InstallPackages.state)
  return static_cast< ::cowa::sau::InstallState >(state_);
}
inline void InstallPackages::set_state(::cowa::sau::InstallState value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:cowa.sau.InstallPackages.state)
}

// repeated .cowa.sau.PackageUpdate pkgs = 4;
inline int InstallPackages::pkgs_size() const {
  return pkgs_.size();
}
inline void InstallPackages::clear_pkgs() {
  pkgs_.Clear();
}
inline const ::cowa::sau::PackageUpdate& InstallPackages::pkgs(int index) const {
  // @@protoc_insertion_point(field_get:cowa.sau.InstallPackages.pkgs)
  return pkgs_.Get(index);
}
inline ::cowa::sau::PackageUpdate* InstallPackages::mutable_pkgs(int index) {
  // @@protoc_insertion_point(field_mutable:cowa.sau.InstallPackages.pkgs)
  return pkgs_.Mutable(index);
}
inline ::cowa::sau::PackageUpdate* InstallPackages::add_pkgs() {
  // @@protoc_insertion_point(field_add:cowa.sau.InstallPackages.pkgs)
  return pkgs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::cowa::sau::PackageUpdate >*
InstallPackages::mutable_pkgs() {
  // @@protoc_insertion_point(field_mutable_list:cowa.sau.InstallPackages.pkgs)
  return &pkgs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::cowa::sau::PackageUpdate >&
InstallPackages::pkgs() const {
  // @@protoc_insertion_point(field_list:cowa.sau.InstallPackages.pkgs)
  return pkgs_;
}

// -------------------------------------------------------------------

// InstallNotify

// bool update = 1;
inline void InstallNotify::clear_update() {
  update_ = false;
}
inline bool InstallNotify::update() const {
  // @@protoc_insertion_point(field_get:cowa.sau.InstallNotify.update)
  return update_;
}
inline void InstallNotify::set_update(bool value) {
  
  update_ = value;
  // @@protoc_insertion_point(field_set:cowa.sau.InstallNotify.update)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace sau
}  // namespace cowa

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::cowa::sau::CmdId> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cowa::sau::CmdId>() {
  return ::cowa::sau::CmdId_descriptor();
}
template <> struct is_proto_enum< ::cowa::sau::InstallState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cowa::sau::InstallState>() {
  return ::cowa::sau::InstallState_descriptor();
}
template <> struct is_proto_enum< ::cowa::sau::InstallControlCmd> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cowa::sau::InstallControlCmd>() {
  return ::cowa::sau::InstallControlCmd_descriptor();
}
template <> struct is_proto_enum< ::cowa::sau::FallbackState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cowa::sau::FallbackState>() {
  return ::cowa::sau::FallbackState_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_sau_2eproto__INCLUDED
