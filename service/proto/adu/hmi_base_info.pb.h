// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: hmi_base_info.proto

#ifndef PROTOBUF_hmi_5fbase_5finfo_2eproto__INCLUDED
#define PROTOBUF_hmi_5fbase_5finfo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "pose.pb.h"
#include "obstacle.pb.h"
#include "trafficlight.pb.h"
#include "trajectory.pb.h"
#include "chassis.pb.h"
// @@protoc_insertion_point(includes)
namespace COWA {
namespace NavMsg {
class Covariance;
class CovarianceDefaultTypeInternal;
extern CovarianceDefaultTypeInternal _Covariance_default_instance_;
class DebugField;
class DebugFieldDefaultTypeInternal;
extern DebugFieldDefaultTypeInternal _DebugField_default_instance_;
class Obstacle;
class ObstacleDefaultTypeInternal;
extern ObstacleDefaultTypeInternal _Obstacle_default_instance_;
class Obstacle_ObstacleTrajectory;
class Obstacle_ObstacleTrajectoryDefaultTypeInternal;
extern Obstacle_ObstacleTrajectoryDefaultTypeInternal _Obstacle_ObstacleTrajectory_default_instance_;
class Obstacles;
class ObstaclesDefaultTypeInternal;
extern ObstaclesDefaultTypeInternal _Obstacles_default_instance_;
class Point3D;
class Point3DDefaultTypeInternal;
extern Point3DDefaultTypeInternal _Point3D_default_instance_;
class Pose;
class PoseDefaultTypeInternal;
extern PoseDefaultTypeInternal _Pose_default_instance_;
class PoseStamped;
class PoseStampedDefaultTypeInternal;
extern PoseStampedDefaultTypeInternal _PoseStamped_default_instance_;
class PoseStampedArray;
class PoseStampedArrayDefaultTypeInternal;
extern PoseStampedArrayDefaultTypeInternal _PoseStampedArray_default_instance_;
class Quaternion;
class QuaternionDefaultTypeInternal;
extern QuaternionDefaultTypeInternal _Quaternion_default_instance_;
class TrafficLight;
class TrafficLightDefaultTypeInternal;
extern TrafficLightDefaultTypeInternal _TrafficLight_default_instance_;
class TrafficLight2;
class TrafficLight2DefaultTypeInternal;
extern TrafficLight2DefaultTypeInternal _TrafficLight2_default_instance_;
class TrafficLight2_Item;
class TrafficLight2_ItemDefaultTypeInternal;
extern TrafficLight2_ItemDefaultTypeInternal _TrafficLight2_Item_default_instance_;
class TrafficLightBBox;
class TrafficLightBBoxDefaultTypeInternal;
extern TrafficLightBBoxDefaultTypeInternal _TrafficLightBBox_default_instance_;
class TrafficLightDetection;
class TrafficLightDetectionDefaultTypeInternal;
extern TrafficLightDetectionDefaultTypeInternal _TrafficLightDetection_default_instance_;
class Trajectory;
class TrajectoryDefaultTypeInternal;
extern TrajectoryDefaultTypeInternal _Trajectory_default_instance_;
class TrajectoryPoint;
class TrajectoryPointDefaultTypeInternal;
extern TrajectoryPointDefaultTypeInternal _TrajectoryPoint_default_instance_;
class VehicleBCM;
class VehicleBCMDefaultTypeInternal;
extern VehicleBCMDefaultTypeInternal _VehicleBCM_default_instance_;
class VehicleCommond;
class VehicleCommondDefaultTypeInternal;
extern VehicleCommondDefaultTypeInternal _VehicleCommond_default_instance_;
class VehicleDrive;
class VehicleDriveDefaultTypeInternal;
extern VehicleDriveDefaultTypeInternal _VehicleDrive_default_instance_;
class VehicleInfo;
class VehicleInfoDefaultTypeInternal;
extern VehicleInfoDefaultTypeInternal _VehicleInfo_default_instance_;
class VehicleSoc;
class VehicleSocDefaultTypeInternal;
extern VehicleSocDefaultTypeInternal _VehicleSoc_default_instance_;
class Velocity;
class VelocityDefaultTypeInternal;
extern VelocityDefaultTypeInternal _Velocity_default_instance_;
}  // namespace NavMsg
}  // namespace COWA
namespace hmi {
class BaseInfoDataType;
class BaseInfoDataTypeDefaultTypeInternal;
extern BaseInfoDataTypeDefaultTypeInternal _BaseInfoDataType_default_instance_;
class ID;
class IDDefaultTypeInternal;
extern IDDefaultTypeInternal _ID_default_instance_;
class LaneInfoType;
class LaneInfoTypeDefaultTypeInternal;
extern LaneInfoTypeDefaultTypeInternal _LaneInfoType_default_instance_;
}  // namespace hmi

namespace hmi {

namespace protobuf_hmi_5fbase_5finfo_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_hmi_5fbase_5finfo_2eproto

// ===================================================================

class ID : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hmi.ID) */ {
 public:
  ID();
  virtual ~ID();

  ID(const ID& from);

  inline ID& operator=(const ID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ID& default_instance();

  static inline const ID* internal_default_instance() {
    return reinterpret_cast<const ID*>(
               &_ID_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(ID* other);

  // implements Message ----------------------------------------------

  inline ID* New() const PROTOBUF_FINAL { return New(NULL); }

  ID* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ID& from);
  void MergeFrom(const ID& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ID* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:hmi.ID)
 private:
  void set_has_id();
  void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  friend struct protobuf_hmi_5fbase_5finfo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LaneInfoType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hmi.LaneInfoType) */ {
 public:
  LaneInfoType();
  virtual ~LaneInfoType();

  LaneInfoType(const LaneInfoType& from);

  inline LaneInfoType& operator=(const LaneInfoType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneInfoType& default_instance();

  static inline const LaneInfoType* internal_default_instance() {
    return reinterpret_cast<const LaneInfoType*>(
               &_LaneInfoType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(LaneInfoType* other);

  // implements Message ----------------------------------------------

  inline LaneInfoType* New() const PROTOBUF_FINAL { return New(NULL); }

  LaneInfoType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LaneInfoType& from);
  void MergeFrom(const LaneInfoType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LaneInfoType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hmi.ID lane_id = 1;
  int lane_id_size() const;
  void clear_lane_id();
  static const int kLaneIdFieldNumber = 1;
  const ::hmi::ID& lane_id(int index) const;
  ::hmi::ID* mutable_lane_id(int index);
  ::hmi::ID* add_lane_id();
  ::google::protobuf::RepeatedPtrField< ::hmi::ID >*
      mutable_lane_id();
  const ::google::protobuf::RepeatedPtrField< ::hmi::ID >&
      lane_id() const;

  // repeated .hmi.ID road_id = 2;
  int road_id_size() const;
  void clear_road_id();
  static const int kRoadIdFieldNumber = 2;
  const ::hmi::ID& road_id(int index) const;
  ::hmi::ID* mutable_road_id(int index);
  ::hmi::ID* add_road_id();
  ::google::protobuf::RepeatedPtrField< ::hmi::ID >*
      mutable_road_id();
  const ::google::protobuf::RepeatedPtrField< ::hmi::ID >&
      road_id() const;

  // repeated .hmi.ID crossroad_id = 3;
  int crossroad_id_size() const;
  void clear_crossroad_id();
  static const int kCrossroadIdFieldNumber = 3;
  const ::hmi::ID& crossroad_id(int index) const;
  ::hmi::ID* mutable_crossroad_id(int index);
  ::hmi::ID* add_crossroad_id();
  ::google::protobuf::RepeatedPtrField< ::hmi::ID >*
      mutable_crossroad_id();
  const ::google::protobuf::RepeatedPtrField< ::hmi::ID >&
      crossroad_id() const;

  // repeated .hmi.ID crosswalk_id = 4;
  int crosswalk_id_size() const;
  void clear_crosswalk_id();
  static const int kCrosswalkIdFieldNumber = 4;
  const ::hmi::ID& crosswalk_id(int index) const;
  ::hmi::ID* mutable_crosswalk_id(int index);
  ::hmi::ID* add_crosswalk_id();
  ::google::protobuf::RepeatedPtrField< ::hmi::ID >*
      mutable_crosswalk_id();
  const ::google::protobuf::RepeatedPtrField< ::hmi::ID >&
      crosswalk_id() const;

  // repeated .hmi.ID signal_id = 5;
  int signal_id_size() const;
  void clear_signal_id();
  static const int kSignalIdFieldNumber = 5;
  const ::hmi::ID& signal_id(int index) const;
  ::hmi::ID* mutable_signal_id(int index);
  ::hmi::ID* add_signal_id();
  ::google::protobuf::RepeatedPtrField< ::hmi::ID >*
      mutable_signal_id();
  const ::google::protobuf::RepeatedPtrField< ::hmi::ID >&
      signal_id() const;

  // @@protoc_insertion_point(class_scope:hmi.LaneInfoType)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::hmi::ID > lane_id_;
  ::google::protobuf::RepeatedPtrField< ::hmi::ID > road_id_;
  ::google::protobuf::RepeatedPtrField< ::hmi::ID > crossroad_id_;
  ::google::protobuf::RepeatedPtrField< ::hmi::ID > crosswalk_id_;
  ::google::protobuf::RepeatedPtrField< ::hmi::ID > signal_id_;
  friend struct protobuf_hmi_5fbase_5finfo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BaseInfoDataType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hmi.BaseInfoDataType) */ {
 public:
  BaseInfoDataType();
  virtual ~BaseInfoDataType();

  BaseInfoDataType(const BaseInfoDataType& from);

  inline BaseInfoDataType& operator=(const BaseInfoDataType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BaseInfoDataType& default_instance();

  static inline const BaseInfoDataType* internal_default_instance() {
    return reinterpret_cast<const BaseInfoDataType*>(
               &_BaseInfoDataType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(BaseInfoDataType* other);

  // implements Message ----------------------------------------------

  inline BaseInfoDataType* New() const PROTOBUF_FINAL { return New(NULL); }

  BaseInfoDataType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BaseInfoDataType& from);
  void MergeFrom(const BaseInfoDataType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BaseInfoDataType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .COWA.NavMsg.PoseStamped pose_info = 2;
  bool has_pose_info() const;
  void clear_pose_info();
  static const int kPoseInfoFieldNumber = 2;
  const ::COWA::NavMsg::PoseStamped& pose_info() const;
  ::COWA::NavMsg::PoseStamped* mutable_pose_info();
  ::COWA::NavMsg::PoseStamped* release_pose_info();
  void set_allocated_pose_info(::COWA::NavMsg::PoseStamped* pose_info);

  // optional .COWA.NavMsg.Trajectory trajectory_info = 3;
  bool has_trajectory_info() const;
  void clear_trajectory_info();
  static const int kTrajectoryInfoFieldNumber = 3;
  const ::COWA::NavMsg::Trajectory& trajectory_info() const;
  ::COWA::NavMsg::Trajectory* mutable_trajectory_info();
  ::COWA::NavMsg::Trajectory* release_trajectory_info();
  void set_allocated_trajectory_info(::COWA::NavMsg::Trajectory* trajectory_info);

  // optional .COWA.NavMsg.Obstacles obstacles_info = 4;
  bool has_obstacles_info() const;
  void clear_obstacles_info();
  static const int kObstaclesInfoFieldNumber = 4;
  const ::COWA::NavMsg::Obstacles& obstacles_info() const;
  ::COWA::NavMsg::Obstacles* mutable_obstacles_info();
  ::COWA::NavMsg::Obstacles* release_obstacles_info();
  void set_allocated_obstacles_info(::COWA::NavMsg::Obstacles* obstacles_info);

  // optional .COWA.NavMsg.TrafficLight2 trafficlight2_info = 5;
  bool has_trafficlight2_info() const;
  void clear_trafficlight2_info();
  static const int kTrafficlight2InfoFieldNumber = 5;
  const ::COWA::NavMsg::TrafficLight2& trafficlight2_info() const;
  ::COWA::NavMsg::TrafficLight2* mutable_trafficlight2_info();
  ::COWA::NavMsg::TrafficLight2* release_trafficlight2_info();
  void set_allocated_trafficlight2_info(::COWA::NavMsg::TrafficLight2* trafficlight2_info);

  // optional .COWA.NavMsg.VehicleDrive vehicle_drive_info = 6;
  bool has_vehicle_drive_info() const;
  void clear_vehicle_drive_info();
  static const int kVehicleDriveInfoFieldNumber = 6;
  const ::COWA::NavMsg::VehicleDrive& vehicle_drive_info() const;
  ::COWA::NavMsg::VehicleDrive* mutable_vehicle_drive_info();
  ::COWA::NavMsg::VehicleDrive* release_vehicle_drive_info();
  void set_allocated_vehicle_drive_info(::COWA::NavMsg::VehicleDrive* vehicle_drive_info);

  // optional .hmi.LaneInfoType lane_info = 7;
  bool has_lane_info() const;
  void clear_lane_info();
  static const int kLaneInfoFieldNumber = 7;
  const ::hmi::LaneInfoType& lane_info() const;
  ::hmi::LaneInfoType* mutable_lane_info();
  ::hmi::LaneInfoType* release_lane_info();
  void set_allocated_lane_info(::hmi::LaneInfoType* lane_info);

  // required uint64 sequence_id = 1;
  bool has_sequence_id() const;
  void clear_sequence_id();
  static const int kSequenceIdFieldNumber = 1;
  ::google::protobuf::uint64 sequence_id() const;
  void set_sequence_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hmi.BaseInfoDataType)
 private:
  void set_has_sequence_id();
  void clear_has_sequence_id();
  void set_has_pose_info();
  void clear_has_pose_info();
  void set_has_trajectory_info();
  void clear_has_trajectory_info();
  void set_has_obstacles_info();
  void clear_has_obstacles_info();
  void set_has_trafficlight2_info();
  void clear_has_trafficlight2_info();
  void set_has_vehicle_drive_info();
  void clear_has_vehicle_drive_info();
  void set_has_lane_info();
  void clear_has_lane_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::COWA::NavMsg::PoseStamped* pose_info_;
  ::COWA::NavMsg::Trajectory* trajectory_info_;
  ::COWA::NavMsg::Obstacles* obstacles_info_;
  ::COWA::NavMsg::TrafficLight2* trafficlight2_info_;
  ::COWA::NavMsg::VehicleDrive* vehicle_drive_info_;
  ::hmi::LaneInfoType* lane_info_;
  ::google::protobuf::uint64 sequence_id_;
  friend struct protobuf_hmi_5fbase_5finfo_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ID

// required string id = 1;
inline bool ID::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ID::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ID::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ID::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& ID::id() const {
  // @@protoc_insertion_point(field_get:hmi.ID.id)
  return id_.GetNoArena();
}
inline void ID::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hmi.ID.id)
}
#if LANG_CXX11
inline void ID::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hmi.ID.id)
}
#endif
inline void ID::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hmi.ID.id)
}
inline void ID::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hmi.ID.id)
}
inline ::std::string* ID::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:hmi.ID.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ID::release_id() {
  // @@protoc_insertion_point(field_release:hmi.ID.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ID::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:hmi.ID.id)
}

// -------------------------------------------------------------------

// LaneInfoType

// repeated .hmi.ID lane_id = 1;
inline int LaneInfoType::lane_id_size() const {
  return lane_id_.size();
}
inline void LaneInfoType::clear_lane_id() {
  lane_id_.Clear();
}
inline const ::hmi::ID& LaneInfoType::lane_id(int index) const {
  // @@protoc_insertion_point(field_get:hmi.LaneInfoType.lane_id)
  return lane_id_.Get(index);
}
inline ::hmi::ID* LaneInfoType::mutable_lane_id(int index) {
  // @@protoc_insertion_point(field_mutable:hmi.LaneInfoType.lane_id)
  return lane_id_.Mutable(index);
}
inline ::hmi::ID* LaneInfoType::add_lane_id() {
  // @@protoc_insertion_point(field_add:hmi.LaneInfoType.lane_id)
  return lane_id_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::hmi::ID >*
LaneInfoType::mutable_lane_id() {
  // @@protoc_insertion_point(field_mutable_list:hmi.LaneInfoType.lane_id)
  return &lane_id_;
}
inline const ::google::protobuf::RepeatedPtrField< ::hmi::ID >&
LaneInfoType::lane_id() const {
  // @@protoc_insertion_point(field_list:hmi.LaneInfoType.lane_id)
  return lane_id_;
}

// repeated .hmi.ID road_id = 2;
inline int LaneInfoType::road_id_size() const {
  return road_id_.size();
}
inline void LaneInfoType::clear_road_id() {
  road_id_.Clear();
}
inline const ::hmi::ID& LaneInfoType::road_id(int index) const {
  // @@protoc_insertion_point(field_get:hmi.LaneInfoType.road_id)
  return road_id_.Get(index);
}
inline ::hmi::ID* LaneInfoType::mutable_road_id(int index) {
  // @@protoc_insertion_point(field_mutable:hmi.LaneInfoType.road_id)
  return road_id_.Mutable(index);
}
inline ::hmi::ID* LaneInfoType::add_road_id() {
  // @@protoc_insertion_point(field_add:hmi.LaneInfoType.road_id)
  return road_id_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::hmi::ID >*
LaneInfoType::mutable_road_id() {
  // @@protoc_insertion_point(field_mutable_list:hmi.LaneInfoType.road_id)
  return &road_id_;
}
inline const ::google::protobuf::RepeatedPtrField< ::hmi::ID >&
LaneInfoType::road_id() const {
  // @@protoc_insertion_point(field_list:hmi.LaneInfoType.road_id)
  return road_id_;
}

// repeated .hmi.ID crossroad_id = 3;
inline int LaneInfoType::crossroad_id_size() const {
  return crossroad_id_.size();
}
inline void LaneInfoType::clear_crossroad_id() {
  crossroad_id_.Clear();
}
inline const ::hmi::ID& LaneInfoType::crossroad_id(int index) const {
  // @@protoc_insertion_point(field_get:hmi.LaneInfoType.crossroad_id)
  return crossroad_id_.Get(index);
}
inline ::hmi::ID* LaneInfoType::mutable_crossroad_id(int index) {
  // @@protoc_insertion_point(field_mutable:hmi.LaneInfoType.crossroad_id)
  return crossroad_id_.Mutable(index);
}
inline ::hmi::ID* LaneInfoType::add_crossroad_id() {
  // @@protoc_insertion_point(field_add:hmi.LaneInfoType.crossroad_id)
  return crossroad_id_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::hmi::ID >*
LaneInfoType::mutable_crossroad_id() {
  // @@protoc_insertion_point(field_mutable_list:hmi.LaneInfoType.crossroad_id)
  return &crossroad_id_;
}
inline const ::google::protobuf::RepeatedPtrField< ::hmi::ID >&
LaneInfoType::crossroad_id() const {
  // @@protoc_insertion_point(field_list:hmi.LaneInfoType.crossroad_id)
  return crossroad_id_;
}

// repeated .hmi.ID crosswalk_id = 4;
inline int LaneInfoType::crosswalk_id_size() const {
  return crosswalk_id_.size();
}
inline void LaneInfoType::clear_crosswalk_id() {
  crosswalk_id_.Clear();
}
inline const ::hmi::ID& LaneInfoType::crosswalk_id(int index) const {
  // @@protoc_insertion_point(field_get:hmi.LaneInfoType.crosswalk_id)
  return crosswalk_id_.Get(index);
}
inline ::hmi::ID* LaneInfoType::mutable_crosswalk_id(int index) {
  // @@protoc_insertion_point(field_mutable:hmi.LaneInfoType.crosswalk_id)
  return crosswalk_id_.Mutable(index);
}
inline ::hmi::ID* LaneInfoType::add_crosswalk_id() {
  // @@protoc_insertion_point(field_add:hmi.LaneInfoType.crosswalk_id)
  return crosswalk_id_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::hmi::ID >*
LaneInfoType::mutable_crosswalk_id() {
  // @@protoc_insertion_point(field_mutable_list:hmi.LaneInfoType.crosswalk_id)
  return &crosswalk_id_;
}
inline const ::google::protobuf::RepeatedPtrField< ::hmi::ID >&
LaneInfoType::crosswalk_id() const {
  // @@protoc_insertion_point(field_list:hmi.LaneInfoType.crosswalk_id)
  return crosswalk_id_;
}

// repeated .hmi.ID signal_id = 5;
inline int LaneInfoType::signal_id_size() const {
  return signal_id_.size();
}
inline void LaneInfoType::clear_signal_id() {
  signal_id_.Clear();
}
inline const ::hmi::ID& LaneInfoType::signal_id(int index) const {
  // @@protoc_insertion_point(field_get:hmi.LaneInfoType.signal_id)
  return signal_id_.Get(index);
}
inline ::hmi::ID* LaneInfoType::mutable_signal_id(int index) {
  // @@protoc_insertion_point(field_mutable:hmi.LaneInfoType.signal_id)
  return signal_id_.Mutable(index);
}
inline ::hmi::ID* LaneInfoType::add_signal_id() {
  // @@protoc_insertion_point(field_add:hmi.LaneInfoType.signal_id)
  return signal_id_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::hmi::ID >*
LaneInfoType::mutable_signal_id() {
  // @@protoc_insertion_point(field_mutable_list:hmi.LaneInfoType.signal_id)
  return &signal_id_;
}
inline const ::google::protobuf::RepeatedPtrField< ::hmi::ID >&
LaneInfoType::signal_id() const {
  // @@protoc_insertion_point(field_list:hmi.LaneInfoType.signal_id)
  return signal_id_;
}

// -------------------------------------------------------------------

// BaseInfoDataType

// required uint64 sequence_id = 1;
inline bool BaseInfoDataType::has_sequence_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BaseInfoDataType::set_has_sequence_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BaseInfoDataType::clear_has_sequence_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BaseInfoDataType::clear_sequence_id() {
  sequence_id_ = GOOGLE_ULONGLONG(0);
  clear_has_sequence_id();
}
inline ::google::protobuf::uint64 BaseInfoDataType::sequence_id() const {
  // @@protoc_insertion_point(field_get:hmi.BaseInfoDataType.sequence_id)
  return sequence_id_;
}
inline void BaseInfoDataType::set_sequence_id(::google::protobuf::uint64 value) {
  set_has_sequence_id();
  sequence_id_ = value;
  // @@protoc_insertion_point(field_set:hmi.BaseInfoDataType.sequence_id)
}

// optional .COWA.NavMsg.PoseStamped pose_info = 2;
inline bool BaseInfoDataType::has_pose_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BaseInfoDataType::set_has_pose_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BaseInfoDataType::clear_has_pose_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BaseInfoDataType::clear_pose_info() {
  if (pose_info_ != NULL) pose_info_->::COWA::NavMsg::PoseStamped::Clear();
  clear_has_pose_info();
}
inline const ::COWA::NavMsg::PoseStamped& BaseInfoDataType::pose_info() const {
  // @@protoc_insertion_point(field_get:hmi.BaseInfoDataType.pose_info)
  return pose_info_ != NULL ? *pose_info_
                         : *::COWA::NavMsg::PoseStamped::internal_default_instance();
}
inline ::COWA::NavMsg::PoseStamped* BaseInfoDataType::mutable_pose_info() {
  set_has_pose_info();
  if (pose_info_ == NULL) {
    pose_info_ = new ::COWA::NavMsg::PoseStamped;
  }
  // @@protoc_insertion_point(field_mutable:hmi.BaseInfoDataType.pose_info)
  return pose_info_;
}
inline ::COWA::NavMsg::PoseStamped* BaseInfoDataType::release_pose_info() {
  // @@protoc_insertion_point(field_release:hmi.BaseInfoDataType.pose_info)
  clear_has_pose_info();
  ::COWA::NavMsg::PoseStamped* temp = pose_info_;
  pose_info_ = NULL;
  return temp;
}
inline void BaseInfoDataType::set_allocated_pose_info(::COWA::NavMsg::PoseStamped* pose_info) {
  delete pose_info_;
  pose_info_ = pose_info;
  if (pose_info) {
    set_has_pose_info();
  } else {
    clear_has_pose_info();
  }
  // @@protoc_insertion_point(field_set_allocated:hmi.BaseInfoDataType.pose_info)
}

// optional .COWA.NavMsg.Trajectory trajectory_info = 3;
inline bool BaseInfoDataType::has_trajectory_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BaseInfoDataType::set_has_trajectory_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BaseInfoDataType::clear_has_trajectory_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BaseInfoDataType::clear_trajectory_info() {
  if (trajectory_info_ != NULL) trajectory_info_->::COWA::NavMsg::Trajectory::Clear();
  clear_has_trajectory_info();
}
inline const ::COWA::NavMsg::Trajectory& BaseInfoDataType::trajectory_info() const {
  // @@protoc_insertion_point(field_get:hmi.BaseInfoDataType.trajectory_info)
  return trajectory_info_ != NULL ? *trajectory_info_
                         : *::COWA::NavMsg::Trajectory::internal_default_instance();
}
inline ::COWA::NavMsg::Trajectory* BaseInfoDataType::mutable_trajectory_info() {
  set_has_trajectory_info();
  if (trajectory_info_ == NULL) {
    trajectory_info_ = new ::COWA::NavMsg::Trajectory;
  }
  // @@protoc_insertion_point(field_mutable:hmi.BaseInfoDataType.trajectory_info)
  return trajectory_info_;
}
inline ::COWA::NavMsg::Trajectory* BaseInfoDataType::release_trajectory_info() {
  // @@protoc_insertion_point(field_release:hmi.BaseInfoDataType.trajectory_info)
  clear_has_trajectory_info();
  ::COWA::NavMsg::Trajectory* temp = trajectory_info_;
  trajectory_info_ = NULL;
  return temp;
}
inline void BaseInfoDataType::set_allocated_trajectory_info(::COWA::NavMsg::Trajectory* trajectory_info) {
  delete trajectory_info_;
  trajectory_info_ = trajectory_info;
  if (trajectory_info) {
    set_has_trajectory_info();
  } else {
    clear_has_trajectory_info();
  }
  // @@protoc_insertion_point(field_set_allocated:hmi.BaseInfoDataType.trajectory_info)
}

// optional .COWA.NavMsg.Obstacles obstacles_info = 4;
inline bool BaseInfoDataType::has_obstacles_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BaseInfoDataType::set_has_obstacles_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BaseInfoDataType::clear_has_obstacles_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BaseInfoDataType::clear_obstacles_info() {
  if (obstacles_info_ != NULL) obstacles_info_->::COWA::NavMsg::Obstacles::Clear();
  clear_has_obstacles_info();
}
inline const ::COWA::NavMsg::Obstacles& BaseInfoDataType::obstacles_info() const {
  // @@protoc_insertion_point(field_get:hmi.BaseInfoDataType.obstacles_info)
  return obstacles_info_ != NULL ? *obstacles_info_
                         : *::COWA::NavMsg::Obstacles::internal_default_instance();
}
inline ::COWA::NavMsg::Obstacles* BaseInfoDataType::mutable_obstacles_info() {
  set_has_obstacles_info();
  if (obstacles_info_ == NULL) {
    obstacles_info_ = new ::COWA::NavMsg::Obstacles;
  }
  // @@protoc_insertion_point(field_mutable:hmi.BaseInfoDataType.obstacles_info)
  return obstacles_info_;
}
inline ::COWA::NavMsg::Obstacles* BaseInfoDataType::release_obstacles_info() {
  // @@protoc_insertion_point(field_release:hmi.BaseInfoDataType.obstacles_info)
  clear_has_obstacles_info();
  ::COWA::NavMsg::Obstacles* temp = obstacles_info_;
  obstacles_info_ = NULL;
  return temp;
}
inline void BaseInfoDataType::set_allocated_obstacles_info(::COWA::NavMsg::Obstacles* obstacles_info) {
  delete obstacles_info_;
  obstacles_info_ = obstacles_info;
  if (obstacles_info) {
    set_has_obstacles_info();
  } else {
    clear_has_obstacles_info();
  }
  // @@protoc_insertion_point(field_set_allocated:hmi.BaseInfoDataType.obstacles_info)
}

// optional .COWA.NavMsg.TrafficLight2 trafficlight2_info = 5;
inline bool BaseInfoDataType::has_trafficlight2_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BaseInfoDataType::set_has_trafficlight2_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BaseInfoDataType::clear_has_trafficlight2_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BaseInfoDataType::clear_trafficlight2_info() {
  if (trafficlight2_info_ != NULL) trafficlight2_info_->::COWA::NavMsg::TrafficLight2::Clear();
  clear_has_trafficlight2_info();
}
inline const ::COWA::NavMsg::TrafficLight2& BaseInfoDataType::trafficlight2_info() const {
  // @@protoc_insertion_point(field_get:hmi.BaseInfoDataType.trafficlight2_info)
  return trafficlight2_info_ != NULL ? *trafficlight2_info_
                         : *::COWA::NavMsg::TrafficLight2::internal_default_instance();
}
inline ::COWA::NavMsg::TrafficLight2* BaseInfoDataType::mutable_trafficlight2_info() {
  set_has_trafficlight2_info();
  if (trafficlight2_info_ == NULL) {
    trafficlight2_info_ = new ::COWA::NavMsg::TrafficLight2;
  }
  // @@protoc_insertion_point(field_mutable:hmi.BaseInfoDataType.trafficlight2_info)
  return trafficlight2_info_;
}
inline ::COWA::NavMsg::TrafficLight2* BaseInfoDataType::release_trafficlight2_info() {
  // @@protoc_insertion_point(field_release:hmi.BaseInfoDataType.trafficlight2_info)
  clear_has_trafficlight2_info();
  ::COWA::NavMsg::TrafficLight2* temp = trafficlight2_info_;
  trafficlight2_info_ = NULL;
  return temp;
}
inline void BaseInfoDataType::set_allocated_trafficlight2_info(::COWA::NavMsg::TrafficLight2* trafficlight2_info) {
  delete trafficlight2_info_;
  trafficlight2_info_ = trafficlight2_info;
  if (trafficlight2_info) {
    set_has_trafficlight2_info();
  } else {
    clear_has_trafficlight2_info();
  }
  // @@protoc_insertion_point(field_set_allocated:hmi.BaseInfoDataType.trafficlight2_info)
}

// optional .COWA.NavMsg.VehicleDrive vehicle_drive_info = 6;
inline bool BaseInfoDataType::has_vehicle_drive_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BaseInfoDataType::set_has_vehicle_drive_info() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BaseInfoDataType::clear_has_vehicle_drive_info() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BaseInfoDataType::clear_vehicle_drive_info() {
  if (vehicle_drive_info_ != NULL) vehicle_drive_info_->::COWA::NavMsg::VehicleDrive::Clear();
  clear_has_vehicle_drive_info();
}
inline const ::COWA::NavMsg::VehicleDrive& BaseInfoDataType::vehicle_drive_info() const {
  // @@protoc_insertion_point(field_get:hmi.BaseInfoDataType.vehicle_drive_info)
  return vehicle_drive_info_ != NULL ? *vehicle_drive_info_
                         : *::COWA::NavMsg::VehicleDrive::internal_default_instance();
}
inline ::COWA::NavMsg::VehicleDrive* BaseInfoDataType::mutable_vehicle_drive_info() {
  set_has_vehicle_drive_info();
  if (vehicle_drive_info_ == NULL) {
    vehicle_drive_info_ = new ::COWA::NavMsg::VehicleDrive;
  }
  // @@protoc_insertion_point(field_mutable:hmi.BaseInfoDataType.vehicle_drive_info)
  return vehicle_drive_info_;
}
inline ::COWA::NavMsg::VehicleDrive* BaseInfoDataType::release_vehicle_drive_info() {
  // @@protoc_insertion_point(field_release:hmi.BaseInfoDataType.vehicle_drive_info)
  clear_has_vehicle_drive_info();
  ::COWA::NavMsg::VehicleDrive* temp = vehicle_drive_info_;
  vehicle_drive_info_ = NULL;
  return temp;
}
inline void BaseInfoDataType::set_allocated_vehicle_drive_info(::COWA::NavMsg::VehicleDrive* vehicle_drive_info) {
  delete vehicle_drive_info_;
  vehicle_drive_info_ = vehicle_drive_info;
  if (vehicle_drive_info) {
    set_has_vehicle_drive_info();
  } else {
    clear_has_vehicle_drive_info();
  }
  // @@protoc_insertion_point(field_set_allocated:hmi.BaseInfoDataType.vehicle_drive_info)
}

// optional .hmi.LaneInfoType lane_info = 7;
inline bool BaseInfoDataType::has_lane_info() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BaseInfoDataType::set_has_lane_info() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BaseInfoDataType::clear_has_lane_info() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BaseInfoDataType::clear_lane_info() {
  if (lane_info_ != NULL) lane_info_->::hmi::LaneInfoType::Clear();
  clear_has_lane_info();
}
inline const ::hmi::LaneInfoType& BaseInfoDataType::lane_info() const {
  // @@protoc_insertion_point(field_get:hmi.BaseInfoDataType.lane_info)
  return lane_info_ != NULL ? *lane_info_
                         : *::hmi::LaneInfoType::internal_default_instance();
}
inline ::hmi::LaneInfoType* BaseInfoDataType::mutable_lane_info() {
  set_has_lane_info();
  if (lane_info_ == NULL) {
    lane_info_ = new ::hmi::LaneInfoType;
  }
  // @@protoc_insertion_point(field_mutable:hmi.BaseInfoDataType.lane_info)
  return lane_info_;
}
inline ::hmi::LaneInfoType* BaseInfoDataType::release_lane_info() {
  // @@protoc_insertion_point(field_release:hmi.BaseInfoDataType.lane_info)
  clear_has_lane_info();
  ::hmi::LaneInfoType* temp = lane_info_;
  lane_info_ = NULL;
  return temp;
}
inline void BaseInfoDataType::set_allocated_lane_info(::hmi::LaneInfoType* lane_info) {
  delete lane_info_;
  lane_info_ = lane_info;
  if (lane_info) {
    set_has_lane_info();
  } else {
    clear_has_lane_info();
  }
  // @@protoc_insertion_point(field_set_allocated:hmi.BaseInfoDataType.lane_info)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace hmi

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_hmi_5fbase_5finfo_2eproto__INCLUDED
