// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: trafficlight.proto

#ifndef PROTOBUF_trafficlight_2eproto__INCLUDED
#define PROTOBUF_trafficlight_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "pose.pb.h"
// @@protoc_insertion_point(includes)
namespace COWA {
namespace NavMsg {
class Covariance;
class CovarianceDefaultTypeInternal;
extern CovarianceDefaultTypeInternal _Covariance_default_instance_;
class Point3D;
class Point3DDefaultTypeInternal;
extern Point3DDefaultTypeInternal _Point3D_default_instance_;
class Pose;
class PoseDefaultTypeInternal;
extern PoseDefaultTypeInternal _Pose_default_instance_;
class PoseStamped;
class PoseStampedDefaultTypeInternal;
extern PoseStampedDefaultTypeInternal _PoseStamped_default_instance_;
class PoseStampedArray;
class PoseStampedArrayDefaultTypeInternal;
extern PoseStampedArrayDefaultTypeInternal _PoseStampedArray_default_instance_;
class Quaternion;
class QuaternionDefaultTypeInternal;
extern QuaternionDefaultTypeInternal _Quaternion_default_instance_;
class TrafficLight;
class TrafficLightDefaultTypeInternal;
extern TrafficLightDefaultTypeInternal _TrafficLight_default_instance_;
class TrafficLight2;
class TrafficLight2DefaultTypeInternal;
extern TrafficLight2DefaultTypeInternal _TrafficLight2_default_instance_;
class TrafficLight2_Item;
class TrafficLight2_ItemDefaultTypeInternal;
extern TrafficLight2_ItemDefaultTypeInternal _TrafficLight2_Item_default_instance_;
class TrafficLightBBox;
class TrafficLightBBoxDefaultTypeInternal;
extern TrafficLightBBoxDefaultTypeInternal _TrafficLightBBox_default_instance_;
class TrafficLightDetection;
class TrafficLightDetectionDefaultTypeInternal;
extern TrafficLightDetectionDefaultTypeInternal _TrafficLightDetection_default_instance_;
class Velocity;
class VelocityDefaultTypeInternal;
extern VelocityDefaultTypeInternal _Velocity_default_instance_;
}  // namespace NavMsg
}  // namespace COWA

namespace COWA {
namespace NavMsg {

namespace protobuf_trafficlight_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_trafficlight_2eproto

enum TrafficLight_Color {
  TrafficLight_Color_UNKNOWN = 0,
  TrafficLight_Color_RED = 1,
  TrafficLight_Color_YELLOW = 2,
  TrafficLight_Color_GREEN = 3,
  TrafficLight_Color_BLACK = 4,
  TrafficLight_Color_WAIT = 5
};
bool TrafficLight_Color_IsValid(int value);
const TrafficLight_Color TrafficLight_Color_Color_MIN = TrafficLight_Color_UNKNOWN;
const TrafficLight_Color TrafficLight_Color_Color_MAX = TrafficLight_Color_WAIT;
const int TrafficLight_Color_Color_ARRAYSIZE = TrafficLight_Color_Color_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficLight_Color_descriptor();
inline const ::std::string& TrafficLight_Color_Name(TrafficLight_Color value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficLight_Color_descriptor(), value);
}
inline bool TrafficLight_Color_Parse(
    const ::std::string& name, TrafficLight_Color* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficLight_Color>(
    TrafficLight_Color_descriptor(), name, value);
}
enum TrafficLight2_State {
  TrafficLight2_State_GREEN = 1,
  TrafficLight2_State_RED = 2,
  TrafficLight2_State_YELLOW = 3,
  TrafficLight2_State_UNKNOWN = 4
};
bool TrafficLight2_State_IsValid(int value);
const TrafficLight2_State TrafficLight2_State_State_MIN = TrafficLight2_State_GREEN;
const TrafficLight2_State TrafficLight2_State_State_MAX = TrafficLight2_State_UNKNOWN;
const int TrafficLight2_State_State_ARRAYSIZE = TrafficLight2_State_State_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficLight2_State_descriptor();
inline const ::std::string& TrafficLight2_State_Name(TrafficLight2_State value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficLight2_State_descriptor(), value);
}
inline bool TrafficLight2_State_Parse(
    const ::std::string& name, TrafficLight2_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficLight2_State>(
    TrafficLight2_State_descriptor(), name, value);
}
enum TrafficLight2_Direction {
  TrafficLight2_Direction_FORWARD = 1,
  TrafficLight2_Direction_LEFT = 2,
  TrafficLight2_Direction_RIGHT = 3,
  TrafficLight2_Direction_UTURN = 4
};
bool TrafficLight2_Direction_IsValid(int value);
const TrafficLight2_Direction TrafficLight2_Direction_Direction_MIN = TrafficLight2_Direction_FORWARD;
const TrafficLight2_Direction TrafficLight2_Direction_Direction_MAX = TrafficLight2_Direction_UTURN;
const int TrafficLight2_Direction_Direction_ARRAYSIZE = TrafficLight2_Direction_Direction_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficLight2_Direction_descriptor();
inline const ::std::string& TrafficLight2_Direction_Name(TrafficLight2_Direction value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficLight2_Direction_descriptor(), value);
}
inline bool TrafficLight2_Direction_Parse(
    const ::std::string& name, TrafficLight2_Direction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficLight2_Direction>(
    TrafficLight2_Direction_descriptor(), name, value);
}
// ===================================================================

class TrafficLightBBox : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.NavMsg.TrafficLightBBox) */ {
 public:
  TrafficLightBBox();
  virtual ~TrafficLightBBox();

  TrafficLightBBox(const TrafficLightBBox& from);

  inline TrafficLightBBox& operator=(const TrafficLightBBox& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficLightBBox& default_instance();

  static inline const TrafficLightBBox* internal_default_instance() {
    return reinterpret_cast<const TrafficLightBBox*>(
               &_TrafficLightBBox_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(TrafficLightBBox* other);

  // implements Message ----------------------------------------------

  inline TrafficLightBBox* New() const PROTOBUF_FINAL { return New(NULL); }

  TrafficLightBBox* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrafficLightBBox& from);
  void MergeFrom(const TrafficLightBBox& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrafficLightBBox* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 x1 = 1;
  bool has_x1() const;
  void clear_x1();
  static const int kX1FieldNumber = 1;
  ::google::protobuf::int32 x1() const;
  void set_x1(::google::protobuf::int32 value);

  // optional int32 y1 = 2;
  bool has_y1() const;
  void clear_y1();
  static const int kY1FieldNumber = 2;
  ::google::protobuf::int32 y1() const;
  void set_y1(::google::protobuf::int32 value);

  // optional int32 x2 = 3;
  bool has_x2() const;
  void clear_x2();
  static const int kX2FieldNumber = 3;
  ::google::protobuf::int32 x2() const;
  void set_x2(::google::protobuf::int32 value);

  // optional int32 y2 = 4;
  bool has_y2() const;
  void clear_y2();
  static const int kY2FieldNumber = 4;
  ::google::protobuf::int32 y2() const;
  void set_y2(::google::protobuf::int32 value);

  // optional bool is_wait = 5 [default = false];
  bool has_is_wait() const;
  void clear_is_wait();
  static const int kIsWaitFieldNumber = 5;
  bool is_wait() const;
  void set_is_wait(bool value);

  // optional int32 depth = 6;
  bool has_depth() const;
  void clear_depth();
  static const int kDepthFieldNumber = 6;
  ::google::protobuf::int32 depth() const;
  void set_depth(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:COWA.NavMsg.TrafficLightBBox)
 private:
  void set_has_x1();
  void clear_has_x1();
  void set_has_y1();
  void clear_has_y1();
  void set_has_x2();
  void clear_has_x2();
  void set_has_y2();
  void clear_has_y2();
  void set_has_depth();
  void clear_has_depth();
  void set_has_is_wait();
  void clear_has_is_wait();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 x1_;
  ::google::protobuf::int32 y1_;
  ::google::protobuf::int32 x2_;
  ::google::protobuf::int32 y2_;
  bool is_wait_;
  ::google::protobuf::int32 depth_;
  friend struct protobuf_trafficlight_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrafficLight : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.NavMsg.TrafficLight) */ {
 public:
  TrafficLight();
  virtual ~TrafficLight();

  TrafficLight(const TrafficLight& from);

  inline TrafficLight& operator=(const TrafficLight& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficLight& default_instance();

  static inline const TrafficLight* internal_default_instance() {
    return reinterpret_cast<const TrafficLight*>(
               &_TrafficLight_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(TrafficLight* other);

  // implements Message ----------------------------------------------

  inline TrafficLight* New() const PROTOBUF_FINAL { return New(NULL); }

  TrafficLight* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrafficLight& from);
  void MergeFrom(const TrafficLight& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrafficLight* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef TrafficLight_Color Color;
  static const Color UNKNOWN =
    TrafficLight_Color_UNKNOWN;
  static const Color RED =
    TrafficLight_Color_RED;
  static const Color YELLOW =
    TrafficLight_Color_YELLOW;
  static const Color GREEN =
    TrafficLight_Color_GREEN;
  static const Color BLACK =
    TrafficLight_Color_BLACK;
  static const Color WAIT =
    TrafficLight_Color_WAIT;
  static inline bool Color_IsValid(int value) {
    return TrafficLight_Color_IsValid(value);
  }
  static const Color Color_MIN =
    TrafficLight_Color_Color_MIN;
  static const Color Color_MAX =
    TrafficLight_Color_Color_MAX;
  static const int Color_ARRAYSIZE =
    TrafficLight_Color_Color_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Color_descriptor() {
    return TrafficLight_Color_descriptor();
  }
  static inline const ::std::string& Color_Name(Color value) {
    return TrafficLight_Color_Name(value);
  }
  static inline bool Color_Parse(const ::std::string& name,
      Color* value) {
    return TrafficLight_Color_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional bytes id = 2;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 2;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const void* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional .COWA.NavMsg.PoseStamped center = 7;
  bool has_center() const;
  void clear_center();
  static const int kCenterFieldNumber = 7;
  const ::COWA::NavMsg::PoseStamped& center() const;
  ::COWA::NavMsg::PoseStamped* mutable_center();
  ::COWA::NavMsg::PoseStamped* release_center();
  void set_allocated_center(::COWA::NavMsg::PoseStamped* center);

  // optional .COWA.NavMsg.TrafficLight.Color color = 1;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 1;
  ::COWA::NavMsg::TrafficLight_Color color() const;
  void set_color(::COWA::NavMsg::TrafficLight_Color value);

  // optional bool blink = 5;
  bool has_blink() const;
  void clear_blink();
  static const int kBlinkFieldNumber = 5;
  bool blink() const;
  void set_blink(bool value);

  // optional double tracking_time = 4;
  bool has_tracking_time() const;
  void clear_tracking_time();
  static const int kTrackingTimeFieldNumber = 4;
  double tracking_time() const;
  void set_tracking_time(double value);

  // optional double remaining_time = 6;
  bool has_remaining_time() const;
  void clear_remaining_time();
  static const int kRemainingTimeFieldNumber = 6;
  double remaining_time() const;
  void set_remaining_time(double value);

  // optional double confidence = 3 [default = 1];
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 3;
  double confidence() const;
  void set_confidence(double value);

  // @@protoc_insertion_point(class_scope:COWA.NavMsg.TrafficLight)
 private:
  void set_has_color();
  void clear_has_color();
  void set_has_id();
  void clear_has_id();
  void set_has_confidence();
  void clear_has_confidence();
  void set_has_tracking_time();
  void clear_has_tracking_time();
  void set_has_blink();
  void clear_has_blink();
  void set_has_remaining_time();
  void clear_has_remaining_time();
  void set_has_center();
  void clear_has_center();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::COWA::NavMsg::PoseStamped* center_;
  int color_;
  bool blink_;
  double tracking_time_;
  double remaining_time_;
  double confidence_;
  friend struct protobuf_trafficlight_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrafficLightDetection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.NavMsg.TrafficLightDetection) */ {
 public:
  TrafficLightDetection();
  virtual ~TrafficLightDetection();

  TrafficLightDetection(const TrafficLightDetection& from);

  inline TrafficLightDetection& operator=(const TrafficLightDetection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficLightDetection& default_instance();

  static inline const TrafficLightDetection* internal_default_instance() {
    return reinterpret_cast<const TrafficLightDetection*>(
               &_TrafficLightDetection_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(TrafficLightDetection* other);

  // implements Message ----------------------------------------------

  inline TrafficLightDetection* New() const PROTOBUF_FINAL { return New(NULL); }

  TrafficLightDetection* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrafficLightDetection& from);
  void MergeFrom(const TrafficLightDetection& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrafficLightDetection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .COWA.NavMsg.TrafficLight traffic_light = 3;
  int traffic_light_size() const;
  void clear_traffic_light();
  static const int kTrafficLightFieldNumber = 3;
  const ::COWA::NavMsg::TrafficLight& traffic_light(int index) const;
  ::COWA::NavMsg::TrafficLight* mutable_traffic_light(int index);
  ::COWA::NavMsg::TrafficLight* add_traffic_light();
  ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::TrafficLight >*
      mutable_traffic_light();
  const ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::TrafficLight >&
      traffic_light() const;

  // repeated .COWA.NavMsg.TrafficLightBBox roi_detected = 5;
  int roi_detected_size() const;
  void clear_roi_detected();
  static const int kRoiDetectedFieldNumber = 5;
  const ::COWA::NavMsg::TrafficLightBBox& roi_detected(int index) const;
  ::COWA::NavMsg::TrafficLightBBox* mutable_roi_detected(int index);
  ::COWA::NavMsg::TrafficLightBBox* add_roi_detected();
  ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::TrafficLightBBox >*
      mutable_roi_detected();
  const ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::TrafficLightBBox >&
      roi_detected() const;

  // repeated bytes signal_id = 7;
  int signal_id_size() const;
  void clear_signal_id();
  static const int kSignalIdFieldNumber = 7;
  const ::std::string& signal_id(int index) const;
  ::std::string* mutable_signal_id(int index);
  void set_signal_id(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_signal_id(int index, ::std::string&& value);
  #endif
  void set_signal_id(int index, const char* value);
  void set_signal_id(int index, const void* value, size_t size);
  ::std::string* add_signal_id();
  void add_signal_id(const ::std::string& value);
  #if LANG_CXX11
  void add_signal_id(::std::string&& value);
  #endif
  void add_signal_id(const char* value);
  void add_signal_id(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& signal_id() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_signal_id();

  // optional bytes camera_id = 4;
  bool has_camera_id() const;
  void clear_camera_id();
  static const int kCameraIdFieldNumber = 4;
  const ::std::string& camera_id() const;
  void set_camera_id(const ::std::string& value);
  #if LANG_CXX11
  void set_camera_id(::std::string&& value);
  #endif
  void set_camera_id(const char* value);
  void set_camera_id(const void* value, size_t size);
  ::std::string* mutable_camera_id();
  ::std::string* release_camera_id();
  void set_allocated_camera_id(::std::string* camera_id);

  // optional .COWA.NavMsg.PoseStamped vehicle_pose = 6;
  bool has_vehicle_pose() const;
  void clear_vehicle_pose();
  static const int kVehiclePoseFieldNumber = 6;
  const ::COWA::NavMsg::PoseStamped& vehicle_pose() const;
  ::COWA::NavMsg::PoseStamped* mutable_vehicle_pose();
  ::COWA::NavMsg::PoseStamped* release_vehicle_pose();
  void set_allocated_vehicle_pose(::COWA::NavMsg::PoseStamped* vehicle_pose);

  // optional uint64 timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // optional uint32 sequence = 2;
  bool has_sequence() const;
  void clear_sequence();
  static const int kSequenceFieldNumber = 2;
  ::google::protobuf::uint32 sequence() const;
  void set_sequence(::google::protobuf::uint32 value);

  // optional int32 latency_ms = 8;
  bool has_latency_ms() const;
  void clear_latency_ms();
  static const int kLatencyMsFieldNumber = 8;
  ::google::protobuf::int32 latency_ms() const;
  void set_latency_ms(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:COWA.NavMsg.TrafficLightDetection)
 private:
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_sequence();
  void clear_has_sequence();
  void set_has_camera_id();
  void clear_has_camera_id();
  void set_has_vehicle_pose();
  void clear_has_vehicle_pose();
  void set_has_latency_ms();
  void clear_has_latency_ms();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::TrafficLight > traffic_light_;
  ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::TrafficLightBBox > roi_detected_;
  ::google::protobuf::RepeatedPtrField< ::std::string> signal_id_;
  ::google::protobuf::internal::ArenaStringPtr camera_id_;
  ::COWA::NavMsg::PoseStamped* vehicle_pose_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::uint32 sequence_;
  ::google::protobuf::int32 latency_ms_;
  friend struct protobuf_trafficlight_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrafficLight2_Item : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.NavMsg.TrafficLight2.Item) */ {
 public:
  TrafficLight2_Item();
  virtual ~TrafficLight2_Item();

  TrafficLight2_Item(const TrafficLight2_Item& from);

  inline TrafficLight2_Item& operator=(const TrafficLight2_Item& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficLight2_Item& default_instance();

  static inline const TrafficLight2_Item* internal_default_instance() {
    return reinterpret_cast<const TrafficLight2_Item*>(
               &_TrafficLight2_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(TrafficLight2_Item* other);

  // implements Message ----------------------------------------------

  inline TrafficLight2_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  TrafficLight2_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrafficLight2_Item& from);
  void MergeFrom(const TrafficLight2_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrafficLight2_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float remaining = 3;
  bool has_remaining() const;
  void clear_remaining();
  static const int kRemainingFieldNumber = 3;
  float remaining() const;
  void set_remaining(float value);

  // optional bool blink = 4;
  bool has_blink() const;
  void clear_blink();
  static const int kBlinkFieldNumber = 4;
  bool blink() const;
  void set_blink(bool value);

  // optional .COWA.NavMsg.TrafficLight2.Direction dir = 1;
  bool has_dir() const;
  void clear_dir();
  static const int kDirFieldNumber = 1;
  ::COWA::NavMsg::TrafficLight2_Direction dir() const;
  void set_dir(::COWA::NavMsg::TrafficLight2_Direction value);

  // optional .COWA.NavMsg.TrafficLight2.State state = 2;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 2;
  ::COWA::NavMsg::TrafficLight2_State state() const;
  void set_state(::COWA::NavMsg::TrafficLight2_State value);

  // @@protoc_insertion_point(class_scope:COWA.NavMsg.TrafficLight2.Item)
 private:
  void set_has_dir();
  void clear_has_dir();
  void set_has_state();
  void clear_has_state();
  void set_has_remaining();
  void clear_has_remaining();
  void set_has_blink();
  void clear_has_blink();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float remaining_;
  bool blink_;
  int dir_;
  int state_;
  friend struct protobuf_trafficlight_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrafficLight2 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.NavMsg.TrafficLight2) */ {
 public:
  TrafficLight2();
  virtual ~TrafficLight2();

  TrafficLight2(const TrafficLight2& from);

  inline TrafficLight2& operator=(const TrafficLight2& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficLight2& default_instance();

  static inline const TrafficLight2* internal_default_instance() {
    return reinterpret_cast<const TrafficLight2*>(
               &_TrafficLight2_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(TrafficLight2* other);

  // implements Message ----------------------------------------------

  inline TrafficLight2* New() const PROTOBUF_FINAL { return New(NULL); }

  TrafficLight2* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrafficLight2& from);
  void MergeFrom(const TrafficLight2& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrafficLight2* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef TrafficLight2_Item Item;

  typedef TrafficLight2_State State;
  static const State GREEN =
    TrafficLight2_State_GREEN;
  static const State RED =
    TrafficLight2_State_RED;
  static const State YELLOW =
    TrafficLight2_State_YELLOW;
  static const State UNKNOWN =
    TrafficLight2_State_UNKNOWN;
  static inline bool State_IsValid(int value) {
    return TrafficLight2_State_IsValid(value);
  }
  static const State State_MIN =
    TrafficLight2_State_State_MIN;
  static const State State_MAX =
    TrafficLight2_State_State_MAX;
  static const int State_ARRAYSIZE =
    TrafficLight2_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  State_descriptor() {
    return TrafficLight2_State_descriptor();
  }
  static inline const ::std::string& State_Name(State value) {
    return TrafficLight2_State_Name(value);
  }
  static inline bool State_Parse(const ::std::string& name,
      State* value) {
    return TrafficLight2_State_Parse(name, value);
  }

  typedef TrafficLight2_Direction Direction;
  static const Direction FORWARD =
    TrafficLight2_Direction_FORWARD;
  static const Direction LEFT =
    TrafficLight2_Direction_LEFT;
  static const Direction RIGHT =
    TrafficLight2_Direction_RIGHT;
  static const Direction UTURN =
    TrafficLight2_Direction_UTURN;
  static inline bool Direction_IsValid(int value) {
    return TrafficLight2_Direction_IsValid(value);
  }
  static const Direction Direction_MIN =
    TrafficLight2_Direction_Direction_MIN;
  static const Direction Direction_MAX =
    TrafficLight2_Direction_Direction_MAX;
  static const int Direction_ARRAYSIZE =
    TrafficLight2_Direction_Direction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Direction_descriptor() {
    return TrafficLight2_Direction_descriptor();
  }
  static inline const ::std::string& Direction_Name(Direction value) {
    return TrafficLight2_Direction_Name(value);
  }
  static inline bool Direction_Parse(const ::std::string& name,
      Direction* value) {
    return TrafficLight2_Direction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .COWA.NavMsg.TrafficLight2.Item lights = 3;
  int lights_size() const;
  void clear_lights();
  static const int kLightsFieldNumber = 3;
  const ::COWA::NavMsg::TrafficLight2_Item& lights(int index) const;
  ::COWA::NavMsg::TrafficLight2_Item* mutable_lights(int index);
  ::COWA::NavMsg::TrafficLight2_Item* add_lights();
  ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::TrafficLight2_Item >*
      mutable_lights();
  const ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::TrafficLight2_Item >&
      lights() const;

  // repeated .COWA.NavMsg.TrafficLightBBox detected = 6;
  int detected_size() const;
  void clear_detected();
  static const int kDetectedFieldNumber = 6;
  const ::COWA::NavMsg::TrafficLightBBox& detected(int index) const;
  ::COWA::NavMsg::TrafficLightBBox* mutable_detected(int index);
  ::COWA::NavMsg::TrafficLightBBox* add_detected();
  ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::TrafficLightBBox >*
      mutable_detected();
  const ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::TrafficLightBBox >&
      detected() const;

  // optional string crossroad_id = 4;
  bool has_crossroad_id() const;
  void clear_crossroad_id();
  static const int kCrossroadIdFieldNumber = 4;
  const ::std::string& crossroad_id() const;
  void set_crossroad_id(const ::std::string& value);
  #if LANG_CXX11
  void set_crossroad_id(::std::string&& value);
  #endif
  void set_crossroad_id(const char* value);
  void set_crossroad_id(const char* value, size_t size);
  ::std::string* mutable_crossroad_id();
  ::std::string* release_crossroad_id();
  void set_allocated_crossroad_id(::std::string* crossroad_id);

  // optional uint64 timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // optional uint32 sequence = 2;
  bool has_sequence() const;
  void clear_sequence();
  static const int kSequenceFieldNumber = 2;
  ::google::protobuf::uint32 sequence() const;
  void set_sequence(::google::protobuf::uint32 value);

  // optional float yaw = 5;
  bool has_yaw() const;
  void clear_yaw();
  static const int kYawFieldNumber = 5;
  float yaw() const;
  void set_yaw(float value);

  // @@protoc_insertion_point(class_scope:COWA.NavMsg.TrafficLight2)
 private:
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_sequence();
  void clear_has_sequence();
  void set_has_crossroad_id();
  void clear_has_crossroad_id();
  void set_has_yaw();
  void clear_has_yaw();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::TrafficLight2_Item > lights_;
  ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::TrafficLightBBox > detected_;
  ::google::protobuf::internal::ArenaStringPtr crossroad_id_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::uint32 sequence_;
  float yaw_;
  friend struct protobuf_trafficlight_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// TrafficLightBBox

// optional int32 x1 = 1;
inline bool TrafficLightBBox::has_x1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrafficLightBBox::set_has_x1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrafficLightBBox::clear_has_x1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrafficLightBBox::clear_x1() {
  x1_ = 0;
  clear_has_x1();
}
inline ::google::protobuf::int32 TrafficLightBBox::x1() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.TrafficLightBBox.x1)
  return x1_;
}
inline void TrafficLightBBox::set_x1(::google::protobuf::int32 value) {
  set_has_x1();
  x1_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.TrafficLightBBox.x1)
}

// optional int32 y1 = 2;
inline bool TrafficLightBBox::has_y1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrafficLightBBox::set_has_y1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrafficLightBBox::clear_has_y1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrafficLightBBox::clear_y1() {
  y1_ = 0;
  clear_has_y1();
}
inline ::google::protobuf::int32 TrafficLightBBox::y1() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.TrafficLightBBox.y1)
  return y1_;
}
inline void TrafficLightBBox::set_y1(::google::protobuf::int32 value) {
  set_has_y1();
  y1_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.TrafficLightBBox.y1)
}

// optional int32 x2 = 3;
inline bool TrafficLightBBox::has_x2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrafficLightBBox::set_has_x2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrafficLightBBox::clear_has_x2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrafficLightBBox::clear_x2() {
  x2_ = 0;
  clear_has_x2();
}
inline ::google::protobuf::int32 TrafficLightBBox::x2() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.TrafficLightBBox.x2)
  return x2_;
}
inline void TrafficLightBBox::set_x2(::google::protobuf::int32 value) {
  set_has_x2();
  x2_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.TrafficLightBBox.x2)
}

// optional int32 y2 = 4;
inline bool TrafficLightBBox::has_y2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrafficLightBBox::set_has_y2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrafficLightBBox::clear_has_y2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrafficLightBBox::clear_y2() {
  y2_ = 0;
  clear_has_y2();
}
inline ::google::protobuf::int32 TrafficLightBBox::y2() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.TrafficLightBBox.y2)
  return y2_;
}
inline void TrafficLightBBox::set_y2(::google::protobuf::int32 value) {
  set_has_y2();
  y2_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.TrafficLightBBox.y2)
}

// optional int32 depth = 6;
inline bool TrafficLightBBox::has_depth() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TrafficLightBBox::set_has_depth() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TrafficLightBBox::clear_has_depth() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TrafficLightBBox::clear_depth() {
  depth_ = 0;
  clear_has_depth();
}
inline ::google::protobuf::int32 TrafficLightBBox::depth() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.TrafficLightBBox.depth)
  return depth_;
}
inline void TrafficLightBBox::set_depth(::google::protobuf::int32 value) {
  set_has_depth();
  depth_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.TrafficLightBBox.depth)
}

// optional bool is_wait = 5 [default = false];
inline bool TrafficLightBBox::has_is_wait() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TrafficLightBBox::set_has_is_wait() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TrafficLightBBox::clear_has_is_wait() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TrafficLightBBox::clear_is_wait() {
  is_wait_ = false;
  clear_has_is_wait();
}
inline bool TrafficLightBBox::is_wait() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.TrafficLightBBox.is_wait)
  return is_wait_;
}
inline void TrafficLightBBox::set_is_wait(bool value) {
  set_has_is_wait();
  is_wait_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.TrafficLightBBox.is_wait)
}

// -------------------------------------------------------------------

// TrafficLight

// optional .COWA.NavMsg.TrafficLight.Color color = 1;
inline bool TrafficLight::has_color() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrafficLight::set_has_color() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrafficLight::clear_has_color() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrafficLight::clear_color() {
  color_ = 0;
  clear_has_color();
}
inline ::COWA::NavMsg::TrafficLight_Color TrafficLight::color() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.TrafficLight.color)
  return static_cast< ::COWA::NavMsg::TrafficLight_Color >(color_);
}
inline void TrafficLight::set_color(::COWA::NavMsg::TrafficLight_Color value) {
  assert(::COWA::NavMsg::TrafficLight_Color_IsValid(value));
  set_has_color();
  color_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.TrafficLight.color)
}

// optional bytes id = 2;
inline bool TrafficLight::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrafficLight::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrafficLight::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrafficLight::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& TrafficLight::id() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.TrafficLight.id)
  return id_.GetNoArena();
}
inline void TrafficLight::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:COWA.NavMsg.TrafficLight.id)
}
#if LANG_CXX11
inline void TrafficLight::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:COWA.NavMsg.TrafficLight.id)
}
#endif
inline void TrafficLight::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:COWA.NavMsg.TrafficLight.id)
}
inline void TrafficLight::set_id(const void* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:COWA.NavMsg.TrafficLight.id)
}
inline ::std::string* TrafficLight::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:COWA.NavMsg.TrafficLight.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TrafficLight::release_id() {
  // @@protoc_insertion_point(field_release:COWA.NavMsg.TrafficLight.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TrafficLight::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:COWA.NavMsg.TrafficLight.id)
}

// optional double confidence = 3 [default = 1];
inline bool TrafficLight::has_confidence() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TrafficLight::set_has_confidence() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TrafficLight::clear_has_confidence() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TrafficLight::clear_confidence() {
  confidence_ = 1;
  clear_has_confidence();
}
inline double TrafficLight::confidence() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.TrafficLight.confidence)
  return confidence_;
}
inline void TrafficLight::set_confidence(double value) {
  set_has_confidence();
  confidence_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.TrafficLight.confidence)
}

// optional double tracking_time = 4;
inline bool TrafficLight::has_tracking_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TrafficLight::set_has_tracking_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TrafficLight::clear_has_tracking_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TrafficLight::clear_tracking_time() {
  tracking_time_ = 0;
  clear_has_tracking_time();
}
inline double TrafficLight::tracking_time() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.TrafficLight.tracking_time)
  return tracking_time_;
}
inline void TrafficLight::set_tracking_time(double value) {
  set_has_tracking_time();
  tracking_time_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.TrafficLight.tracking_time)
}

// optional bool blink = 5;
inline bool TrafficLight::has_blink() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrafficLight::set_has_blink() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrafficLight::clear_has_blink() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrafficLight::clear_blink() {
  blink_ = false;
  clear_has_blink();
}
inline bool TrafficLight::blink() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.TrafficLight.blink)
  return blink_;
}
inline void TrafficLight::set_blink(bool value) {
  set_has_blink();
  blink_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.TrafficLight.blink)
}

// optional double remaining_time = 6;
inline bool TrafficLight::has_remaining_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TrafficLight::set_has_remaining_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TrafficLight::clear_has_remaining_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TrafficLight::clear_remaining_time() {
  remaining_time_ = 0;
  clear_has_remaining_time();
}
inline double TrafficLight::remaining_time() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.TrafficLight.remaining_time)
  return remaining_time_;
}
inline void TrafficLight::set_remaining_time(double value) {
  set_has_remaining_time();
  remaining_time_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.TrafficLight.remaining_time)
}

// optional .COWA.NavMsg.PoseStamped center = 7;
inline bool TrafficLight::has_center() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrafficLight::set_has_center() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrafficLight::clear_has_center() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrafficLight::clear_center() {
  if (center_ != NULL) center_->::COWA::NavMsg::PoseStamped::Clear();
  clear_has_center();
}
inline const ::COWA::NavMsg::PoseStamped& TrafficLight::center() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.TrafficLight.center)
  return center_ != NULL ? *center_
                         : *::COWA::NavMsg::PoseStamped::internal_default_instance();
}
inline ::COWA::NavMsg::PoseStamped* TrafficLight::mutable_center() {
  set_has_center();
  if (center_ == NULL) {
    center_ = new ::COWA::NavMsg::PoseStamped;
  }
  // @@protoc_insertion_point(field_mutable:COWA.NavMsg.TrafficLight.center)
  return center_;
}
inline ::COWA::NavMsg::PoseStamped* TrafficLight::release_center() {
  // @@protoc_insertion_point(field_release:COWA.NavMsg.TrafficLight.center)
  clear_has_center();
  ::COWA::NavMsg::PoseStamped* temp = center_;
  center_ = NULL;
  return temp;
}
inline void TrafficLight::set_allocated_center(::COWA::NavMsg::PoseStamped* center) {
  delete center_;
  center_ = center;
  if (center) {
    set_has_center();
  } else {
    clear_has_center();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.NavMsg.TrafficLight.center)
}

// -------------------------------------------------------------------

// TrafficLightDetection

// optional uint64 timestamp = 1;
inline bool TrafficLightDetection::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrafficLightDetection::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrafficLightDetection::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrafficLightDetection::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 TrafficLightDetection::timestamp() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.TrafficLightDetection.timestamp)
  return timestamp_;
}
inline void TrafficLightDetection::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.TrafficLightDetection.timestamp)
}

// optional uint32 sequence = 2;
inline bool TrafficLightDetection::has_sequence() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrafficLightDetection::set_has_sequence() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrafficLightDetection::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrafficLightDetection::clear_sequence() {
  sequence_ = 0u;
  clear_has_sequence();
}
inline ::google::protobuf::uint32 TrafficLightDetection::sequence() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.TrafficLightDetection.sequence)
  return sequence_;
}
inline void TrafficLightDetection::set_sequence(::google::protobuf::uint32 value) {
  set_has_sequence();
  sequence_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.TrafficLightDetection.sequence)
}

// repeated .COWA.NavMsg.TrafficLight traffic_light = 3;
inline int TrafficLightDetection::traffic_light_size() const {
  return traffic_light_.size();
}
inline void TrafficLightDetection::clear_traffic_light() {
  traffic_light_.Clear();
}
inline const ::COWA::NavMsg::TrafficLight& TrafficLightDetection::traffic_light(int index) const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.TrafficLightDetection.traffic_light)
  return traffic_light_.Get(index);
}
inline ::COWA::NavMsg::TrafficLight* TrafficLightDetection::mutable_traffic_light(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.NavMsg.TrafficLightDetection.traffic_light)
  return traffic_light_.Mutable(index);
}
inline ::COWA::NavMsg::TrafficLight* TrafficLightDetection::add_traffic_light() {
  // @@protoc_insertion_point(field_add:COWA.NavMsg.TrafficLightDetection.traffic_light)
  return traffic_light_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::TrafficLight >*
TrafficLightDetection::mutable_traffic_light() {
  // @@protoc_insertion_point(field_mutable_list:COWA.NavMsg.TrafficLightDetection.traffic_light)
  return &traffic_light_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::TrafficLight >&
TrafficLightDetection::traffic_light() const {
  // @@protoc_insertion_point(field_list:COWA.NavMsg.TrafficLightDetection.traffic_light)
  return traffic_light_;
}

// optional bytes camera_id = 4;
inline bool TrafficLightDetection::has_camera_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrafficLightDetection::set_has_camera_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrafficLightDetection::clear_has_camera_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrafficLightDetection::clear_camera_id() {
  camera_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_camera_id();
}
inline const ::std::string& TrafficLightDetection::camera_id() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.TrafficLightDetection.camera_id)
  return camera_id_.GetNoArena();
}
inline void TrafficLightDetection::set_camera_id(const ::std::string& value) {
  set_has_camera_id();
  camera_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:COWA.NavMsg.TrafficLightDetection.camera_id)
}
#if LANG_CXX11
inline void TrafficLightDetection::set_camera_id(::std::string&& value) {
  set_has_camera_id();
  camera_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:COWA.NavMsg.TrafficLightDetection.camera_id)
}
#endif
inline void TrafficLightDetection::set_camera_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_camera_id();
  camera_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:COWA.NavMsg.TrafficLightDetection.camera_id)
}
inline void TrafficLightDetection::set_camera_id(const void* value, size_t size) {
  set_has_camera_id();
  camera_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:COWA.NavMsg.TrafficLightDetection.camera_id)
}
inline ::std::string* TrafficLightDetection::mutable_camera_id() {
  set_has_camera_id();
  // @@protoc_insertion_point(field_mutable:COWA.NavMsg.TrafficLightDetection.camera_id)
  return camera_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TrafficLightDetection::release_camera_id() {
  // @@protoc_insertion_point(field_release:COWA.NavMsg.TrafficLightDetection.camera_id)
  clear_has_camera_id();
  return camera_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TrafficLightDetection::set_allocated_camera_id(::std::string* camera_id) {
  if (camera_id != NULL) {
    set_has_camera_id();
  } else {
    clear_has_camera_id();
  }
  camera_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), camera_id);
  // @@protoc_insertion_point(field_set_allocated:COWA.NavMsg.TrafficLightDetection.camera_id)
}

// repeated .COWA.NavMsg.TrafficLightBBox roi_detected = 5;
inline int TrafficLightDetection::roi_detected_size() const {
  return roi_detected_.size();
}
inline void TrafficLightDetection::clear_roi_detected() {
  roi_detected_.Clear();
}
inline const ::COWA::NavMsg::TrafficLightBBox& TrafficLightDetection::roi_detected(int index) const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.TrafficLightDetection.roi_detected)
  return roi_detected_.Get(index);
}
inline ::COWA::NavMsg::TrafficLightBBox* TrafficLightDetection::mutable_roi_detected(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.NavMsg.TrafficLightDetection.roi_detected)
  return roi_detected_.Mutable(index);
}
inline ::COWA::NavMsg::TrafficLightBBox* TrafficLightDetection::add_roi_detected() {
  // @@protoc_insertion_point(field_add:COWA.NavMsg.TrafficLightDetection.roi_detected)
  return roi_detected_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::TrafficLightBBox >*
TrafficLightDetection::mutable_roi_detected() {
  // @@protoc_insertion_point(field_mutable_list:COWA.NavMsg.TrafficLightDetection.roi_detected)
  return &roi_detected_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::TrafficLightBBox >&
TrafficLightDetection::roi_detected() const {
  // @@protoc_insertion_point(field_list:COWA.NavMsg.TrafficLightDetection.roi_detected)
  return roi_detected_;
}

// optional .COWA.NavMsg.PoseStamped vehicle_pose = 6;
inline bool TrafficLightDetection::has_vehicle_pose() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrafficLightDetection::set_has_vehicle_pose() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrafficLightDetection::clear_has_vehicle_pose() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrafficLightDetection::clear_vehicle_pose() {
  if (vehicle_pose_ != NULL) vehicle_pose_->::COWA::NavMsg::PoseStamped::Clear();
  clear_has_vehicle_pose();
}
inline const ::COWA::NavMsg::PoseStamped& TrafficLightDetection::vehicle_pose() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.TrafficLightDetection.vehicle_pose)
  return vehicle_pose_ != NULL ? *vehicle_pose_
                         : *::COWA::NavMsg::PoseStamped::internal_default_instance();
}
inline ::COWA::NavMsg::PoseStamped* TrafficLightDetection::mutable_vehicle_pose() {
  set_has_vehicle_pose();
  if (vehicle_pose_ == NULL) {
    vehicle_pose_ = new ::COWA::NavMsg::PoseStamped;
  }
  // @@protoc_insertion_point(field_mutable:COWA.NavMsg.TrafficLightDetection.vehicle_pose)
  return vehicle_pose_;
}
inline ::COWA::NavMsg::PoseStamped* TrafficLightDetection::release_vehicle_pose() {
  // @@protoc_insertion_point(field_release:COWA.NavMsg.TrafficLightDetection.vehicle_pose)
  clear_has_vehicle_pose();
  ::COWA::NavMsg::PoseStamped* temp = vehicle_pose_;
  vehicle_pose_ = NULL;
  return temp;
}
inline void TrafficLightDetection::set_allocated_vehicle_pose(::COWA::NavMsg::PoseStamped* vehicle_pose) {
  delete vehicle_pose_;
  vehicle_pose_ = vehicle_pose;
  if (vehicle_pose) {
    set_has_vehicle_pose();
  } else {
    clear_has_vehicle_pose();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.NavMsg.TrafficLightDetection.vehicle_pose)
}

// repeated bytes signal_id = 7;
inline int TrafficLightDetection::signal_id_size() const {
  return signal_id_.size();
}
inline void TrafficLightDetection::clear_signal_id() {
  signal_id_.Clear();
}
inline const ::std::string& TrafficLightDetection::signal_id(int index) const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.TrafficLightDetection.signal_id)
  return signal_id_.Get(index);
}
inline ::std::string* TrafficLightDetection::mutable_signal_id(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.NavMsg.TrafficLightDetection.signal_id)
  return signal_id_.Mutable(index);
}
inline void TrafficLightDetection::set_signal_id(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:COWA.NavMsg.TrafficLightDetection.signal_id)
  signal_id_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void TrafficLightDetection::set_signal_id(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:COWA.NavMsg.TrafficLightDetection.signal_id)
  signal_id_.Mutable(index)->assign(std::move(value));
}
#endif
inline void TrafficLightDetection::set_signal_id(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  signal_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:COWA.NavMsg.TrafficLightDetection.signal_id)
}
inline void TrafficLightDetection::set_signal_id(int index, const void* value, size_t size) {
  signal_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:COWA.NavMsg.TrafficLightDetection.signal_id)
}
inline ::std::string* TrafficLightDetection::add_signal_id() {
  // @@protoc_insertion_point(field_add_mutable:COWA.NavMsg.TrafficLightDetection.signal_id)
  return signal_id_.Add();
}
inline void TrafficLightDetection::add_signal_id(const ::std::string& value) {
  signal_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:COWA.NavMsg.TrafficLightDetection.signal_id)
}
#if LANG_CXX11
inline void TrafficLightDetection::add_signal_id(::std::string&& value) {
  signal_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:COWA.NavMsg.TrafficLightDetection.signal_id)
}
#endif
inline void TrafficLightDetection::add_signal_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  signal_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:COWA.NavMsg.TrafficLightDetection.signal_id)
}
inline void TrafficLightDetection::add_signal_id(const void* value, size_t size) {
  signal_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:COWA.NavMsg.TrafficLightDetection.signal_id)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TrafficLightDetection::signal_id() const {
  // @@protoc_insertion_point(field_list:COWA.NavMsg.TrafficLightDetection.signal_id)
  return signal_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TrafficLightDetection::mutable_signal_id() {
  // @@protoc_insertion_point(field_mutable_list:COWA.NavMsg.TrafficLightDetection.signal_id)
  return &signal_id_;
}

// optional int32 latency_ms = 8;
inline bool TrafficLightDetection::has_latency_ms() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TrafficLightDetection::set_has_latency_ms() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TrafficLightDetection::clear_has_latency_ms() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TrafficLightDetection::clear_latency_ms() {
  latency_ms_ = 0;
  clear_has_latency_ms();
}
inline ::google::protobuf::int32 TrafficLightDetection::latency_ms() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.TrafficLightDetection.latency_ms)
  return latency_ms_;
}
inline void TrafficLightDetection::set_latency_ms(::google::protobuf::int32 value) {
  set_has_latency_ms();
  latency_ms_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.TrafficLightDetection.latency_ms)
}

// -------------------------------------------------------------------

// TrafficLight2_Item

// optional .COWA.NavMsg.TrafficLight2.Direction dir = 1;
inline bool TrafficLight2_Item::has_dir() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrafficLight2_Item::set_has_dir() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrafficLight2_Item::clear_has_dir() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrafficLight2_Item::clear_dir() {
  dir_ = 1;
  clear_has_dir();
}
inline ::COWA::NavMsg::TrafficLight2_Direction TrafficLight2_Item::dir() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.TrafficLight2.Item.dir)
  return static_cast< ::COWA::NavMsg::TrafficLight2_Direction >(dir_);
}
inline void TrafficLight2_Item::set_dir(::COWA::NavMsg::TrafficLight2_Direction value) {
  assert(::COWA::NavMsg::TrafficLight2_Direction_IsValid(value));
  set_has_dir();
  dir_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.TrafficLight2.Item.dir)
}

// optional .COWA.NavMsg.TrafficLight2.State state = 2;
inline bool TrafficLight2_Item::has_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrafficLight2_Item::set_has_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrafficLight2_Item::clear_has_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrafficLight2_Item::clear_state() {
  state_ = 1;
  clear_has_state();
}
inline ::COWA::NavMsg::TrafficLight2_State TrafficLight2_Item::state() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.TrafficLight2.Item.state)
  return static_cast< ::COWA::NavMsg::TrafficLight2_State >(state_);
}
inline void TrafficLight2_Item::set_state(::COWA::NavMsg::TrafficLight2_State value) {
  assert(::COWA::NavMsg::TrafficLight2_State_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.TrafficLight2.Item.state)
}

// optional float remaining = 3;
inline bool TrafficLight2_Item::has_remaining() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrafficLight2_Item::set_has_remaining() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrafficLight2_Item::clear_has_remaining() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrafficLight2_Item::clear_remaining() {
  remaining_ = 0;
  clear_has_remaining();
}
inline float TrafficLight2_Item::remaining() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.TrafficLight2.Item.remaining)
  return remaining_;
}
inline void TrafficLight2_Item::set_remaining(float value) {
  set_has_remaining();
  remaining_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.TrafficLight2.Item.remaining)
}

// optional bool blink = 4;
inline bool TrafficLight2_Item::has_blink() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrafficLight2_Item::set_has_blink() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrafficLight2_Item::clear_has_blink() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrafficLight2_Item::clear_blink() {
  blink_ = false;
  clear_has_blink();
}
inline bool TrafficLight2_Item::blink() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.TrafficLight2.Item.blink)
  return blink_;
}
inline void TrafficLight2_Item::set_blink(bool value) {
  set_has_blink();
  blink_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.TrafficLight2.Item.blink)
}

// -------------------------------------------------------------------

// TrafficLight2

// optional uint64 timestamp = 1;
inline bool TrafficLight2::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrafficLight2::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrafficLight2::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrafficLight2::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 TrafficLight2::timestamp() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.TrafficLight2.timestamp)
  return timestamp_;
}
inline void TrafficLight2::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.TrafficLight2.timestamp)
}

// optional uint32 sequence = 2;
inline bool TrafficLight2::has_sequence() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrafficLight2::set_has_sequence() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrafficLight2::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrafficLight2::clear_sequence() {
  sequence_ = 0u;
  clear_has_sequence();
}
inline ::google::protobuf::uint32 TrafficLight2::sequence() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.TrafficLight2.sequence)
  return sequence_;
}
inline void TrafficLight2::set_sequence(::google::protobuf::uint32 value) {
  set_has_sequence();
  sequence_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.TrafficLight2.sequence)
}

// repeated .COWA.NavMsg.TrafficLight2.Item lights = 3;
inline int TrafficLight2::lights_size() const {
  return lights_.size();
}
inline void TrafficLight2::clear_lights() {
  lights_.Clear();
}
inline const ::COWA::NavMsg::TrafficLight2_Item& TrafficLight2::lights(int index) const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.TrafficLight2.lights)
  return lights_.Get(index);
}
inline ::COWA::NavMsg::TrafficLight2_Item* TrafficLight2::mutable_lights(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.NavMsg.TrafficLight2.lights)
  return lights_.Mutable(index);
}
inline ::COWA::NavMsg::TrafficLight2_Item* TrafficLight2::add_lights() {
  // @@protoc_insertion_point(field_add:COWA.NavMsg.TrafficLight2.lights)
  return lights_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::TrafficLight2_Item >*
TrafficLight2::mutable_lights() {
  // @@protoc_insertion_point(field_mutable_list:COWA.NavMsg.TrafficLight2.lights)
  return &lights_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::TrafficLight2_Item >&
TrafficLight2::lights() const {
  // @@protoc_insertion_point(field_list:COWA.NavMsg.TrafficLight2.lights)
  return lights_;
}

// optional string crossroad_id = 4;
inline bool TrafficLight2::has_crossroad_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrafficLight2::set_has_crossroad_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrafficLight2::clear_has_crossroad_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrafficLight2::clear_crossroad_id() {
  crossroad_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_crossroad_id();
}
inline const ::std::string& TrafficLight2::crossroad_id() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.TrafficLight2.crossroad_id)
  return crossroad_id_.GetNoArena();
}
inline void TrafficLight2::set_crossroad_id(const ::std::string& value) {
  set_has_crossroad_id();
  crossroad_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:COWA.NavMsg.TrafficLight2.crossroad_id)
}
#if LANG_CXX11
inline void TrafficLight2::set_crossroad_id(::std::string&& value) {
  set_has_crossroad_id();
  crossroad_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:COWA.NavMsg.TrafficLight2.crossroad_id)
}
#endif
inline void TrafficLight2::set_crossroad_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_crossroad_id();
  crossroad_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:COWA.NavMsg.TrafficLight2.crossroad_id)
}
inline void TrafficLight2::set_crossroad_id(const char* value, size_t size) {
  set_has_crossroad_id();
  crossroad_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:COWA.NavMsg.TrafficLight2.crossroad_id)
}
inline ::std::string* TrafficLight2::mutable_crossroad_id() {
  set_has_crossroad_id();
  // @@protoc_insertion_point(field_mutable:COWA.NavMsg.TrafficLight2.crossroad_id)
  return crossroad_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TrafficLight2::release_crossroad_id() {
  // @@protoc_insertion_point(field_release:COWA.NavMsg.TrafficLight2.crossroad_id)
  clear_has_crossroad_id();
  return crossroad_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TrafficLight2::set_allocated_crossroad_id(::std::string* crossroad_id) {
  if (crossroad_id != NULL) {
    set_has_crossroad_id();
  } else {
    clear_has_crossroad_id();
  }
  crossroad_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), crossroad_id);
  // @@protoc_insertion_point(field_set_allocated:COWA.NavMsg.TrafficLight2.crossroad_id)
}

// optional float yaw = 5;
inline bool TrafficLight2::has_yaw() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrafficLight2::set_has_yaw() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrafficLight2::clear_has_yaw() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrafficLight2::clear_yaw() {
  yaw_ = 0;
  clear_has_yaw();
}
inline float TrafficLight2::yaw() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.TrafficLight2.yaw)
  return yaw_;
}
inline void TrafficLight2::set_yaw(float value) {
  set_has_yaw();
  yaw_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.TrafficLight2.yaw)
}

// repeated .COWA.NavMsg.TrafficLightBBox detected = 6;
inline int TrafficLight2::detected_size() const {
  return detected_.size();
}
inline void TrafficLight2::clear_detected() {
  detected_.Clear();
}
inline const ::COWA::NavMsg::TrafficLightBBox& TrafficLight2::detected(int index) const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.TrafficLight2.detected)
  return detected_.Get(index);
}
inline ::COWA::NavMsg::TrafficLightBBox* TrafficLight2::mutable_detected(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.NavMsg.TrafficLight2.detected)
  return detected_.Mutable(index);
}
inline ::COWA::NavMsg::TrafficLightBBox* TrafficLight2::add_detected() {
  // @@protoc_insertion_point(field_add:COWA.NavMsg.TrafficLight2.detected)
  return detected_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::TrafficLightBBox >*
TrafficLight2::mutable_detected() {
  // @@protoc_insertion_point(field_mutable_list:COWA.NavMsg.TrafficLight2.detected)
  return &detected_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::TrafficLightBBox >&
TrafficLight2::detected() const {
  // @@protoc_insertion_point(field_list:COWA.NavMsg.TrafficLight2.detected)
  return detected_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace NavMsg
}  // namespace COWA

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::COWA::NavMsg::TrafficLight_Color> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::COWA::NavMsg::TrafficLight_Color>() {
  return ::COWA::NavMsg::TrafficLight_Color_descriptor();
}
template <> struct is_proto_enum< ::COWA::NavMsg::TrafficLight2_State> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::COWA::NavMsg::TrafficLight2_State>() {
  return ::COWA::NavMsg::TrafficLight2_State_descriptor();
}
template <> struct is_proto_enum< ::COWA::NavMsg::TrafficLight2_Direction> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::COWA::NavMsg::TrafficLight2_Direction>() {
  return ::COWA::NavMsg::TrafficLight2_Direction_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_trafficlight_2eproto__INCLUDED
