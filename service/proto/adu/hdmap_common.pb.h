// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: hdmap_common.proto

#ifndef PROTOBUF_hdmap_5fcommon_2eproto__INCLUDED
#define PROTOBUF_hdmap_5fcommon_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace COWA {
namespace MapData {
class Cloud;
class CloudDefaultTypeInternal;
extern CloudDefaultTypeInternal _Cloud_default_instance_;
class CrossroadOverlapInfo;
class CrossroadOverlapInfoDefaultTypeInternal;
extern CrossroadOverlapInfoDefaultTypeInternal _CrossroadOverlapInfo_default_instance_;
class CrosswalkOverlapInfo;
class CrosswalkOverlapInfoDefaultTypeInternal;
extern CrosswalkOverlapInfoDefaultTypeInternal _CrosswalkOverlapInfo_default_instance_;
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class Id;
class IdDefaultTypeInternal;
extern IdDefaultTypeInternal _Id_default_instance_;
class LaneOverlapInfo;
class LaneOverlapInfoDefaultTypeInternal;
extern LaneOverlapInfoDefaultTypeInternal _LaneOverlapInfo_default_instance_;
class Overlap;
class OverlapDefaultTypeInternal;
extern OverlapDefaultTypeInternal _Overlap_default_instance_;
class Overlap_ObjectOverlapInfo;
class Overlap_ObjectOverlapInfoDefaultTypeInternal;
extern Overlap_ObjectOverlapInfoDefaultTypeInternal _Overlap_ObjectOverlapInfo_default_instance_;
class PointENU;
class PointENUDefaultTypeInternal;
extern PointENUDefaultTypeInternal _PointENU_default_instance_;
class Polygon;
class PolygonDefaultTypeInternal;
extern PolygonDefaultTypeInternal _Polygon_default_instance_;
class RampOverlapInfo;
class RampOverlapInfoDefaultTypeInternal;
extern RampOverlapInfoDefaultTypeInternal _RampOverlapInfo_default_instance_;
class RoadOverlapInfo;
class RoadOverlapInfoDefaultTypeInternal;
extern RoadOverlapInfoDefaultTypeInternal _RoadOverlapInfo_default_instance_;
class RoadmarkOverlapInfo;
class RoadmarkOverlapInfoDefaultTypeInternal;
extern RoadmarkOverlapInfoDefaultTypeInternal _RoadmarkOverlapInfo_default_instance_;
class SignalOverlapInfo;
class SignalOverlapInfoDefaultTypeInternal;
extern SignalOverlapInfoDefaultTypeInternal _SignalOverlapInfo_default_instance_;
}  // namespace MapData
}  // namespace COWA

namespace COWA {
namespace MapData {

namespace protobuf_hdmap_5fcommon_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_hdmap_5fcommon_2eproto

// ===================================================================

class Id : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.MapData.Id) */ {
 public:
  Id();
  virtual ~Id();

  Id(const Id& from);

  inline Id& operator=(const Id& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Id& default_instance();

  static inline const Id* internal_default_instance() {
    return reinterpret_cast<const Id*>(
               &_Id_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Id* other);

  // implements Message ----------------------------------------------

  inline Id* New() const PROTOBUF_FINAL { return New(NULL); }

  Id* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Id& from);
  void MergeFrom(const Id& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Id* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:COWA.MapData.Id)
 private:
  void set_has_id();
  void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  friend struct protobuf_hdmap_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PointENU : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.MapData.PointENU) */ {
 public:
  PointENU();
  virtual ~PointENU();

  PointENU(const PointENU& from);

  inline PointENU& operator=(const PointENU& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PointENU& default_instance();

  static inline const PointENU* internal_default_instance() {
    return reinterpret_cast<const PointENU*>(
               &_PointENU_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(PointENU* other);

  // implements Message ----------------------------------------------

  inline PointENU* New() const PROTOBUF_FINAL { return New(NULL); }

  PointENU* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PointENU& from);
  void MergeFrom(const PointENU& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PointENU* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double z = 3 [default = 0];
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // optional double x = 1 [default = nan];
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // optional double y = 2 [default = nan];
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // @@protoc_insertion_point(class_scope:COWA.MapData.PointENU)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double z_;
  double x_;
  double y_;
  friend struct protobuf_hdmap_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Polygon : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.MapData.Polygon) */ {
 public:
  Polygon();
  virtual ~Polygon();

  Polygon(const Polygon& from);

  inline Polygon& operator=(const Polygon& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Polygon& default_instance();

  static inline const Polygon* internal_default_instance() {
    return reinterpret_cast<const Polygon*>(
               &_Polygon_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Polygon* other);

  // implements Message ----------------------------------------------

  inline Polygon* New() const PROTOBUF_FINAL { return New(NULL); }

  Polygon* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Polygon& from);
  void MergeFrom(const Polygon& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Polygon* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .COWA.MapData.PointENU point = 1;
  int point_size() const;
  void clear_point();
  static const int kPointFieldNumber = 1;
  const ::COWA::MapData::PointENU& point(int index) const;
  ::COWA::MapData::PointENU* mutable_point(int index);
  ::COWA::MapData::PointENU* add_point();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::PointENU >*
      mutable_point();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::PointENU >&
      point() const;

  // @@protoc_insertion_point(class_scope:COWA.MapData.Polygon)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::PointENU > point_;
  friend struct protobuf_hdmap_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Cloud : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.MapData.Cloud) */ {
 public:
  Cloud();
  virtual ~Cloud();

  Cloud(const Cloud& from);

  inline Cloud& operator=(const Cloud& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Cloud& default_instance();

  static inline const Cloud* internal_default_instance() {
    return reinterpret_cast<const Cloud*>(
               &_Cloud_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Cloud* other);

  // implements Message ----------------------------------------------

  inline Cloud* New() const PROTOBUF_FINAL { return New(NULL); }

  Cloud* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Cloud& from);
  void MergeFrom(const Cloud& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Cloud* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float xyz = 1;
  int xyz_size() const;
  void clear_xyz();
  static const int kXyzFieldNumber = 1;
  float xyz(int index) const;
  void set_xyz(int index, float value);
  void add_xyz(float value);
  const ::google::protobuf::RepeatedField< float >&
      xyz() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_xyz();

  // optional double offset_x = 2;
  bool has_offset_x() const;
  void clear_offset_x();
  static const int kOffsetXFieldNumber = 2;
  double offset_x() const;
  void set_offset_x(double value);

  // optional double offset_y = 3;
  bool has_offset_y() const;
  void clear_offset_y();
  static const int kOffsetYFieldNumber = 3;
  double offset_y() const;
  void set_offset_y(double value);

  // @@protoc_insertion_point(class_scope:COWA.MapData.Cloud)
 private:
  void set_has_offset_x();
  void clear_has_offset_x();
  void set_has_offset_y();
  void clear_has_offset_y();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< float > xyz_;
  double offset_x_;
  double offset_y_;
  friend struct protobuf_hdmap_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LaneOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.MapData.LaneOverlapInfo) */ {
 public:
  LaneOverlapInfo();
  virtual ~LaneOverlapInfo();

  LaneOverlapInfo(const LaneOverlapInfo& from);

  inline LaneOverlapInfo& operator=(const LaneOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneOverlapInfo& default_instance();

  static inline const LaneOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const LaneOverlapInfo*>(
               &_LaneOverlapInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(LaneOverlapInfo* other);

  // implements Message ----------------------------------------------

  inline LaneOverlapInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  LaneOverlapInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LaneOverlapInfo& from);
  void MergeFrom(const LaneOverlapInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LaneOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double start_s = 1;
  bool has_start_s() const;
  void clear_start_s();
  static const int kStartSFieldNumber = 1;
  double start_s() const;
  void set_start_s(double value);

  // optional double end_s = 2;
  bool has_end_s() const;
  void clear_end_s();
  static const int kEndSFieldNumber = 2;
  double end_s() const;
  void set_end_s(double value);

  // @@protoc_insertion_point(class_scope:COWA.MapData.LaneOverlapInfo)
 private:
  void set_has_start_s();
  void clear_has_start_s();
  void set_has_end_s();
  void clear_has_end_s();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double start_s_;
  double end_s_;
  friend struct protobuf_hdmap_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SignalOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.MapData.SignalOverlapInfo) */ {
 public:
  SignalOverlapInfo();
  virtual ~SignalOverlapInfo();

  SignalOverlapInfo(const SignalOverlapInfo& from);

  inline SignalOverlapInfo& operator=(const SignalOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignalOverlapInfo& default_instance();

  static inline const SignalOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const SignalOverlapInfo*>(
               &_SignalOverlapInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(SignalOverlapInfo* other);

  // implements Message ----------------------------------------------

  inline SignalOverlapInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  SignalOverlapInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SignalOverlapInfo& from);
  void MergeFrom(const SignalOverlapInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SignalOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 reserved = 1;
  bool has_reserved() const;
  void clear_reserved();
  static const int kReservedFieldNumber = 1;
  ::google::protobuf::int32 reserved() const;
  void set_reserved(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:COWA.MapData.SignalOverlapInfo)
 private:
  void set_has_reserved();
  void clear_has_reserved();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 reserved_;
  friend struct protobuf_hdmap_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CrosswalkOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.MapData.CrosswalkOverlapInfo) */ {
 public:
  CrosswalkOverlapInfo();
  virtual ~CrosswalkOverlapInfo();

  CrosswalkOverlapInfo(const CrosswalkOverlapInfo& from);

  inline CrosswalkOverlapInfo& operator=(const CrosswalkOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CrosswalkOverlapInfo& default_instance();

  static inline const CrosswalkOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const CrosswalkOverlapInfo*>(
               &_CrosswalkOverlapInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(CrosswalkOverlapInfo* other);

  // implements Message ----------------------------------------------

  inline CrosswalkOverlapInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  CrosswalkOverlapInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CrosswalkOverlapInfo& from);
  void MergeFrom(const CrosswalkOverlapInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CrosswalkOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 reserved = 1;
  bool has_reserved() const;
  void clear_reserved();
  static const int kReservedFieldNumber = 1;
  ::google::protobuf::int32 reserved() const;
  void set_reserved(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:COWA.MapData.CrosswalkOverlapInfo)
 private:
  void set_has_reserved();
  void clear_has_reserved();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 reserved_;
  friend struct protobuf_hdmap_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CrossroadOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.MapData.CrossroadOverlapInfo) */ {
 public:
  CrossroadOverlapInfo();
  virtual ~CrossroadOverlapInfo();

  CrossroadOverlapInfo(const CrossroadOverlapInfo& from);

  inline CrossroadOverlapInfo& operator=(const CrossroadOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CrossroadOverlapInfo& default_instance();

  static inline const CrossroadOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const CrossroadOverlapInfo*>(
               &_CrossroadOverlapInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(CrossroadOverlapInfo* other);

  // implements Message ----------------------------------------------

  inline CrossroadOverlapInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  CrossroadOverlapInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CrossroadOverlapInfo& from);
  void MergeFrom(const CrossroadOverlapInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CrossroadOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 reserved = 1;
  bool has_reserved() const;
  void clear_reserved();
  static const int kReservedFieldNumber = 1;
  ::google::protobuf::int32 reserved() const;
  void set_reserved(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:COWA.MapData.CrossroadOverlapInfo)
 private:
  void set_has_reserved();
  void clear_has_reserved();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 reserved_;
  friend struct protobuf_hdmap_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RampOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.MapData.RampOverlapInfo) */ {
 public:
  RampOverlapInfo();
  virtual ~RampOverlapInfo();

  RampOverlapInfo(const RampOverlapInfo& from);

  inline RampOverlapInfo& operator=(const RampOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RampOverlapInfo& default_instance();

  static inline const RampOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const RampOverlapInfo*>(
               &_RampOverlapInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(RampOverlapInfo* other);

  // implements Message ----------------------------------------------

  inline RampOverlapInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  RampOverlapInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RampOverlapInfo& from);
  void MergeFrom(const RampOverlapInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RampOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 reserved = 1;
  bool has_reserved() const;
  void clear_reserved();
  static const int kReservedFieldNumber = 1;
  ::google::protobuf::int32 reserved() const;
  void set_reserved(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:COWA.MapData.RampOverlapInfo)
 private:
  void set_has_reserved();
  void clear_has_reserved();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 reserved_;
  friend struct protobuf_hdmap_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoadmarkOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.MapData.RoadmarkOverlapInfo) */ {
 public:
  RoadmarkOverlapInfo();
  virtual ~RoadmarkOverlapInfo();

  RoadmarkOverlapInfo(const RoadmarkOverlapInfo& from);

  inline RoadmarkOverlapInfo& operator=(const RoadmarkOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoadmarkOverlapInfo& default_instance();

  static inline const RoadmarkOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const RoadmarkOverlapInfo*>(
               &_RoadmarkOverlapInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(RoadmarkOverlapInfo* other);

  // implements Message ----------------------------------------------

  inline RoadmarkOverlapInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  RoadmarkOverlapInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RoadmarkOverlapInfo& from);
  void MergeFrom(const RoadmarkOverlapInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RoadmarkOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 reserved = 1;
  bool has_reserved() const;
  void clear_reserved();
  static const int kReservedFieldNumber = 1;
  ::google::protobuf::int32 reserved() const;
  void set_reserved(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:COWA.MapData.RoadmarkOverlapInfo)
 private:
  void set_has_reserved();
  void clear_has_reserved();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 reserved_;
  friend struct protobuf_hdmap_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoadOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.MapData.RoadOverlapInfo) */ {
 public:
  RoadOverlapInfo();
  virtual ~RoadOverlapInfo();

  RoadOverlapInfo(const RoadOverlapInfo& from);

  inline RoadOverlapInfo& operator=(const RoadOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoadOverlapInfo& default_instance();

  static inline const RoadOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const RoadOverlapInfo*>(
               &_RoadOverlapInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(RoadOverlapInfo* other);

  // implements Message ----------------------------------------------

  inline RoadOverlapInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  RoadOverlapInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RoadOverlapInfo& from);
  void MergeFrom(const RoadOverlapInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RoadOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 reserved = 1;
  bool has_reserved() const;
  void clear_reserved();
  static const int kReservedFieldNumber = 1;
  ::google::protobuf::int32 reserved() const;
  void set_reserved(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:COWA.MapData.RoadOverlapInfo)
 private:
  void set_has_reserved();
  void clear_has_reserved();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 reserved_;
  friend struct protobuf_hdmap_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Overlap_ObjectOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.MapData.Overlap.ObjectOverlapInfo) */ {
 public:
  Overlap_ObjectOverlapInfo();
  virtual ~Overlap_ObjectOverlapInfo();

  Overlap_ObjectOverlapInfo(const Overlap_ObjectOverlapInfo& from);

  inline Overlap_ObjectOverlapInfo& operator=(const Overlap_ObjectOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Overlap_ObjectOverlapInfo& default_instance();

  enum OverlapInfoCase {
    kLane = 2,
    kSignal = 3,
    kCrossroad = 4,
    kCrosswalk = 5,
    kRamp = 6,
    kRoadmark = 7,
    kRoad = 8,
    OVERLAP_INFO_NOT_SET = 0,
  };

  static inline const Overlap_ObjectOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const Overlap_ObjectOverlapInfo*>(
               &_Overlap_ObjectOverlapInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(Overlap_ObjectOverlapInfo* other);

  // implements Message ----------------------------------------------

  inline Overlap_ObjectOverlapInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  Overlap_ObjectOverlapInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Overlap_ObjectOverlapInfo& from);
  void MergeFrom(const Overlap_ObjectOverlapInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Overlap_ObjectOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .COWA.MapData.Id id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::COWA::MapData::Id& id() const;
  ::COWA::MapData::Id* mutable_id();
  ::COWA::MapData::Id* release_id();
  void set_allocated_id(::COWA::MapData::Id* id);

  // optional .COWA.MapData.LaneOverlapInfo lane = 2;
  bool has_lane() const;
  void clear_lane();
  static const int kLaneFieldNumber = 2;
  const ::COWA::MapData::LaneOverlapInfo& lane() const;
  ::COWA::MapData::LaneOverlapInfo* mutable_lane();
  ::COWA::MapData::LaneOverlapInfo* release_lane();
  void set_allocated_lane(::COWA::MapData::LaneOverlapInfo* lane);

  // optional .COWA.MapData.SignalOverlapInfo signal = 3;
  bool has_signal() const;
  void clear_signal();
  static const int kSignalFieldNumber = 3;
  const ::COWA::MapData::SignalOverlapInfo& signal() const;
  ::COWA::MapData::SignalOverlapInfo* mutable_signal();
  ::COWA::MapData::SignalOverlapInfo* release_signal();
  void set_allocated_signal(::COWA::MapData::SignalOverlapInfo* signal);

  // optional .COWA.MapData.CrossroadOverlapInfo crossroad = 4;
  bool has_crossroad() const;
  void clear_crossroad();
  static const int kCrossroadFieldNumber = 4;
  const ::COWA::MapData::CrossroadOverlapInfo& crossroad() const;
  ::COWA::MapData::CrossroadOverlapInfo* mutable_crossroad();
  ::COWA::MapData::CrossroadOverlapInfo* release_crossroad();
  void set_allocated_crossroad(::COWA::MapData::CrossroadOverlapInfo* crossroad);

  // optional .COWA.MapData.CrosswalkOverlapInfo crosswalk = 5;
  bool has_crosswalk() const;
  void clear_crosswalk();
  static const int kCrosswalkFieldNumber = 5;
  const ::COWA::MapData::CrosswalkOverlapInfo& crosswalk() const;
  ::COWA::MapData::CrosswalkOverlapInfo* mutable_crosswalk();
  ::COWA::MapData::CrosswalkOverlapInfo* release_crosswalk();
  void set_allocated_crosswalk(::COWA::MapData::CrosswalkOverlapInfo* crosswalk);

  // optional .COWA.MapData.RampOverlapInfo ramp = 6;
  bool has_ramp() const;
  void clear_ramp();
  static const int kRampFieldNumber = 6;
  const ::COWA::MapData::RampOverlapInfo& ramp() const;
  ::COWA::MapData::RampOverlapInfo* mutable_ramp();
  ::COWA::MapData::RampOverlapInfo* release_ramp();
  void set_allocated_ramp(::COWA::MapData::RampOverlapInfo* ramp);

  // optional .COWA.MapData.RoadmarkOverlapInfo roadmark = 7;
  bool has_roadmark() const;
  void clear_roadmark();
  static const int kRoadmarkFieldNumber = 7;
  const ::COWA::MapData::RoadmarkOverlapInfo& roadmark() const;
  ::COWA::MapData::RoadmarkOverlapInfo* mutable_roadmark();
  ::COWA::MapData::RoadmarkOverlapInfo* release_roadmark();
  void set_allocated_roadmark(::COWA::MapData::RoadmarkOverlapInfo* roadmark);

  // optional .COWA.MapData.RoadOverlapInfo road = 8;
  bool has_road() const;
  void clear_road();
  static const int kRoadFieldNumber = 8;
  const ::COWA::MapData::RoadOverlapInfo& road() const;
  ::COWA::MapData::RoadOverlapInfo* mutable_road();
  ::COWA::MapData::RoadOverlapInfo* release_road();
  void set_allocated_road(::COWA::MapData::RoadOverlapInfo* road);

  OverlapInfoCase overlap_info_case() const;
  // @@protoc_insertion_point(class_scope:COWA.MapData.Overlap.ObjectOverlapInfo)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_lane();
  void set_has_signal();
  void set_has_crossroad();
  void set_has_crosswalk();
  void set_has_ramp();
  void set_has_roadmark();
  void set_has_road();

  inline bool has_overlap_info() const;
  void clear_overlap_info();
  inline void clear_has_overlap_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::COWA::MapData::Id* id_;
  union OverlapInfoUnion {
    OverlapInfoUnion() {}
    ::COWA::MapData::LaneOverlapInfo* lane_;
    ::COWA::MapData::SignalOverlapInfo* signal_;
    ::COWA::MapData::CrossroadOverlapInfo* crossroad_;
    ::COWA::MapData::CrosswalkOverlapInfo* crosswalk_;
    ::COWA::MapData::RampOverlapInfo* ramp_;
    ::COWA::MapData::RoadmarkOverlapInfo* roadmark_;
    ::COWA::MapData::RoadOverlapInfo* road_;
  } overlap_info_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_hdmap_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Overlap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.MapData.Overlap) */ {
 public:
  Overlap();
  virtual ~Overlap();

  Overlap(const Overlap& from);

  inline Overlap& operator=(const Overlap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Overlap& default_instance();

  static inline const Overlap* internal_default_instance() {
    return reinterpret_cast<const Overlap*>(
               &_Overlap_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(Overlap* other);

  // implements Message ----------------------------------------------

  inline Overlap* New() const PROTOBUF_FINAL { return New(NULL); }

  Overlap* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Overlap& from);
  void MergeFrom(const Overlap& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Overlap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Overlap_ObjectOverlapInfo ObjectOverlapInfo;

  // accessors -------------------------------------------------------

  // optional .COWA.MapData.Overlap.ObjectOverlapInfo first = 2;
  bool has_first() const;
  void clear_first();
  static const int kFirstFieldNumber = 2;
  const ::COWA::MapData::Overlap_ObjectOverlapInfo& first() const;
  ::COWA::MapData::Overlap_ObjectOverlapInfo* mutable_first();
  ::COWA::MapData::Overlap_ObjectOverlapInfo* release_first();
  void set_allocated_first(::COWA::MapData::Overlap_ObjectOverlapInfo* first);

  // optional .COWA.MapData.Overlap.ObjectOverlapInfo second = 3;
  bool has_second() const;
  void clear_second();
  static const int kSecondFieldNumber = 3;
  const ::COWA::MapData::Overlap_ObjectOverlapInfo& second() const;
  ::COWA::MapData::Overlap_ObjectOverlapInfo* mutable_second();
  ::COWA::MapData::Overlap_ObjectOverlapInfo* release_second();
  void set_allocated_second(::COWA::MapData::Overlap_ObjectOverlapInfo* second);

  // optional .COWA.MapData.Polygon polygon = 4;
  bool has_polygon() const;
  void clear_polygon();
  static const int kPolygonFieldNumber = 4;
  const ::COWA::MapData::Polygon& polygon() const;
  ::COWA::MapData::Polygon* mutable_polygon();
  ::COWA::MapData::Polygon* release_polygon();
  void set_allocated_polygon(::COWA::MapData::Polygon* polygon);

  // @@protoc_insertion_point(class_scope:COWA.MapData.Overlap)
 private:
  void set_has_first();
  void clear_has_first();
  void set_has_second();
  void clear_has_second();
  void set_has_polygon();
  void clear_has_polygon();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::COWA::MapData::Overlap_ObjectOverlapInfo* first_;
  ::COWA::MapData::Overlap_ObjectOverlapInfo* second_;
  ::COWA::MapData::Polygon* polygon_;
  friend struct protobuf_hdmap_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Header : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.MapData.Header) */ {
 public:
  Header();
  virtual ~Header();

  Header(const Header& from);

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Header& default_instance();

  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(Header* other);

  // implements Message ----------------------------------------------

  inline Header* New() const PROTOBUF_FINAL { return New(NULL); }

  Header* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Header* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string log = 6;
  int log_size() const;
  void clear_log();
  static const int kLogFieldNumber = 6;
  const ::std::string& log(int index) const;
  ::std::string* mutable_log(int index);
  void set_log(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_log(int index, ::std::string&& value);
  #endif
  void set_log(int index, const char* value);
  void set_log(int index, const char* value, size_t size);
  ::std::string* add_log();
  void add_log(const ::std::string& value);
  #if LANG_CXX11
  void add_log(::std::string&& value);
  #endif
  void add_log(const char* value);
  void add_log(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& log() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_log();

  // optional string version = 1;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // optional string date = 2;
  bool has_date() const;
  void clear_date();
  static const int kDateFieldNumber = 2;
  const ::std::string& date() const;
  void set_date(const ::std::string& value);
  #if LANG_CXX11
  void set_date(::std::string&& value);
  #endif
  void set_date(const char* value);
  void set_date(const char* value, size_t size);
  ::std::string* mutable_date();
  ::std::string* release_date();
  void set_allocated_date(::std::string* date);

  // optional string projection = 3;
  bool has_projection() const;
  void clear_projection();
  static const int kProjectionFieldNumber = 3;
  const ::std::string& projection() const;
  void set_projection(const ::std::string& value);
  #if LANG_CXX11
  void set_projection(::std::string&& value);
  #endif
  void set_projection(const char* value);
  void set_projection(const char* value, size_t size);
  ::std::string* mutable_projection();
  ::std::string* release_projection();
  void set_allocated_projection(::std::string* projection);

  // optional string generation = 4;
  bool has_generation() const;
  void clear_generation();
  static const int kGenerationFieldNumber = 4;
  const ::std::string& generation() const;
  void set_generation(const ::std::string& value);
  #if LANG_CXX11
  void set_generation(::std::string&& value);
  #endif
  void set_generation(const char* value);
  void set_generation(const char* value, size_t size);
  ::std::string* mutable_generation();
  ::std::string* release_generation();
  void set_allocated_generation(::std::string* generation);

  // optional string md5 = 5;
  bool has_md5() const;
  void clear_md5();
  static const int kMd5FieldNumber = 5;
  const ::std::string& md5() const;
  void set_md5(const ::std::string& value);
  #if LANG_CXX11
  void set_md5(::std::string&& value);
  #endif
  void set_md5(const char* value);
  void set_md5(const char* value, size_t size);
  ::std::string* mutable_md5();
  ::std::string* release_md5();
  void set_allocated_md5(::std::string* md5);

  // @@protoc_insertion_point(class_scope:COWA.MapData.Header)
 private:
  void set_has_version();
  void clear_has_version();
  void set_has_date();
  void clear_has_date();
  void set_has_projection();
  void clear_has_projection();
  void set_has_generation();
  void clear_has_generation();
  void set_has_md5();
  void clear_has_md5();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> log_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr date_;
  ::google::protobuf::internal::ArenaStringPtr projection_;
  ::google::protobuf::internal::ArenaStringPtr generation_;
  ::google::protobuf::internal::ArenaStringPtr md5_;
  friend struct protobuf_hdmap_5fcommon_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Id

// optional string id = 1;
inline bool Id::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Id::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Id::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Id::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& Id::id() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Id.id)
  return id_.GetNoArena();
}
inline void Id::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:COWA.MapData.Id.id)
}
#if LANG_CXX11
inline void Id::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:COWA.MapData.Id.id)
}
#endif
inline void Id::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:COWA.MapData.Id.id)
}
inline void Id::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:COWA.MapData.Id.id)
}
inline ::std::string* Id::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Id.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Id::release_id() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Id.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Id::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Id.id)
}

// -------------------------------------------------------------------

// PointENU

// optional double x = 1 [default = nan];
inline bool PointENU::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PointENU::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PointENU::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PointENU::clear_x() {
  x_ = ::google::protobuf::internal::NaN();
  clear_has_x();
}
inline double PointENU::x() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.PointENU.x)
  return x_;
}
inline void PointENU::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.PointENU.x)
}

// optional double y = 2 [default = nan];
inline bool PointENU::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PointENU::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PointENU::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PointENU::clear_y() {
  y_ = ::google::protobuf::internal::NaN();
  clear_has_y();
}
inline double PointENU::y() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.PointENU.y)
  return y_;
}
inline void PointENU::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.PointENU.y)
}

// optional double z = 3 [default = 0];
inline bool PointENU::has_z() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PointENU::set_has_z() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PointENU::clear_has_z() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PointENU::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double PointENU::z() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.PointENU.z)
  return z_;
}
inline void PointENU::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.PointENU.z)
}

// -------------------------------------------------------------------

// Polygon

// repeated .COWA.MapData.PointENU point = 1;
inline int Polygon::point_size() const {
  return point_.size();
}
inline void Polygon::clear_point() {
  point_.Clear();
}
inline const ::COWA::MapData::PointENU& Polygon::point(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Polygon.point)
  return point_.Get(index);
}
inline ::COWA::MapData::PointENU* Polygon::mutable_point(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Polygon.point)
  return point_.Mutable(index);
}
inline ::COWA::MapData::PointENU* Polygon::add_point() {
  // @@protoc_insertion_point(field_add:COWA.MapData.Polygon.point)
  return point_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::PointENU >*
Polygon::mutable_point() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.Polygon.point)
  return &point_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::PointENU >&
Polygon::point() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.Polygon.point)
  return point_;
}

// -------------------------------------------------------------------

// Cloud

// repeated float xyz = 1;
inline int Cloud::xyz_size() const {
  return xyz_.size();
}
inline void Cloud::clear_xyz() {
  xyz_.Clear();
}
inline float Cloud::xyz(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Cloud.xyz)
  return xyz_.Get(index);
}
inline void Cloud::set_xyz(int index, float value) {
  xyz_.Set(index, value);
  // @@protoc_insertion_point(field_set:COWA.MapData.Cloud.xyz)
}
inline void Cloud::add_xyz(float value) {
  xyz_.Add(value);
  // @@protoc_insertion_point(field_add:COWA.MapData.Cloud.xyz)
}
inline const ::google::protobuf::RepeatedField< float >&
Cloud::xyz() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.Cloud.xyz)
  return xyz_;
}
inline ::google::protobuf::RepeatedField< float >*
Cloud::mutable_xyz() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.Cloud.xyz)
  return &xyz_;
}

// optional double offset_x = 2;
inline bool Cloud::has_offset_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Cloud::set_has_offset_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Cloud::clear_has_offset_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Cloud::clear_offset_x() {
  offset_x_ = 0;
  clear_has_offset_x();
}
inline double Cloud::offset_x() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Cloud.offset_x)
  return offset_x_;
}
inline void Cloud::set_offset_x(double value) {
  set_has_offset_x();
  offset_x_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.Cloud.offset_x)
}

// optional double offset_y = 3;
inline bool Cloud::has_offset_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Cloud::set_has_offset_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Cloud::clear_has_offset_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Cloud::clear_offset_y() {
  offset_y_ = 0;
  clear_has_offset_y();
}
inline double Cloud::offset_y() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Cloud.offset_y)
  return offset_y_;
}
inline void Cloud::set_offset_y(double value) {
  set_has_offset_y();
  offset_y_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.Cloud.offset_y)
}

// -------------------------------------------------------------------

// LaneOverlapInfo

// optional double start_s = 1;
inline bool LaneOverlapInfo::has_start_s() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaneOverlapInfo::set_has_start_s() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LaneOverlapInfo::clear_has_start_s() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LaneOverlapInfo::clear_start_s() {
  start_s_ = 0;
  clear_has_start_s();
}
inline double LaneOverlapInfo::start_s() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.LaneOverlapInfo.start_s)
  return start_s_;
}
inline void LaneOverlapInfo::set_start_s(double value) {
  set_has_start_s();
  start_s_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.LaneOverlapInfo.start_s)
}

// optional double end_s = 2;
inline bool LaneOverlapInfo::has_end_s() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaneOverlapInfo::set_has_end_s() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LaneOverlapInfo::clear_has_end_s() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LaneOverlapInfo::clear_end_s() {
  end_s_ = 0;
  clear_has_end_s();
}
inline double LaneOverlapInfo::end_s() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.LaneOverlapInfo.end_s)
  return end_s_;
}
inline void LaneOverlapInfo::set_end_s(double value) {
  set_has_end_s();
  end_s_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.LaneOverlapInfo.end_s)
}

// -------------------------------------------------------------------

// SignalOverlapInfo

// optional int32 reserved = 1;
inline bool SignalOverlapInfo::has_reserved() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignalOverlapInfo::set_has_reserved() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignalOverlapInfo::clear_has_reserved() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignalOverlapInfo::clear_reserved() {
  reserved_ = 0;
  clear_has_reserved();
}
inline ::google::protobuf::int32 SignalOverlapInfo::reserved() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.SignalOverlapInfo.reserved)
  return reserved_;
}
inline void SignalOverlapInfo::set_reserved(::google::protobuf::int32 value) {
  set_has_reserved();
  reserved_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.SignalOverlapInfo.reserved)
}

// -------------------------------------------------------------------

// CrosswalkOverlapInfo

// optional int32 reserved = 1;
inline bool CrosswalkOverlapInfo::has_reserved() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CrosswalkOverlapInfo::set_has_reserved() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CrosswalkOverlapInfo::clear_has_reserved() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CrosswalkOverlapInfo::clear_reserved() {
  reserved_ = 0;
  clear_has_reserved();
}
inline ::google::protobuf::int32 CrosswalkOverlapInfo::reserved() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.CrosswalkOverlapInfo.reserved)
  return reserved_;
}
inline void CrosswalkOverlapInfo::set_reserved(::google::protobuf::int32 value) {
  set_has_reserved();
  reserved_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.CrosswalkOverlapInfo.reserved)
}

// -------------------------------------------------------------------

// CrossroadOverlapInfo

// optional int32 reserved = 1;
inline bool CrossroadOverlapInfo::has_reserved() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CrossroadOverlapInfo::set_has_reserved() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CrossroadOverlapInfo::clear_has_reserved() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CrossroadOverlapInfo::clear_reserved() {
  reserved_ = 0;
  clear_has_reserved();
}
inline ::google::protobuf::int32 CrossroadOverlapInfo::reserved() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.CrossroadOverlapInfo.reserved)
  return reserved_;
}
inline void CrossroadOverlapInfo::set_reserved(::google::protobuf::int32 value) {
  set_has_reserved();
  reserved_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.CrossroadOverlapInfo.reserved)
}

// -------------------------------------------------------------------

// RampOverlapInfo

// optional int32 reserved = 1;
inline bool RampOverlapInfo::has_reserved() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RampOverlapInfo::set_has_reserved() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RampOverlapInfo::clear_has_reserved() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RampOverlapInfo::clear_reserved() {
  reserved_ = 0;
  clear_has_reserved();
}
inline ::google::protobuf::int32 RampOverlapInfo::reserved() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.RampOverlapInfo.reserved)
  return reserved_;
}
inline void RampOverlapInfo::set_reserved(::google::protobuf::int32 value) {
  set_has_reserved();
  reserved_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.RampOverlapInfo.reserved)
}

// -------------------------------------------------------------------

// RoadmarkOverlapInfo

// optional int32 reserved = 1;
inline bool RoadmarkOverlapInfo::has_reserved() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoadmarkOverlapInfo::set_has_reserved() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoadmarkOverlapInfo::clear_has_reserved() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoadmarkOverlapInfo::clear_reserved() {
  reserved_ = 0;
  clear_has_reserved();
}
inline ::google::protobuf::int32 RoadmarkOverlapInfo::reserved() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.RoadmarkOverlapInfo.reserved)
  return reserved_;
}
inline void RoadmarkOverlapInfo::set_reserved(::google::protobuf::int32 value) {
  set_has_reserved();
  reserved_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.RoadmarkOverlapInfo.reserved)
}

// -------------------------------------------------------------------

// RoadOverlapInfo

// optional int32 reserved = 1;
inline bool RoadOverlapInfo::has_reserved() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoadOverlapInfo::set_has_reserved() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoadOverlapInfo::clear_has_reserved() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoadOverlapInfo::clear_reserved() {
  reserved_ = 0;
  clear_has_reserved();
}
inline ::google::protobuf::int32 RoadOverlapInfo::reserved() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.RoadOverlapInfo.reserved)
  return reserved_;
}
inline void RoadOverlapInfo::set_reserved(::google::protobuf::int32 value) {
  set_has_reserved();
  reserved_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.RoadOverlapInfo.reserved)
}

// -------------------------------------------------------------------

// Overlap_ObjectOverlapInfo

// optional .COWA.MapData.Id id = 1;
inline bool Overlap_ObjectOverlapInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Overlap_ObjectOverlapInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Overlap_ObjectOverlapInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Overlap_ObjectOverlapInfo::clear_id() {
  if (id_ != NULL) id_->::COWA::MapData::Id::Clear();
  clear_has_id();
}
inline const ::COWA::MapData::Id& Overlap_ObjectOverlapInfo::id() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Overlap.ObjectOverlapInfo.id)
  return id_ != NULL ? *id_
                         : *::COWA::MapData::Id::internal_default_instance();
}
inline ::COWA::MapData::Id* Overlap_ObjectOverlapInfo::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    id_ = new ::COWA::MapData::Id;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Overlap.ObjectOverlapInfo.id)
  return id_;
}
inline ::COWA::MapData::Id* Overlap_ObjectOverlapInfo::release_id() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Overlap.ObjectOverlapInfo.id)
  clear_has_id();
  ::COWA::MapData::Id* temp = id_;
  id_ = NULL;
  return temp;
}
inline void Overlap_ObjectOverlapInfo::set_allocated_id(::COWA::MapData::Id* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Overlap.ObjectOverlapInfo.id)
}

// optional .COWA.MapData.LaneOverlapInfo lane = 2;
inline bool Overlap_ObjectOverlapInfo::has_lane() const {
  return overlap_info_case() == kLane;
}
inline void Overlap_ObjectOverlapInfo::set_has_lane() {
  _oneof_case_[0] = kLane;
}
inline void Overlap_ObjectOverlapInfo::clear_lane() {
  if (has_lane()) {
    delete overlap_info_.lane_;
    clear_has_overlap_info();
  }
}
inline  const ::COWA::MapData::LaneOverlapInfo& Overlap_ObjectOverlapInfo::lane() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Overlap.ObjectOverlapInfo.lane)
  return has_lane()
      ? *overlap_info_.lane_
      : ::COWA::MapData::LaneOverlapInfo::default_instance();
}
inline ::COWA::MapData::LaneOverlapInfo* Overlap_ObjectOverlapInfo::mutable_lane() {
  if (!has_lane()) {
    clear_overlap_info();
    set_has_lane();
    overlap_info_.lane_ = new ::COWA::MapData::LaneOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Overlap.ObjectOverlapInfo.lane)
  return overlap_info_.lane_;
}
inline ::COWA::MapData::LaneOverlapInfo* Overlap_ObjectOverlapInfo::release_lane() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Overlap.ObjectOverlapInfo.lane)
  if (has_lane()) {
    clear_has_overlap_info();
    ::COWA::MapData::LaneOverlapInfo* temp = overlap_info_.lane_;
    overlap_info_.lane_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Overlap_ObjectOverlapInfo::set_allocated_lane(::COWA::MapData::LaneOverlapInfo* lane) {
  clear_overlap_info();
  if (lane) {
    set_has_lane();
    overlap_info_.lane_ = lane;
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Overlap.ObjectOverlapInfo.lane)
}

// optional .COWA.MapData.SignalOverlapInfo signal = 3;
inline bool Overlap_ObjectOverlapInfo::has_signal() const {
  return overlap_info_case() == kSignal;
}
inline void Overlap_ObjectOverlapInfo::set_has_signal() {
  _oneof_case_[0] = kSignal;
}
inline void Overlap_ObjectOverlapInfo::clear_signal() {
  if (has_signal()) {
    delete overlap_info_.signal_;
    clear_has_overlap_info();
  }
}
inline  const ::COWA::MapData::SignalOverlapInfo& Overlap_ObjectOverlapInfo::signal() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Overlap.ObjectOverlapInfo.signal)
  return has_signal()
      ? *overlap_info_.signal_
      : ::COWA::MapData::SignalOverlapInfo::default_instance();
}
inline ::COWA::MapData::SignalOverlapInfo* Overlap_ObjectOverlapInfo::mutable_signal() {
  if (!has_signal()) {
    clear_overlap_info();
    set_has_signal();
    overlap_info_.signal_ = new ::COWA::MapData::SignalOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Overlap.ObjectOverlapInfo.signal)
  return overlap_info_.signal_;
}
inline ::COWA::MapData::SignalOverlapInfo* Overlap_ObjectOverlapInfo::release_signal() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Overlap.ObjectOverlapInfo.signal)
  if (has_signal()) {
    clear_has_overlap_info();
    ::COWA::MapData::SignalOverlapInfo* temp = overlap_info_.signal_;
    overlap_info_.signal_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Overlap_ObjectOverlapInfo::set_allocated_signal(::COWA::MapData::SignalOverlapInfo* signal) {
  clear_overlap_info();
  if (signal) {
    set_has_signal();
    overlap_info_.signal_ = signal;
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Overlap.ObjectOverlapInfo.signal)
}

// optional .COWA.MapData.CrossroadOverlapInfo crossroad = 4;
inline bool Overlap_ObjectOverlapInfo::has_crossroad() const {
  return overlap_info_case() == kCrossroad;
}
inline void Overlap_ObjectOverlapInfo::set_has_crossroad() {
  _oneof_case_[0] = kCrossroad;
}
inline void Overlap_ObjectOverlapInfo::clear_crossroad() {
  if (has_crossroad()) {
    delete overlap_info_.crossroad_;
    clear_has_overlap_info();
  }
}
inline  const ::COWA::MapData::CrossroadOverlapInfo& Overlap_ObjectOverlapInfo::crossroad() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Overlap.ObjectOverlapInfo.crossroad)
  return has_crossroad()
      ? *overlap_info_.crossroad_
      : ::COWA::MapData::CrossroadOverlapInfo::default_instance();
}
inline ::COWA::MapData::CrossroadOverlapInfo* Overlap_ObjectOverlapInfo::mutable_crossroad() {
  if (!has_crossroad()) {
    clear_overlap_info();
    set_has_crossroad();
    overlap_info_.crossroad_ = new ::COWA::MapData::CrossroadOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Overlap.ObjectOverlapInfo.crossroad)
  return overlap_info_.crossroad_;
}
inline ::COWA::MapData::CrossroadOverlapInfo* Overlap_ObjectOverlapInfo::release_crossroad() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Overlap.ObjectOverlapInfo.crossroad)
  if (has_crossroad()) {
    clear_has_overlap_info();
    ::COWA::MapData::CrossroadOverlapInfo* temp = overlap_info_.crossroad_;
    overlap_info_.crossroad_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Overlap_ObjectOverlapInfo::set_allocated_crossroad(::COWA::MapData::CrossroadOverlapInfo* crossroad) {
  clear_overlap_info();
  if (crossroad) {
    set_has_crossroad();
    overlap_info_.crossroad_ = crossroad;
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Overlap.ObjectOverlapInfo.crossroad)
}

// optional .COWA.MapData.CrosswalkOverlapInfo crosswalk = 5;
inline bool Overlap_ObjectOverlapInfo::has_crosswalk() const {
  return overlap_info_case() == kCrosswalk;
}
inline void Overlap_ObjectOverlapInfo::set_has_crosswalk() {
  _oneof_case_[0] = kCrosswalk;
}
inline void Overlap_ObjectOverlapInfo::clear_crosswalk() {
  if (has_crosswalk()) {
    delete overlap_info_.crosswalk_;
    clear_has_overlap_info();
  }
}
inline  const ::COWA::MapData::CrosswalkOverlapInfo& Overlap_ObjectOverlapInfo::crosswalk() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Overlap.ObjectOverlapInfo.crosswalk)
  return has_crosswalk()
      ? *overlap_info_.crosswalk_
      : ::COWA::MapData::CrosswalkOverlapInfo::default_instance();
}
inline ::COWA::MapData::CrosswalkOverlapInfo* Overlap_ObjectOverlapInfo::mutable_crosswalk() {
  if (!has_crosswalk()) {
    clear_overlap_info();
    set_has_crosswalk();
    overlap_info_.crosswalk_ = new ::COWA::MapData::CrosswalkOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Overlap.ObjectOverlapInfo.crosswalk)
  return overlap_info_.crosswalk_;
}
inline ::COWA::MapData::CrosswalkOverlapInfo* Overlap_ObjectOverlapInfo::release_crosswalk() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Overlap.ObjectOverlapInfo.crosswalk)
  if (has_crosswalk()) {
    clear_has_overlap_info();
    ::COWA::MapData::CrosswalkOverlapInfo* temp = overlap_info_.crosswalk_;
    overlap_info_.crosswalk_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Overlap_ObjectOverlapInfo::set_allocated_crosswalk(::COWA::MapData::CrosswalkOverlapInfo* crosswalk) {
  clear_overlap_info();
  if (crosswalk) {
    set_has_crosswalk();
    overlap_info_.crosswalk_ = crosswalk;
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Overlap.ObjectOverlapInfo.crosswalk)
}

// optional .COWA.MapData.RampOverlapInfo ramp = 6;
inline bool Overlap_ObjectOverlapInfo::has_ramp() const {
  return overlap_info_case() == kRamp;
}
inline void Overlap_ObjectOverlapInfo::set_has_ramp() {
  _oneof_case_[0] = kRamp;
}
inline void Overlap_ObjectOverlapInfo::clear_ramp() {
  if (has_ramp()) {
    delete overlap_info_.ramp_;
    clear_has_overlap_info();
  }
}
inline  const ::COWA::MapData::RampOverlapInfo& Overlap_ObjectOverlapInfo::ramp() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Overlap.ObjectOverlapInfo.ramp)
  return has_ramp()
      ? *overlap_info_.ramp_
      : ::COWA::MapData::RampOverlapInfo::default_instance();
}
inline ::COWA::MapData::RampOverlapInfo* Overlap_ObjectOverlapInfo::mutable_ramp() {
  if (!has_ramp()) {
    clear_overlap_info();
    set_has_ramp();
    overlap_info_.ramp_ = new ::COWA::MapData::RampOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Overlap.ObjectOverlapInfo.ramp)
  return overlap_info_.ramp_;
}
inline ::COWA::MapData::RampOverlapInfo* Overlap_ObjectOverlapInfo::release_ramp() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Overlap.ObjectOverlapInfo.ramp)
  if (has_ramp()) {
    clear_has_overlap_info();
    ::COWA::MapData::RampOverlapInfo* temp = overlap_info_.ramp_;
    overlap_info_.ramp_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Overlap_ObjectOverlapInfo::set_allocated_ramp(::COWA::MapData::RampOverlapInfo* ramp) {
  clear_overlap_info();
  if (ramp) {
    set_has_ramp();
    overlap_info_.ramp_ = ramp;
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Overlap.ObjectOverlapInfo.ramp)
}

// optional .COWA.MapData.RoadmarkOverlapInfo roadmark = 7;
inline bool Overlap_ObjectOverlapInfo::has_roadmark() const {
  return overlap_info_case() == kRoadmark;
}
inline void Overlap_ObjectOverlapInfo::set_has_roadmark() {
  _oneof_case_[0] = kRoadmark;
}
inline void Overlap_ObjectOverlapInfo::clear_roadmark() {
  if (has_roadmark()) {
    delete overlap_info_.roadmark_;
    clear_has_overlap_info();
  }
}
inline  const ::COWA::MapData::RoadmarkOverlapInfo& Overlap_ObjectOverlapInfo::roadmark() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Overlap.ObjectOverlapInfo.roadmark)
  return has_roadmark()
      ? *overlap_info_.roadmark_
      : ::COWA::MapData::RoadmarkOverlapInfo::default_instance();
}
inline ::COWA::MapData::RoadmarkOverlapInfo* Overlap_ObjectOverlapInfo::mutable_roadmark() {
  if (!has_roadmark()) {
    clear_overlap_info();
    set_has_roadmark();
    overlap_info_.roadmark_ = new ::COWA::MapData::RoadmarkOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Overlap.ObjectOverlapInfo.roadmark)
  return overlap_info_.roadmark_;
}
inline ::COWA::MapData::RoadmarkOverlapInfo* Overlap_ObjectOverlapInfo::release_roadmark() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Overlap.ObjectOverlapInfo.roadmark)
  if (has_roadmark()) {
    clear_has_overlap_info();
    ::COWA::MapData::RoadmarkOverlapInfo* temp = overlap_info_.roadmark_;
    overlap_info_.roadmark_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Overlap_ObjectOverlapInfo::set_allocated_roadmark(::COWA::MapData::RoadmarkOverlapInfo* roadmark) {
  clear_overlap_info();
  if (roadmark) {
    set_has_roadmark();
    overlap_info_.roadmark_ = roadmark;
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Overlap.ObjectOverlapInfo.roadmark)
}

// optional .COWA.MapData.RoadOverlapInfo road = 8;
inline bool Overlap_ObjectOverlapInfo::has_road() const {
  return overlap_info_case() == kRoad;
}
inline void Overlap_ObjectOverlapInfo::set_has_road() {
  _oneof_case_[0] = kRoad;
}
inline void Overlap_ObjectOverlapInfo::clear_road() {
  if (has_road()) {
    delete overlap_info_.road_;
    clear_has_overlap_info();
  }
}
inline  const ::COWA::MapData::RoadOverlapInfo& Overlap_ObjectOverlapInfo::road() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Overlap.ObjectOverlapInfo.road)
  return has_road()
      ? *overlap_info_.road_
      : ::COWA::MapData::RoadOverlapInfo::default_instance();
}
inline ::COWA::MapData::RoadOverlapInfo* Overlap_ObjectOverlapInfo::mutable_road() {
  if (!has_road()) {
    clear_overlap_info();
    set_has_road();
    overlap_info_.road_ = new ::COWA::MapData::RoadOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Overlap.ObjectOverlapInfo.road)
  return overlap_info_.road_;
}
inline ::COWA::MapData::RoadOverlapInfo* Overlap_ObjectOverlapInfo::release_road() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Overlap.ObjectOverlapInfo.road)
  if (has_road()) {
    clear_has_overlap_info();
    ::COWA::MapData::RoadOverlapInfo* temp = overlap_info_.road_;
    overlap_info_.road_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Overlap_ObjectOverlapInfo::set_allocated_road(::COWA::MapData::RoadOverlapInfo* road) {
  clear_overlap_info();
  if (road) {
    set_has_road();
    overlap_info_.road_ = road;
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Overlap.ObjectOverlapInfo.road)
}

inline bool Overlap_ObjectOverlapInfo::has_overlap_info() const {
  return overlap_info_case() != OVERLAP_INFO_NOT_SET;
}
inline void Overlap_ObjectOverlapInfo::clear_has_overlap_info() {
  _oneof_case_[0] = OVERLAP_INFO_NOT_SET;
}
inline Overlap_ObjectOverlapInfo::OverlapInfoCase Overlap_ObjectOverlapInfo::overlap_info_case() const {
  return Overlap_ObjectOverlapInfo::OverlapInfoCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Overlap

// optional .COWA.MapData.Overlap.ObjectOverlapInfo first = 2;
inline bool Overlap::has_first() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Overlap::set_has_first() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Overlap::clear_has_first() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Overlap::clear_first() {
  if (first_ != NULL) first_->::COWA::MapData::Overlap_ObjectOverlapInfo::Clear();
  clear_has_first();
}
inline const ::COWA::MapData::Overlap_ObjectOverlapInfo& Overlap::first() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Overlap.first)
  return first_ != NULL ? *first_
                         : *::COWA::MapData::Overlap_ObjectOverlapInfo::internal_default_instance();
}
inline ::COWA::MapData::Overlap_ObjectOverlapInfo* Overlap::mutable_first() {
  set_has_first();
  if (first_ == NULL) {
    first_ = new ::COWA::MapData::Overlap_ObjectOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Overlap.first)
  return first_;
}
inline ::COWA::MapData::Overlap_ObjectOverlapInfo* Overlap::release_first() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Overlap.first)
  clear_has_first();
  ::COWA::MapData::Overlap_ObjectOverlapInfo* temp = first_;
  first_ = NULL;
  return temp;
}
inline void Overlap::set_allocated_first(::COWA::MapData::Overlap_ObjectOverlapInfo* first) {
  delete first_;
  first_ = first;
  if (first) {
    set_has_first();
  } else {
    clear_has_first();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Overlap.first)
}

// optional .COWA.MapData.Overlap.ObjectOverlapInfo second = 3;
inline bool Overlap::has_second() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Overlap::set_has_second() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Overlap::clear_has_second() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Overlap::clear_second() {
  if (second_ != NULL) second_->::COWA::MapData::Overlap_ObjectOverlapInfo::Clear();
  clear_has_second();
}
inline const ::COWA::MapData::Overlap_ObjectOverlapInfo& Overlap::second() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Overlap.second)
  return second_ != NULL ? *second_
                         : *::COWA::MapData::Overlap_ObjectOverlapInfo::internal_default_instance();
}
inline ::COWA::MapData::Overlap_ObjectOverlapInfo* Overlap::mutable_second() {
  set_has_second();
  if (second_ == NULL) {
    second_ = new ::COWA::MapData::Overlap_ObjectOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Overlap.second)
  return second_;
}
inline ::COWA::MapData::Overlap_ObjectOverlapInfo* Overlap::release_second() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Overlap.second)
  clear_has_second();
  ::COWA::MapData::Overlap_ObjectOverlapInfo* temp = second_;
  second_ = NULL;
  return temp;
}
inline void Overlap::set_allocated_second(::COWA::MapData::Overlap_ObjectOverlapInfo* second) {
  delete second_;
  second_ = second;
  if (second) {
    set_has_second();
  } else {
    clear_has_second();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Overlap.second)
}

// optional .COWA.MapData.Polygon polygon = 4;
inline bool Overlap::has_polygon() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Overlap::set_has_polygon() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Overlap::clear_has_polygon() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Overlap::clear_polygon() {
  if (polygon_ != NULL) polygon_->::COWA::MapData::Polygon::Clear();
  clear_has_polygon();
}
inline const ::COWA::MapData::Polygon& Overlap::polygon() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Overlap.polygon)
  return polygon_ != NULL ? *polygon_
                         : *::COWA::MapData::Polygon::internal_default_instance();
}
inline ::COWA::MapData::Polygon* Overlap::mutable_polygon() {
  set_has_polygon();
  if (polygon_ == NULL) {
    polygon_ = new ::COWA::MapData::Polygon;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Overlap.polygon)
  return polygon_;
}
inline ::COWA::MapData::Polygon* Overlap::release_polygon() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Overlap.polygon)
  clear_has_polygon();
  ::COWA::MapData::Polygon* temp = polygon_;
  polygon_ = NULL;
  return temp;
}
inline void Overlap::set_allocated_polygon(::COWA::MapData::Polygon* polygon) {
  delete polygon_;
  polygon_ = polygon;
  if (polygon) {
    set_has_polygon();
  } else {
    clear_has_polygon();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Overlap.polygon)
}

// -------------------------------------------------------------------

// Header

// optional string version = 1;
inline bool Header::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Header::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Header::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Header::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_version();
}
inline const ::std::string& Header::version() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Header.version)
  return version_.GetNoArena();
}
inline void Header::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:COWA.MapData.Header.version)
}
#if LANG_CXX11
inline void Header::set_version(::std::string&& value) {
  set_has_version();
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:COWA.MapData.Header.version)
}
#endif
inline void Header::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:COWA.MapData.Header.version)
}
inline void Header::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:COWA.MapData.Header.version)
}
inline ::std::string* Header::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Header.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_version() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Header.version)
  clear_has_version();
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Header.version)
}

// optional string date = 2;
inline bool Header::has_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Header::set_has_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Header::clear_has_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Header::clear_date() {
  date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_date();
}
inline const ::std::string& Header::date() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Header.date)
  return date_.GetNoArena();
}
inline void Header::set_date(const ::std::string& value) {
  set_has_date();
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:COWA.MapData.Header.date)
}
#if LANG_CXX11
inline void Header::set_date(::std::string&& value) {
  set_has_date();
  date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:COWA.MapData.Header.date)
}
#endif
inline void Header::set_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_date();
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:COWA.MapData.Header.date)
}
inline void Header::set_date(const char* value, size_t size) {
  set_has_date();
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:COWA.MapData.Header.date)
}
inline ::std::string* Header::mutable_date() {
  set_has_date();
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Header.date)
  return date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_date() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Header.date)
  clear_has_date();
  return date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_date(::std::string* date) {
  if (date != NULL) {
    set_has_date();
  } else {
    clear_has_date();
  }
  date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), date);
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Header.date)
}

// optional string projection = 3;
inline bool Header::has_projection() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Header::set_has_projection() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Header::clear_has_projection() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Header::clear_projection() {
  projection_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_projection();
}
inline const ::std::string& Header::projection() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Header.projection)
  return projection_.GetNoArena();
}
inline void Header::set_projection(const ::std::string& value) {
  set_has_projection();
  projection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:COWA.MapData.Header.projection)
}
#if LANG_CXX11
inline void Header::set_projection(::std::string&& value) {
  set_has_projection();
  projection_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:COWA.MapData.Header.projection)
}
#endif
inline void Header::set_projection(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_projection();
  projection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:COWA.MapData.Header.projection)
}
inline void Header::set_projection(const char* value, size_t size) {
  set_has_projection();
  projection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:COWA.MapData.Header.projection)
}
inline ::std::string* Header::mutable_projection() {
  set_has_projection();
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Header.projection)
  return projection_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_projection() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Header.projection)
  clear_has_projection();
  return projection_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_projection(::std::string* projection) {
  if (projection != NULL) {
    set_has_projection();
  } else {
    clear_has_projection();
  }
  projection_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), projection);
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Header.projection)
}

// optional string generation = 4;
inline bool Header::has_generation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Header::set_has_generation() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Header::clear_has_generation() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Header::clear_generation() {
  generation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_generation();
}
inline const ::std::string& Header::generation() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Header.generation)
  return generation_.GetNoArena();
}
inline void Header::set_generation(const ::std::string& value) {
  set_has_generation();
  generation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:COWA.MapData.Header.generation)
}
#if LANG_CXX11
inline void Header::set_generation(::std::string&& value) {
  set_has_generation();
  generation_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:COWA.MapData.Header.generation)
}
#endif
inline void Header::set_generation(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_generation();
  generation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:COWA.MapData.Header.generation)
}
inline void Header::set_generation(const char* value, size_t size) {
  set_has_generation();
  generation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:COWA.MapData.Header.generation)
}
inline ::std::string* Header::mutable_generation() {
  set_has_generation();
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Header.generation)
  return generation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_generation() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Header.generation)
  clear_has_generation();
  return generation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_generation(::std::string* generation) {
  if (generation != NULL) {
    set_has_generation();
  } else {
    clear_has_generation();
  }
  generation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), generation);
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Header.generation)
}

// optional string md5 = 5;
inline bool Header::has_md5() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Header::set_has_md5() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Header::clear_has_md5() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Header::clear_md5() {
  md5_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_md5();
}
inline const ::std::string& Header::md5() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Header.md5)
  return md5_.GetNoArena();
}
inline void Header::set_md5(const ::std::string& value) {
  set_has_md5();
  md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:COWA.MapData.Header.md5)
}
#if LANG_CXX11
inline void Header::set_md5(::std::string&& value) {
  set_has_md5();
  md5_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:COWA.MapData.Header.md5)
}
#endif
inline void Header::set_md5(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_md5();
  md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:COWA.MapData.Header.md5)
}
inline void Header::set_md5(const char* value, size_t size) {
  set_has_md5();
  md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:COWA.MapData.Header.md5)
}
inline ::std::string* Header::mutable_md5() {
  set_has_md5();
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Header.md5)
  return md5_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_md5() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Header.md5)
  clear_has_md5();
  return md5_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_md5(::std::string* md5) {
  if (md5 != NULL) {
    set_has_md5();
  } else {
    clear_has_md5();
  }
  md5_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), md5);
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Header.md5)
}

// repeated string log = 6;
inline int Header::log_size() const {
  return log_.size();
}
inline void Header::clear_log() {
  log_.Clear();
}
inline const ::std::string& Header::log(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Header.log)
  return log_.Get(index);
}
inline ::std::string* Header::mutable_log(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Header.log)
  return log_.Mutable(index);
}
inline void Header::set_log(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:COWA.MapData.Header.log)
  log_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Header::set_log(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:COWA.MapData.Header.log)
  log_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Header::set_log(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  log_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:COWA.MapData.Header.log)
}
inline void Header::set_log(int index, const char* value, size_t size) {
  log_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:COWA.MapData.Header.log)
}
inline ::std::string* Header::add_log() {
  // @@protoc_insertion_point(field_add_mutable:COWA.MapData.Header.log)
  return log_.Add();
}
inline void Header::add_log(const ::std::string& value) {
  log_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:COWA.MapData.Header.log)
}
#if LANG_CXX11
inline void Header::add_log(::std::string&& value) {
  log_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:COWA.MapData.Header.log)
}
#endif
inline void Header::add_log(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  log_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:COWA.MapData.Header.log)
}
inline void Header::add_log(const char* value, size_t size) {
  log_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:COWA.MapData.Header.log)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Header::log() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.Header.log)
  return log_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Header::mutable_log() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.Header.log)
  return &log_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace MapData
}  // namespace COWA

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_hdmap_5fcommon_2eproto__INCLUDED
