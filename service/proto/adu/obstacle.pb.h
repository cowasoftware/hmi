// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: obstacle.proto

#ifndef PROTOBUF_obstacle_2eproto__INCLUDED
#define PROTOBUF_obstacle_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "pose.pb.h"
#include "trajectory.pb.h"
// @@protoc_insertion_point(includes)
namespace COWA {
namespace NavMsg {
class Covariance;
class CovarianceDefaultTypeInternal;
extern CovarianceDefaultTypeInternal _Covariance_default_instance_;
class Obstacle;
class ObstacleDefaultTypeInternal;
extern ObstacleDefaultTypeInternal _Obstacle_default_instance_;
class Obstacle_ObstacleTrajectory;
class Obstacle_ObstacleTrajectoryDefaultTypeInternal;
extern Obstacle_ObstacleTrajectoryDefaultTypeInternal _Obstacle_ObstacleTrajectory_default_instance_;
class Obstacles;
class ObstaclesDefaultTypeInternal;
extern ObstaclesDefaultTypeInternal _Obstacles_default_instance_;
class Point3D;
class Point3DDefaultTypeInternal;
extern Point3DDefaultTypeInternal _Point3D_default_instance_;
class Pose;
class PoseDefaultTypeInternal;
extern PoseDefaultTypeInternal _Pose_default_instance_;
class PoseStamped;
class PoseStampedDefaultTypeInternal;
extern PoseStampedDefaultTypeInternal _PoseStamped_default_instance_;
class PoseStampedArray;
class PoseStampedArrayDefaultTypeInternal;
extern PoseStampedArrayDefaultTypeInternal _PoseStampedArray_default_instance_;
class Quaternion;
class QuaternionDefaultTypeInternal;
extern QuaternionDefaultTypeInternal _Quaternion_default_instance_;
class Trajectory;
class TrajectoryDefaultTypeInternal;
extern TrajectoryDefaultTypeInternal _Trajectory_default_instance_;
class TrajectoryPoint;
class TrajectoryPointDefaultTypeInternal;
extern TrajectoryPointDefaultTypeInternal _TrajectoryPoint_default_instance_;
class Velocity;
class VelocityDefaultTypeInternal;
extern VelocityDefaultTypeInternal _Velocity_default_instance_;
}  // namespace NavMsg
}  // namespace COWA

namespace COWA {
namespace NavMsg {

namespace protobuf_obstacle_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_obstacle_2eproto

enum Obstacle_Type {
  Obstacle_Type_UNKNOWN = 0,
  Obstacle_Type_UNKNOWN_MOVABLE = 1,
  Obstacle_Type_UNKNOWN_UNMOVABLE = 2,
  Obstacle_Type_CAR = 3,
  Obstacle_Type_BUS = 4,
  Obstacle_Type_TRUCK = 5,
  Obstacle_Type_SPECIAL = 6,
  Obstacle_Type_CYCLIST = 10,
  Obstacle_Type_TRICYCLE = 11,
  Obstacle_Type_MOTORCYCLIST = 12,
  Obstacle_Type_PEDESTRIAN = 20,
  Obstacle_Type_WHEELCHAIR = 21,
  Obstacle_Type_BABYCAR = 22,
  Obstacle_Type_ROADBLOCK = 30,
  Obstacle_Type_TREE_TRUNK = 31,
  Obstacle_Type_POLE = 32,
  Obstacle_Type_PILES = 33,
  Obstacle_Type_DUSTBIN = 35,
  Obstacle_Type_BLOCK = 36,
  Obstacle_Type_CURB_LINE = 37,
  Obstacle_Type_TRAFFICLIGHT = 40
};
bool Obstacle_Type_IsValid(int value);
const Obstacle_Type Obstacle_Type_Type_MIN = Obstacle_Type_UNKNOWN;
const Obstacle_Type Obstacle_Type_Type_MAX = Obstacle_Type_TRAFFICLIGHT;
const int Obstacle_Type_Type_ARRAYSIZE = Obstacle_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Obstacle_Type_descriptor();
inline const ::std::string& Obstacle_Type_Name(Obstacle_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Obstacle_Type_descriptor(), value);
}
inline bool Obstacle_Type_Parse(
    const ::std::string& name, Obstacle_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Obstacle_Type>(
    Obstacle_Type_descriptor(), name, value);
}
enum Obstacle_SignalLamp {
  Obstacle_SignalLamp_INDICATE_OFF = 0,
  Obstacle_SignalLamp_INDICATE_LEFT = 1,
  Obstacle_SignalLamp_INDICATE_RIGHT = 2,
  Obstacle_SignalLamp_EMERGENCY_FLASHER = 3,
  Obstacle_SignalLamp_INDICATE_UNKNOWN = 9
};
bool Obstacle_SignalLamp_IsValid(int value);
const Obstacle_SignalLamp Obstacle_SignalLamp_SignalLamp_MIN = Obstacle_SignalLamp_INDICATE_OFF;
const Obstacle_SignalLamp Obstacle_SignalLamp_SignalLamp_MAX = Obstacle_SignalLamp_INDICATE_UNKNOWN;
const int Obstacle_SignalLamp_SignalLamp_ARRAYSIZE = Obstacle_SignalLamp_SignalLamp_MAX + 1;

const ::google::protobuf::EnumDescriptor* Obstacle_SignalLamp_descriptor();
inline const ::std::string& Obstacle_SignalLamp_Name(Obstacle_SignalLamp value) {
  return ::google::protobuf::internal::NameOfEnum(
    Obstacle_SignalLamp_descriptor(), value);
}
inline bool Obstacle_SignalLamp_Parse(
    const ::std::string& name, Obstacle_SignalLamp* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Obstacle_SignalLamp>(
    Obstacle_SignalLamp_descriptor(), name, value);
}
enum Obstacle_BrakeLamp {
  Obstacle_BrakeLamp_BRAKE_OFF = 0,
  Obstacle_BrakeLamp_BRAKE_ON = 1,
  Obstacle_BrakeLamp_BRAKE_UNKNOWN = 9
};
bool Obstacle_BrakeLamp_IsValid(int value);
const Obstacle_BrakeLamp Obstacle_BrakeLamp_BrakeLamp_MIN = Obstacle_BrakeLamp_BRAKE_OFF;
const Obstacle_BrakeLamp Obstacle_BrakeLamp_BrakeLamp_MAX = Obstacle_BrakeLamp_BRAKE_UNKNOWN;
const int Obstacle_BrakeLamp_BrakeLamp_ARRAYSIZE = Obstacle_BrakeLamp_BrakeLamp_MAX + 1;

const ::google::protobuf::EnumDescriptor* Obstacle_BrakeLamp_descriptor();
inline const ::std::string& Obstacle_BrakeLamp_Name(Obstacle_BrakeLamp value) {
  return ::google::protobuf::internal::NameOfEnum(
    Obstacle_BrakeLamp_descriptor(), value);
}
inline bool Obstacle_BrakeLamp_Parse(
    const ::std::string& name, Obstacle_BrakeLamp* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Obstacle_BrakeLamp>(
    Obstacle_BrakeLamp_descriptor(), name, value);
}
// ===================================================================

class Obstacle_ObstacleTrajectory : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.NavMsg.Obstacle.ObstacleTrajectory) */ {
 public:
  Obstacle_ObstacleTrajectory();
  virtual ~Obstacle_ObstacleTrajectory();

  Obstacle_ObstacleTrajectory(const Obstacle_ObstacleTrajectory& from);

  inline Obstacle_ObstacleTrajectory& operator=(const Obstacle_ObstacleTrajectory& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Obstacle_ObstacleTrajectory& default_instance();

  static inline const Obstacle_ObstacleTrajectory* internal_default_instance() {
    return reinterpret_cast<const Obstacle_ObstacleTrajectory*>(
               &_Obstacle_ObstacleTrajectory_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Obstacle_ObstacleTrajectory* other);

  // implements Message ----------------------------------------------

  inline Obstacle_ObstacleTrajectory* New() const PROTOBUF_FINAL { return New(NULL); }

  Obstacle_ObstacleTrajectory* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Obstacle_ObstacleTrajectory& from);
  void MergeFrom(const Obstacle_ObstacleTrajectory& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Obstacle_ObstacleTrajectory* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .COWA.NavMsg.TrajectoryPoint point = 2;
  int point_size() const;
  void clear_point();
  static const int kPointFieldNumber = 2;
  const ::COWA::NavMsg::TrajectoryPoint& point(int index) const;
  ::COWA::NavMsg::TrajectoryPoint* mutable_point(int index);
  ::COWA::NavMsg::TrajectoryPoint* add_point();
  ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::TrajectoryPoint >*
      mutable_point();
  const ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::TrajectoryPoint >&
      point() const;

  // optional float confidence = 1;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 1;
  float confidence() const;
  void set_confidence(float value);

  // @@protoc_insertion_point(class_scope:COWA.NavMsg.Obstacle.ObstacleTrajectory)
 private:
  void set_has_confidence();
  void clear_has_confidence();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::TrajectoryPoint > point_;
  float confidence_;
  friend struct protobuf_obstacle_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Obstacle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.NavMsg.Obstacle) */ {
 public:
  Obstacle();
  virtual ~Obstacle();

  Obstacle(const Obstacle& from);

  inline Obstacle& operator=(const Obstacle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Obstacle& default_instance();

  static inline const Obstacle* internal_default_instance() {
    return reinterpret_cast<const Obstacle*>(
               &_Obstacle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Obstacle* other);

  // implements Message ----------------------------------------------

  inline Obstacle* New() const PROTOBUF_FINAL { return New(NULL); }

  Obstacle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Obstacle& from);
  void MergeFrom(const Obstacle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Obstacle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Obstacle_ObstacleTrajectory ObstacleTrajectory;

  typedef Obstacle_Type Type;
  static const Type UNKNOWN =
    Obstacle_Type_UNKNOWN;
  static const Type UNKNOWN_MOVABLE =
    Obstacle_Type_UNKNOWN_MOVABLE;
  static const Type UNKNOWN_UNMOVABLE =
    Obstacle_Type_UNKNOWN_UNMOVABLE;
  static const Type CAR =
    Obstacle_Type_CAR;
  static const Type BUS =
    Obstacle_Type_BUS;
  static const Type TRUCK =
    Obstacle_Type_TRUCK;
  static const Type SPECIAL =
    Obstacle_Type_SPECIAL;
  static const Type CYCLIST =
    Obstacle_Type_CYCLIST;
  static const Type TRICYCLE =
    Obstacle_Type_TRICYCLE;
  static const Type MOTORCYCLIST =
    Obstacle_Type_MOTORCYCLIST;
  static const Type PEDESTRIAN =
    Obstacle_Type_PEDESTRIAN;
  static const Type WHEELCHAIR =
    Obstacle_Type_WHEELCHAIR;
  static const Type BABYCAR =
    Obstacle_Type_BABYCAR;
  static const Type ROADBLOCK =
    Obstacle_Type_ROADBLOCK;
  static const Type TREE_TRUNK =
    Obstacle_Type_TREE_TRUNK;
  static const Type POLE =
    Obstacle_Type_POLE;
  static const Type PILES =
    Obstacle_Type_PILES;
  static const Type DUSTBIN =
    Obstacle_Type_DUSTBIN;
  static const Type BLOCK =
    Obstacle_Type_BLOCK;
  static const Type CURB_LINE =
    Obstacle_Type_CURB_LINE;
  static const Type TRAFFICLIGHT =
    Obstacle_Type_TRAFFICLIGHT;
  static inline bool Type_IsValid(int value) {
    return Obstacle_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Obstacle_Type_Type_MIN;
  static const Type Type_MAX =
    Obstacle_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Obstacle_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Obstacle_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Obstacle_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Obstacle_Type_Parse(name, value);
  }

  typedef Obstacle_SignalLamp SignalLamp;
  static const SignalLamp INDICATE_OFF =
    Obstacle_SignalLamp_INDICATE_OFF;
  static const SignalLamp INDICATE_LEFT =
    Obstacle_SignalLamp_INDICATE_LEFT;
  static const SignalLamp INDICATE_RIGHT =
    Obstacle_SignalLamp_INDICATE_RIGHT;
  static const SignalLamp EMERGENCY_FLASHER =
    Obstacle_SignalLamp_EMERGENCY_FLASHER;
  static const SignalLamp INDICATE_UNKNOWN =
    Obstacle_SignalLamp_INDICATE_UNKNOWN;
  static inline bool SignalLamp_IsValid(int value) {
    return Obstacle_SignalLamp_IsValid(value);
  }
  static const SignalLamp SignalLamp_MIN =
    Obstacle_SignalLamp_SignalLamp_MIN;
  static const SignalLamp SignalLamp_MAX =
    Obstacle_SignalLamp_SignalLamp_MAX;
  static const int SignalLamp_ARRAYSIZE =
    Obstacle_SignalLamp_SignalLamp_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SignalLamp_descriptor() {
    return Obstacle_SignalLamp_descriptor();
  }
  static inline const ::std::string& SignalLamp_Name(SignalLamp value) {
    return Obstacle_SignalLamp_Name(value);
  }
  static inline bool SignalLamp_Parse(const ::std::string& name,
      SignalLamp* value) {
    return Obstacle_SignalLamp_Parse(name, value);
  }

  typedef Obstacle_BrakeLamp BrakeLamp;
  static const BrakeLamp BRAKE_OFF =
    Obstacle_BrakeLamp_BRAKE_OFF;
  static const BrakeLamp BRAKE_ON =
    Obstacle_BrakeLamp_BRAKE_ON;
  static const BrakeLamp BRAKE_UNKNOWN =
    Obstacle_BrakeLamp_BRAKE_UNKNOWN;
  static inline bool BrakeLamp_IsValid(int value) {
    return Obstacle_BrakeLamp_IsValid(value);
  }
  static const BrakeLamp BrakeLamp_MIN =
    Obstacle_BrakeLamp_BrakeLamp_MIN;
  static const BrakeLamp BrakeLamp_MAX =
    Obstacle_BrakeLamp_BrakeLamp_MAX;
  static const int BrakeLamp_ARRAYSIZE =
    Obstacle_BrakeLamp_BrakeLamp_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BrakeLamp_descriptor() {
    return Obstacle_BrakeLamp_descriptor();
  }
  static inline const ::std::string& BrakeLamp_Name(BrakeLamp value) {
    return Obstacle_BrakeLamp_Name(value);
  }
  static inline bool BrakeLamp_Parse(const ::std::string& name,
      BrakeLamp* value) {
    return Obstacle_BrakeLamp_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .COWA.NavMsg.Point3D bounding_contours = 11;
  int bounding_contours_size() const;
  void clear_bounding_contours();
  static const int kBoundingContoursFieldNumber = 11;
  const ::COWA::NavMsg::Point3D& bounding_contours(int index) const;
  ::COWA::NavMsg::Point3D* mutable_bounding_contours(int index);
  ::COWA::NavMsg::Point3D* add_bounding_contours();
  ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::Point3D >*
      mutable_bounding_contours();
  const ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::Point3D >&
      bounding_contours() const;

  // repeated .COWA.NavMsg.Obstacle.ObstacleTrajectory trajectory = 20;
  int trajectory_size() const;
  void clear_trajectory();
  static const int kTrajectoryFieldNumber = 20;
  const ::COWA::NavMsg::Obstacle_ObstacleTrajectory& trajectory(int index) const;
  ::COWA::NavMsg::Obstacle_ObstacleTrajectory* mutable_trajectory(int index);
  ::COWA::NavMsg::Obstacle_ObstacleTrajectory* add_trajectory();
  ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::Obstacle_ObstacleTrajectory >*
      mutable_trajectory();
  const ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::Obstacle_ObstacleTrajectory >&
      trajectory() const;

  // optional .COWA.NavMsg.Pose pose = 5;
  bool has_pose() const;
  void clear_pose();
  static const int kPoseFieldNumber = 5;
  const ::COWA::NavMsg::Pose& pose() const;
  ::COWA::NavMsg::Pose* mutable_pose();
  ::COWA::NavMsg::Pose* release_pose();
  void set_allocated_pose(::COWA::NavMsg::Pose* pose);

  // optional .COWA.NavMsg.Velocity velocity = 6;
  bool has_velocity() const;
  void clear_velocity();
  static const int kVelocityFieldNumber = 6;
  const ::COWA::NavMsg::Velocity& velocity() const;
  ::COWA::NavMsg::Velocity* mutable_velocity();
  ::COWA::NavMsg::Velocity* release_velocity();
  void set_allocated_velocity(::COWA::NavMsg::Velocity* velocity);

  // optional .COWA.NavMsg.Velocity acceleration = 13;
  bool has_acceleration() const;
  void clear_acceleration();
  static const int kAccelerationFieldNumber = 13;
  const ::COWA::NavMsg::Velocity& acceleration() const;
  ::COWA::NavMsg::Velocity* mutable_acceleration();
  ::COWA::NavMsg::Velocity* release_acceleration();
  void set_allocated_acceleration(::COWA::NavMsg::Velocity* acceleration);

  // optional uint64 timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // optional int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // optional .COWA.NavMsg.Obstacle.Type type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::COWA::NavMsg::Obstacle_Type type() const;
  void set_type(::COWA::NavMsg::Obstacle_Type value);

  // optional float length = 7;
  bool has_length() const;
  void clear_length();
  static const int kLengthFieldNumber = 7;
  float length() const;
  void set_length(float value);

  // optional float width = 8;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 8;
  float width() const;
  void set_width(float value);

  // optional float height = 9;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 9;
  float height() const;
  void set_height(float value);

  // optional bool is_static = 10;
  bool has_is_static() const;
  void clear_is_static();
  static const int kIsStaticFieldNumber = 10;
  bool is_static() const;
  void set_is_static(bool value);

  // optional float confidence = 12;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 12;
  float confidence() const;
  void set_confidence(float value);

  // optional .COWA.NavMsg.Obstacle.SignalLamp signal = 14;
  bool has_signal() const;
  void clear_signal();
  static const int kSignalFieldNumber = 14;
  ::COWA::NavMsg::Obstacle_SignalLamp signal() const;
  void set_signal(::COWA::NavMsg::Obstacle_SignalLamp value);

  // optional .COWA.NavMsg.Obstacle.BrakeLamp brake = 15;
  bool has_brake() const;
  void clear_brake();
  static const int kBrakeFieldNumber = 15;
  ::COWA::NavMsg::Obstacle_BrakeLamp brake() const;
  void set_brake(::COWA::NavMsg::Obstacle_BrakeLamp value);

  // optional int32 track_id = 16;
  bool has_track_id() const;
  void clear_track_id();
  static const int kTrackIdFieldNumber = 16;
  ::google::protobuf::int32 track_id() const;
  void set_track_id(::google::protobuf::int32 value);

  // optional float theta = 21;
  bool has_theta() const;
  void clear_theta();
  static const int kThetaFieldNumber = 21;
  float theta() const;
  void set_theta(float value);

  // optional float theta_confidence = 22;
  bool has_theta_confidence() const;
  void clear_theta_confidence();
  static const int kThetaConfidenceFieldNumber = 22;
  float theta_confidence() const;
  void set_theta_confidence(float value);

  // optional float pose_confidence = 23;
  bool has_pose_confidence() const;
  void clear_pose_confidence();
  static const int kPoseConfidenceFieldNumber = 23;
  float pose_confidence() const;
  void set_pose_confidence(float value);

  // optional float velocity_confidence = 24;
  bool has_velocity_confidence() const;
  void clear_velocity_confidence();
  static const int kVelocityConfidenceFieldNumber = 24;
  float velocity_confidence() const;
  void set_velocity_confidence(float value);

  // optional float size_confidence = 25;
  bool has_size_confidence() const;
  void clear_size_confidence();
  static const int kSizeConfidenceFieldNumber = 25;
  float size_confidence() const;
  void set_size_confidence(float value);

  // optional float bounding_confidence = 26;
  bool has_bounding_confidence() const;
  void clear_bounding_confidence();
  static const int kBoundingConfidenceFieldNumber = 26;
  float bounding_confidence() const;
  void set_bounding_confidence(float value);

  // @@protoc_insertion_point(class_scope:COWA.NavMsg.Obstacle)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_type();
  void clear_has_type();
  void set_has_theta();
  void clear_has_theta();
  void set_has_theta_confidence();
  void clear_has_theta_confidence();
  void set_has_pose();
  void clear_has_pose();
  void set_has_pose_confidence();
  void clear_has_pose_confidence();
  void set_has_velocity();
  void clear_has_velocity();
  void set_has_velocity_confidence();
  void clear_has_velocity_confidence();
  void set_has_length();
  void clear_has_length();
  void set_has_width();
  void clear_has_width();
  void set_has_height();
  void clear_has_height();
  void set_has_size_confidence();
  void clear_has_size_confidence();
  void set_has_is_static();
  void clear_has_is_static();
  void set_has_track_id();
  void clear_has_track_id();
  void set_has_bounding_confidence();
  void clear_has_bounding_confidence();
  void set_has_confidence();
  void clear_has_confidence();
  void set_has_acceleration();
  void clear_has_acceleration();
  void set_has_signal();
  void clear_has_signal();
  void set_has_brake();
  void clear_has_brake();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::Point3D > bounding_contours_;
  ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::Obstacle_ObstacleTrajectory > trajectory_;
  ::COWA::NavMsg::Pose* pose_;
  ::COWA::NavMsg::Velocity* velocity_;
  ::COWA::NavMsg::Velocity* acceleration_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::int32 id_;
  int type_;
  float length_;
  float width_;
  float height_;
  bool is_static_;
  float confidence_;
  int signal_;
  int brake_;
  ::google::protobuf::int32 track_id_;
  float theta_;
  float theta_confidence_;
  float pose_confidence_;
  float velocity_confidence_;
  float size_confidence_;
  float bounding_confidence_;
  friend struct protobuf_obstacle_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Obstacles : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.NavMsg.Obstacles) */ {
 public:
  Obstacles();
  virtual ~Obstacles();

  Obstacles(const Obstacles& from);

  inline Obstacles& operator=(const Obstacles& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Obstacles& default_instance();

  static inline const Obstacles* internal_default_instance() {
    return reinterpret_cast<const Obstacles*>(
               &_Obstacles_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Obstacles* other);

  // implements Message ----------------------------------------------

  inline Obstacles* New() const PROTOBUF_FINAL { return New(NULL); }

  Obstacles* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Obstacles& from);
  void MergeFrom(const Obstacles& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Obstacles* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .COWA.NavMsg.Obstacle obstacles = 4;
  int obstacles_size() const;
  void clear_obstacles();
  static const int kObstaclesFieldNumber = 4;
  const ::COWA::NavMsg::Obstacle& obstacles(int index) const;
  ::COWA::NavMsg::Obstacle* mutable_obstacles(int index);
  ::COWA::NavMsg::Obstacle* add_obstacles();
  ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::Obstacle >*
      mutable_obstacles();
  const ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::Obstacle >&
      obstacles() const;

  // optional bytes frame_id = 1;
  bool has_frame_id() const;
  void clear_frame_id();
  static const int kFrameIdFieldNumber = 1;
  const ::std::string& frame_id() const;
  void set_frame_id(const ::std::string& value);
  #if LANG_CXX11
  void set_frame_id(::std::string&& value);
  #endif
  void set_frame_id(const char* value);
  void set_frame_id(const void* value, size_t size);
  ::std::string* mutable_frame_id();
  ::std::string* release_frame_id();
  void set_allocated_frame_id(::std::string* frame_id);

  // optional string debug = 6;
  bool has_debug() const;
  void clear_debug();
  static const int kDebugFieldNumber = 6;
  const ::std::string& debug() const;
  void set_debug(const ::std::string& value);
  #if LANG_CXX11
  void set_debug(::std::string&& value);
  #endif
  void set_debug(const char* value);
  void set_debug(const char* value, size_t size);
  ::std::string* mutable_debug();
  ::std::string* release_debug();
  void set_allocated_debug(::std::string* debug);

  // optional uint64 timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // optional uint32 sequence = 3;
  bool has_sequence() const;
  void clear_sequence();
  static const int kSequenceFieldNumber = 3;
  ::google::protobuf::uint32 sequence() const;
  void set_sequence(::google::protobuf::uint32 value);

  // optional int32 latency_ms = 5;
  bool has_latency_ms() const;
  void clear_latency_ms();
  static const int kLatencyMsFieldNumber = 5;
  ::google::protobuf::int32 latency_ms() const;
  void set_latency_ms(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:COWA.NavMsg.Obstacles)
 private:
  void set_has_frame_id();
  void clear_has_frame_id();
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_sequence();
  void clear_has_sequence();
  void set_has_latency_ms();
  void clear_has_latency_ms();
  void set_has_debug();
  void clear_has_debug();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::Obstacle > obstacles_;
  ::google::protobuf::internal::ArenaStringPtr frame_id_;
  ::google::protobuf::internal::ArenaStringPtr debug_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::uint32 sequence_;
  ::google::protobuf::int32 latency_ms_;
  friend struct protobuf_obstacle_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Obstacle_ObstacleTrajectory

// optional float confidence = 1;
inline bool Obstacle_ObstacleTrajectory::has_confidence() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Obstacle_ObstacleTrajectory::set_has_confidence() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Obstacle_ObstacleTrajectory::clear_has_confidence() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Obstacle_ObstacleTrajectory::clear_confidence() {
  confidence_ = 0;
  clear_has_confidence();
}
inline float Obstacle_ObstacleTrajectory::confidence() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.Obstacle.ObstacleTrajectory.confidence)
  return confidence_;
}
inline void Obstacle_ObstacleTrajectory::set_confidence(float value) {
  set_has_confidence();
  confidence_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.Obstacle.ObstacleTrajectory.confidence)
}

// repeated .COWA.NavMsg.TrajectoryPoint point = 2;
inline int Obstacle_ObstacleTrajectory::point_size() const {
  return point_.size();
}
inline void Obstacle_ObstacleTrajectory::clear_point() {
  point_.Clear();
}
inline const ::COWA::NavMsg::TrajectoryPoint& Obstacle_ObstacleTrajectory::point(int index) const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.Obstacle.ObstacleTrajectory.point)
  return point_.Get(index);
}
inline ::COWA::NavMsg::TrajectoryPoint* Obstacle_ObstacleTrajectory::mutable_point(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.NavMsg.Obstacle.ObstacleTrajectory.point)
  return point_.Mutable(index);
}
inline ::COWA::NavMsg::TrajectoryPoint* Obstacle_ObstacleTrajectory::add_point() {
  // @@protoc_insertion_point(field_add:COWA.NavMsg.Obstacle.ObstacleTrajectory.point)
  return point_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::TrajectoryPoint >*
Obstacle_ObstacleTrajectory::mutable_point() {
  // @@protoc_insertion_point(field_mutable_list:COWA.NavMsg.Obstacle.ObstacleTrajectory.point)
  return &point_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::TrajectoryPoint >&
Obstacle_ObstacleTrajectory::point() const {
  // @@protoc_insertion_point(field_list:COWA.NavMsg.Obstacle.ObstacleTrajectory.point)
  return point_;
}

// -------------------------------------------------------------------

// Obstacle

// optional int32 id = 1;
inline bool Obstacle::has_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Obstacle::set_has_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Obstacle::clear_has_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Obstacle::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Obstacle::id() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.Obstacle.id)
  return id_;
}
inline void Obstacle::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.Obstacle.id)
}

// optional uint64 timestamp = 2;
inline bool Obstacle::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Obstacle::set_has_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Obstacle::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Obstacle::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 Obstacle::timestamp() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.Obstacle.timestamp)
  return timestamp_;
}
inline void Obstacle::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.Obstacle.timestamp)
}

// optional .COWA.NavMsg.Obstacle.Type type = 3;
inline bool Obstacle::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Obstacle::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Obstacle::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Obstacle::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::COWA::NavMsg::Obstacle_Type Obstacle::type() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.Obstacle.type)
  return static_cast< ::COWA::NavMsg::Obstacle_Type >(type_);
}
inline void Obstacle::set_type(::COWA::NavMsg::Obstacle_Type value) {
  assert(::COWA::NavMsg::Obstacle_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.Obstacle.type)
}

// optional float theta = 21;
inline bool Obstacle::has_theta() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Obstacle::set_has_theta() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Obstacle::clear_has_theta() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Obstacle::clear_theta() {
  theta_ = 0;
  clear_has_theta();
}
inline float Obstacle::theta() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.Obstacle.theta)
  return theta_;
}
inline void Obstacle::set_theta(float value) {
  set_has_theta();
  theta_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.Obstacle.theta)
}

// optional float theta_confidence = 22;
inline bool Obstacle::has_theta_confidence() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Obstacle::set_has_theta_confidence() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Obstacle::clear_has_theta_confidence() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Obstacle::clear_theta_confidence() {
  theta_confidence_ = 0;
  clear_has_theta_confidence();
}
inline float Obstacle::theta_confidence() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.Obstacle.theta_confidence)
  return theta_confidence_;
}
inline void Obstacle::set_theta_confidence(float value) {
  set_has_theta_confidence();
  theta_confidence_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.Obstacle.theta_confidence)
}

// optional .COWA.NavMsg.Pose pose = 5;
inline bool Obstacle::has_pose() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Obstacle::set_has_pose() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Obstacle::clear_has_pose() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Obstacle::clear_pose() {
  if (pose_ != NULL) pose_->::COWA::NavMsg::Pose::Clear();
  clear_has_pose();
}
inline const ::COWA::NavMsg::Pose& Obstacle::pose() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.Obstacle.pose)
  return pose_ != NULL ? *pose_
                         : *::COWA::NavMsg::Pose::internal_default_instance();
}
inline ::COWA::NavMsg::Pose* Obstacle::mutable_pose() {
  set_has_pose();
  if (pose_ == NULL) {
    pose_ = new ::COWA::NavMsg::Pose;
  }
  // @@protoc_insertion_point(field_mutable:COWA.NavMsg.Obstacle.pose)
  return pose_;
}
inline ::COWA::NavMsg::Pose* Obstacle::release_pose() {
  // @@protoc_insertion_point(field_release:COWA.NavMsg.Obstacle.pose)
  clear_has_pose();
  ::COWA::NavMsg::Pose* temp = pose_;
  pose_ = NULL;
  return temp;
}
inline void Obstacle::set_allocated_pose(::COWA::NavMsg::Pose* pose) {
  delete pose_;
  pose_ = pose;
  if (pose) {
    set_has_pose();
  } else {
    clear_has_pose();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.NavMsg.Obstacle.pose)
}

// optional float pose_confidence = 23;
inline bool Obstacle::has_pose_confidence() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Obstacle::set_has_pose_confidence() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Obstacle::clear_has_pose_confidence() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Obstacle::clear_pose_confidence() {
  pose_confidence_ = 0;
  clear_has_pose_confidence();
}
inline float Obstacle::pose_confidence() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.Obstacle.pose_confidence)
  return pose_confidence_;
}
inline void Obstacle::set_pose_confidence(float value) {
  set_has_pose_confidence();
  pose_confidence_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.Obstacle.pose_confidence)
}

// optional .COWA.NavMsg.Velocity velocity = 6;
inline bool Obstacle::has_velocity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Obstacle::set_has_velocity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Obstacle::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Obstacle::clear_velocity() {
  if (velocity_ != NULL) velocity_->::COWA::NavMsg::Velocity::Clear();
  clear_has_velocity();
}
inline const ::COWA::NavMsg::Velocity& Obstacle::velocity() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.Obstacle.velocity)
  return velocity_ != NULL ? *velocity_
                         : *::COWA::NavMsg::Velocity::internal_default_instance();
}
inline ::COWA::NavMsg::Velocity* Obstacle::mutable_velocity() {
  set_has_velocity();
  if (velocity_ == NULL) {
    velocity_ = new ::COWA::NavMsg::Velocity;
  }
  // @@protoc_insertion_point(field_mutable:COWA.NavMsg.Obstacle.velocity)
  return velocity_;
}
inline ::COWA::NavMsg::Velocity* Obstacle::release_velocity() {
  // @@protoc_insertion_point(field_release:COWA.NavMsg.Obstacle.velocity)
  clear_has_velocity();
  ::COWA::NavMsg::Velocity* temp = velocity_;
  velocity_ = NULL;
  return temp;
}
inline void Obstacle::set_allocated_velocity(::COWA::NavMsg::Velocity* velocity) {
  delete velocity_;
  velocity_ = velocity;
  if (velocity) {
    set_has_velocity();
  } else {
    clear_has_velocity();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.NavMsg.Obstacle.velocity)
}

// optional float velocity_confidence = 24;
inline bool Obstacle::has_velocity_confidence() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Obstacle::set_has_velocity_confidence() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Obstacle::clear_has_velocity_confidence() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Obstacle::clear_velocity_confidence() {
  velocity_confidence_ = 0;
  clear_has_velocity_confidence();
}
inline float Obstacle::velocity_confidence() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.Obstacle.velocity_confidence)
  return velocity_confidence_;
}
inline void Obstacle::set_velocity_confidence(float value) {
  set_has_velocity_confidence();
  velocity_confidence_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.Obstacle.velocity_confidence)
}

// optional float length = 7;
inline bool Obstacle::has_length() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Obstacle::set_has_length() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Obstacle::clear_has_length() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Obstacle::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline float Obstacle::length() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.Obstacle.length)
  return length_;
}
inline void Obstacle::set_length(float value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.Obstacle.length)
}

// optional float width = 8;
inline bool Obstacle::has_width() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Obstacle::set_has_width() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Obstacle::clear_has_width() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Obstacle::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline float Obstacle::width() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.Obstacle.width)
  return width_;
}
inline void Obstacle::set_width(float value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.Obstacle.width)
}

// optional float height = 9;
inline bool Obstacle::has_height() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Obstacle::set_has_height() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Obstacle::clear_has_height() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Obstacle::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline float Obstacle::height() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.Obstacle.height)
  return height_;
}
inline void Obstacle::set_height(float value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.Obstacle.height)
}

// optional float size_confidence = 25;
inline bool Obstacle::has_size_confidence() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Obstacle::set_has_size_confidence() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Obstacle::clear_has_size_confidence() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Obstacle::clear_size_confidence() {
  size_confidence_ = 0;
  clear_has_size_confidence();
}
inline float Obstacle::size_confidence() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.Obstacle.size_confidence)
  return size_confidence_;
}
inline void Obstacle::set_size_confidence(float value) {
  set_has_size_confidence();
  size_confidence_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.Obstacle.size_confidence)
}

// optional bool is_static = 10;
inline bool Obstacle::has_is_static() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Obstacle::set_has_is_static() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Obstacle::clear_has_is_static() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Obstacle::clear_is_static() {
  is_static_ = false;
  clear_has_is_static();
}
inline bool Obstacle::is_static() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.Obstacle.is_static)
  return is_static_;
}
inline void Obstacle::set_is_static(bool value) {
  set_has_is_static();
  is_static_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.Obstacle.is_static)
}

// optional int32 track_id = 16;
inline bool Obstacle::has_track_id() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Obstacle::set_has_track_id() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Obstacle::clear_has_track_id() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Obstacle::clear_track_id() {
  track_id_ = 0;
  clear_has_track_id();
}
inline ::google::protobuf::int32 Obstacle::track_id() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.Obstacle.track_id)
  return track_id_;
}
inline void Obstacle::set_track_id(::google::protobuf::int32 value) {
  set_has_track_id();
  track_id_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.Obstacle.track_id)
}

// repeated .COWA.NavMsg.Point3D bounding_contours = 11;
inline int Obstacle::bounding_contours_size() const {
  return bounding_contours_.size();
}
inline void Obstacle::clear_bounding_contours() {
  bounding_contours_.Clear();
}
inline const ::COWA::NavMsg::Point3D& Obstacle::bounding_contours(int index) const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.Obstacle.bounding_contours)
  return bounding_contours_.Get(index);
}
inline ::COWA::NavMsg::Point3D* Obstacle::mutable_bounding_contours(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.NavMsg.Obstacle.bounding_contours)
  return bounding_contours_.Mutable(index);
}
inline ::COWA::NavMsg::Point3D* Obstacle::add_bounding_contours() {
  // @@protoc_insertion_point(field_add:COWA.NavMsg.Obstacle.bounding_contours)
  return bounding_contours_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::Point3D >*
Obstacle::mutable_bounding_contours() {
  // @@protoc_insertion_point(field_mutable_list:COWA.NavMsg.Obstacle.bounding_contours)
  return &bounding_contours_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::Point3D >&
Obstacle::bounding_contours() const {
  // @@protoc_insertion_point(field_list:COWA.NavMsg.Obstacle.bounding_contours)
  return bounding_contours_;
}

// optional float bounding_confidence = 26;
inline bool Obstacle::has_bounding_confidence() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Obstacle::set_has_bounding_confidence() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Obstacle::clear_has_bounding_confidence() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Obstacle::clear_bounding_confidence() {
  bounding_confidence_ = 0;
  clear_has_bounding_confidence();
}
inline float Obstacle::bounding_confidence() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.Obstacle.bounding_confidence)
  return bounding_confidence_;
}
inline void Obstacle::set_bounding_confidence(float value) {
  set_has_bounding_confidence();
  bounding_confidence_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.Obstacle.bounding_confidence)
}

// optional float confidence = 12;
inline bool Obstacle::has_confidence() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Obstacle::set_has_confidence() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Obstacle::clear_has_confidence() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Obstacle::clear_confidence() {
  confidence_ = 0;
  clear_has_confidence();
}
inline float Obstacle::confidence() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.Obstacle.confidence)
  return confidence_;
}
inline void Obstacle::set_confidence(float value) {
  set_has_confidence();
  confidence_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.Obstacle.confidence)
}

// optional .COWA.NavMsg.Velocity acceleration = 13;
inline bool Obstacle::has_acceleration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Obstacle::set_has_acceleration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Obstacle::clear_has_acceleration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Obstacle::clear_acceleration() {
  if (acceleration_ != NULL) acceleration_->::COWA::NavMsg::Velocity::Clear();
  clear_has_acceleration();
}
inline const ::COWA::NavMsg::Velocity& Obstacle::acceleration() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.Obstacle.acceleration)
  return acceleration_ != NULL ? *acceleration_
                         : *::COWA::NavMsg::Velocity::internal_default_instance();
}
inline ::COWA::NavMsg::Velocity* Obstacle::mutable_acceleration() {
  set_has_acceleration();
  if (acceleration_ == NULL) {
    acceleration_ = new ::COWA::NavMsg::Velocity;
  }
  // @@protoc_insertion_point(field_mutable:COWA.NavMsg.Obstacle.acceleration)
  return acceleration_;
}
inline ::COWA::NavMsg::Velocity* Obstacle::release_acceleration() {
  // @@protoc_insertion_point(field_release:COWA.NavMsg.Obstacle.acceleration)
  clear_has_acceleration();
  ::COWA::NavMsg::Velocity* temp = acceleration_;
  acceleration_ = NULL;
  return temp;
}
inline void Obstacle::set_allocated_acceleration(::COWA::NavMsg::Velocity* acceleration) {
  delete acceleration_;
  acceleration_ = acceleration;
  if (acceleration) {
    set_has_acceleration();
  } else {
    clear_has_acceleration();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.NavMsg.Obstacle.acceleration)
}

// optional .COWA.NavMsg.Obstacle.SignalLamp signal = 14;
inline bool Obstacle::has_signal() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Obstacle::set_has_signal() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Obstacle::clear_has_signal() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Obstacle::clear_signal() {
  signal_ = 0;
  clear_has_signal();
}
inline ::COWA::NavMsg::Obstacle_SignalLamp Obstacle::signal() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.Obstacle.signal)
  return static_cast< ::COWA::NavMsg::Obstacle_SignalLamp >(signal_);
}
inline void Obstacle::set_signal(::COWA::NavMsg::Obstacle_SignalLamp value) {
  assert(::COWA::NavMsg::Obstacle_SignalLamp_IsValid(value));
  set_has_signal();
  signal_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.Obstacle.signal)
}

// optional .COWA.NavMsg.Obstacle.BrakeLamp brake = 15;
inline bool Obstacle::has_brake() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Obstacle::set_has_brake() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Obstacle::clear_has_brake() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Obstacle::clear_brake() {
  brake_ = 0;
  clear_has_brake();
}
inline ::COWA::NavMsg::Obstacle_BrakeLamp Obstacle::brake() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.Obstacle.brake)
  return static_cast< ::COWA::NavMsg::Obstacle_BrakeLamp >(brake_);
}
inline void Obstacle::set_brake(::COWA::NavMsg::Obstacle_BrakeLamp value) {
  assert(::COWA::NavMsg::Obstacle_BrakeLamp_IsValid(value));
  set_has_brake();
  brake_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.Obstacle.brake)
}

// repeated .COWA.NavMsg.Obstacle.ObstacleTrajectory trajectory = 20;
inline int Obstacle::trajectory_size() const {
  return trajectory_.size();
}
inline void Obstacle::clear_trajectory() {
  trajectory_.Clear();
}
inline const ::COWA::NavMsg::Obstacle_ObstacleTrajectory& Obstacle::trajectory(int index) const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.Obstacle.trajectory)
  return trajectory_.Get(index);
}
inline ::COWA::NavMsg::Obstacle_ObstacleTrajectory* Obstacle::mutable_trajectory(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.NavMsg.Obstacle.trajectory)
  return trajectory_.Mutable(index);
}
inline ::COWA::NavMsg::Obstacle_ObstacleTrajectory* Obstacle::add_trajectory() {
  // @@protoc_insertion_point(field_add:COWA.NavMsg.Obstacle.trajectory)
  return trajectory_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::Obstacle_ObstacleTrajectory >*
Obstacle::mutable_trajectory() {
  // @@protoc_insertion_point(field_mutable_list:COWA.NavMsg.Obstacle.trajectory)
  return &trajectory_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::Obstacle_ObstacleTrajectory >&
Obstacle::trajectory() const {
  // @@protoc_insertion_point(field_list:COWA.NavMsg.Obstacle.trajectory)
  return trajectory_;
}

// -------------------------------------------------------------------

// Obstacles

// optional bytes frame_id = 1;
inline bool Obstacles::has_frame_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Obstacles::set_has_frame_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Obstacles::clear_has_frame_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Obstacles::clear_frame_id() {
  frame_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_frame_id();
}
inline const ::std::string& Obstacles::frame_id() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.Obstacles.frame_id)
  return frame_id_.GetNoArena();
}
inline void Obstacles::set_frame_id(const ::std::string& value) {
  set_has_frame_id();
  frame_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:COWA.NavMsg.Obstacles.frame_id)
}
#if LANG_CXX11
inline void Obstacles::set_frame_id(::std::string&& value) {
  set_has_frame_id();
  frame_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:COWA.NavMsg.Obstacles.frame_id)
}
#endif
inline void Obstacles::set_frame_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_frame_id();
  frame_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:COWA.NavMsg.Obstacles.frame_id)
}
inline void Obstacles::set_frame_id(const void* value, size_t size) {
  set_has_frame_id();
  frame_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:COWA.NavMsg.Obstacles.frame_id)
}
inline ::std::string* Obstacles::mutable_frame_id() {
  set_has_frame_id();
  // @@protoc_insertion_point(field_mutable:COWA.NavMsg.Obstacles.frame_id)
  return frame_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Obstacles::release_frame_id() {
  // @@protoc_insertion_point(field_release:COWA.NavMsg.Obstacles.frame_id)
  clear_has_frame_id();
  return frame_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Obstacles::set_allocated_frame_id(::std::string* frame_id) {
  if (frame_id != NULL) {
    set_has_frame_id();
  } else {
    clear_has_frame_id();
  }
  frame_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), frame_id);
  // @@protoc_insertion_point(field_set_allocated:COWA.NavMsg.Obstacles.frame_id)
}

// optional uint64 timestamp = 2;
inline bool Obstacles::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Obstacles::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Obstacles::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Obstacles::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 Obstacles::timestamp() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.Obstacles.timestamp)
  return timestamp_;
}
inline void Obstacles::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.Obstacles.timestamp)
}

// optional uint32 sequence = 3;
inline bool Obstacles::has_sequence() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Obstacles::set_has_sequence() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Obstacles::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Obstacles::clear_sequence() {
  sequence_ = 0u;
  clear_has_sequence();
}
inline ::google::protobuf::uint32 Obstacles::sequence() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.Obstacles.sequence)
  return sequence_;
}
inline void Obstacles::set_sequence(::google::protobuf::uint32 value) {
  set_has_sequence();
  sequence_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.Obstacles.sequence)
}

// repeated .COWA.NavMsg.Obstacle obstacles = 4;
inline int Obstacles::obstacles_size() const {
  return obstacles_.size();
}
inline void Obstacles::clear_obstacles() {
  obstacles_.Clear();
}
inline const ::COWA::NavMsg::Obstacle& Obstacles::obstacles(int index) const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.Obstacles.obstacles)
  return obstacles_.Get(index);
}
inline ::COWA::NavMsg::Obstacle* Obstacles::mutable_obstacles(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.NavMsg.Obstacles.obstacles)
  return obstacles_.Mutable(index);
}
inline ::COWA::NavMsg::Obstacle* Obstacles::add_obstacles() {
  // @@protoc_insertion_point(field_add:COWA.NavMsg.Obstacles.obstacles)
  return obstacles_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::Obstacle >*
Obstacles::mutable_obstacles() {
  // @@protoc_insertion_point(field_mutable_list:COWA.NavMsg.Obstacles.obstacles)
  return &obstacles_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::Obstacle >&
Obstacles::obstacles() const {
  // @@protoc_insertion_point(field_list:COWA.NavMsg.Obstacles.obstacles)
  return obstacles_;
}

// optional int32 latency_ms = 5;
inline bool Obstacles::has_latency_ms() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Obstacles::set_has_latency_ms() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Obstacles::clear_has_latency_ms() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Obstacles::clear_latency_ms() {
  latency_ms_ = 0;
  clear_has_latency_ms();
}
inline ::google::protobuf::int32 Obstacles::latency_ms() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.Obstacles.latency_ms)
  return latency_ms_;
}
inline void Obstacles::set_latency_ms(::google::protobuf::int32 value) {
  set_has_latency_ms();
  latency_ms_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.Obstacles.latency_ms)
}

// optional string debug = 6;
inline bool Obstacles::has_debug() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Obstacles::set_has_debug() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Obstacles::clear_has_debug() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Obstacles::clear_debug() {
  debug_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_debug();
}
inline const ::std::string& Obstacles::debug() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.Obstacles.debug)
  return debug_.GetNoArena();
}
inline void Obstacles::set_debug(const ::std::string& value) {
  set_has_debug();
  debug_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:COWA.NavMsg.Obstacles.debug)
}
#if LANG_CXX11
inline void Obstacles::set_debug(::std::string&& value) {
  set_has_debug();
  debug_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:COWA.NavMsg.Obstacles.debug)
}
#endif
inline void Obstacles::set_debug(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_debug();
  debug_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:COWA.NavMsg.Obstacles.debug)
}
inline void Obstacles::set_debug(const char* value, size_t size) {
  set_has_debug();
  debug_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:COWA.NavMsg.Obstacles.debug)
}
inline ::std::string* Obstacles::mutable_debug() {
  set_has_debug();
  // @@protoc_insertion_point(field_mutable:COWA.NavMsg.Obstacles.debug)
  return debug_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Obstacles::release_debug() {
  // @@protoc_insertion_point(field_release:COWA.NavMsg.Obstacles.debug)
  clear_has_debug();
  return debug_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Obstacles::set_allocated_debug(::std::string* debug) {
  if (debug != NULL) {
    set_has_debug();
  } else {
    clear_has_debug();
  }
  debug_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), debug);
  // @@protoc_insertion_point(field_set_allocated:COWA.NavMsg.Obstacles.debug)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace NavMsg
}  // namespace COWA

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::COWA::NavMsg::Obstacle_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::COWA::NavMsg::Obstacle_Type>() {
  return ::COWA::NavMsg::Obstacle_Type_descriptor();
}
template <> struct is_proto_enum< ::COWA::NavMsg::Obstacle_SignalLamp> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::COWA::NavMsg::Obstacle_SignalLamp>() {
  return ::COWA::NavMsg::Obstacle_SignalLamp_descriptor();
}
template <> struct is_proto_enum< ::COWA::NavMsg::Obstacle_BrakeLamp> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::COWA::NavMsg::Obstacle_BrakeLamp>() {
  return ::COWA::NavMsg::Obstacle_BrakeLamp_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_obstacle_2eproto__INCLUDED
