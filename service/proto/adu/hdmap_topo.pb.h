// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: hdmap_topo.proto

#ifndef PROTOBUF_hdmap_5ftopo_2eproto__INCLUDED
#define PROTOBUF_hdmap_5ftopo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "hdmap_common.pb.h"
// @@protoc_insertion_point(includes)
namespace COWA {
namespace MapData {
class Cloud;
class CloudDefaultTypeInternal;
extern CloudDefaultTypeInternal _Cloud_default_instance_;
class CrossroadOverlapInfo;
class CrossroadOverlapInfoDefaultTypeInternal;
extern CrossroadOverlapInfoDefaultTypeInternal _CrossroadOverlapInfo_default_instance_;
class CrosswalkOverlapInfo;
class CrosswalkOverlapInfoDefaultTypeInternal;
extern CrosswalkOverlapInfoDefaultTypeInternal _CrosswalkOverlapInfo_default_instance_;
class Edge;
class EdgeDefaultTypeInternal;
extern EdgeDefaultTypeInternal _Edge_default_instance_;
class Graph;
class GraphDefaultTypeInternal;
extern GraphDefaultTypeInternal _Graph_default_instance_;
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class Id;
class IdDefaultTypeInternal;
extern IdDefaultTypeInternal _Id_default_instance_;
class LaneOverlapInfo;
class LaneOverlapInfoDefaultTypeInternal;
extern LaneOverlapInfoDefaultTypeInternal _LaneOverlapInfo_default_instance_;
class Node;
class NodeDefaultTypeInternal;
extern NodeDefaultTypeInternal _Node_default_instance_;
class Overlap;
class OverlapDefaultTypeInternal;
extern OverlapDefaultTypeInternal _Overlap_default_instance_;
class Overlap_ObjectOverlapInfo;
class Overlap_ObjectOverlapInfoDefaultTypeInternal;
extern Overlap_ObjectOverlapInfoDefaultTypeInternal _Overlap_ObjectOverlapInfo_default_instance_;
class PointENU;
class PointENUDefaultTypeInternal;
extern PointENUDefaultTypeInternal _PointENU_default_instance_;
class Polygon;
class PolygonDefaultTypeInternal;
extern PolygonDefaultTypeInternal _Polygon_default_instance_;
class RampOverlapInfo;
class RampOverlapInfoDefaultTypeInternal;
extern RampOverlapInfoDefaultTypeInternal _RampOverlapInfo_default_instance_;
class RoadOverlapInfo;
class RoadOverlapInfoDefaultTypeInternal;
extern RoadOverlapInfoDefaultTypeInternal _RoadOverlapInfo_default_instance_;
class RoadmarkOverlapInfo;
class RoadmarkOverlapInfoDefaultTypeInternal;
extern RoadmarkOverlapInfoDefaultTypeInternal _RoadmarkOverlapInfo_default_instance_;
class SignalOverlapInfo;
class SignalOverlapInfoDefaultTypeInternal;
extern SignalOverlapInfoDefaultTypeInternal _SignalOverlapInfo_default_instance_;
class TopoId;
class TopoIdDefaultTypeInternal;
extern TopoIdDefaultTypeInternal _TopoId_default_instance_;
}  // namespace MapData
}  // namespace COWA

namespace COWA {
namespace MapData {

namespace protobuf_hdmap_5ftopo_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_hdmap_5ftopo_2eproto

enum Edge_DirectionType {
  Edge_DirectionType_FORWARD = 0,
  Edge_DirectionType_LEFT = 1,
  Edge_DirectionType_RIGHT = 2,
  Edge_DirectionType_BIDIRECTION = 3
};
bool Edge_DirectionType_IsValid(int value);
const Edge_DirectionType Edge_DirectionType_DirectionType_MIN = Edge_DirectionType_FORWARD;
const Edge_DirectionType Edge_DirectionType_DirectionType_MAX = Edge_DirectionType_BIDIRECTION;
const int Edge_DirectionType_DirectionType_ARRAYSIZE = Edge_DirectionType_DirectionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Edge_DirectionType_descriptor();
inline const ::std::string& Edge_DirectionType_Name(Edge_DirectionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Edge_DirectionType_descriptor(), value);
}
inline bool Edge_DirectionType_Parse(
    const ::std::string& name, Edge_DirectionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Edge_DirectionType>(
    Edge_DirectionType_descriptor(), name, value);
}
enum TopoType {
  CITY_DRIVING = 2,
  BIKING = 3,
  SIDEWALK = 4,
  PARKING = 5,
  SHOULDER = 6,
  RAMP = 7,
  CROSSWALK = 8,
  SQUARE = 9
};
bool TopoType_IsValid(int value);
const TopoType TopoType_MIN = CITY_DRIVING;
const TopoType TopoType_MAX = SQUARE;
const int TopoType_ARRAYSIZE = TopoType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TopoType_descriptor();
inline const ::std::string& TopoType_Name(TopoType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TopoType_descriptor(), value);
}
inline bool TopoType_Parse(
    const ::std::string& name, TopoType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TopoType>(
    TopoType_descriptor(), name, value);
}
// ===================================================================

class TopoId : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.MapData.TopoId) */ {
 public:
  TopoId();
  virtual ~TopoId();

  TopoId(const TopoId& from);

  inline TopoId& operator=(const TopoId& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopoId& default_instance();

  static inline const TopoId* internal_default_instance() {
    return reinterpret_cast<const TopoId*>(
               &_TopoId_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(TopoId* other);

  // implements Message ----------------------------------------------

  inline TopoId* New() const PROTOBUF_FINAL { return New(NULL); }

  TopoId* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TopoId& from);
  void MergeFrom(const TopoId& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TopoId* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional .COWA.MapData.TopoType type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::COWA::MapData::TopoType type() const;
  void set_type(::COWA::MapData::TopoType value);

  // @@protoc_insertion_point(class_scope:COWA.MapData.TopoId)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_type();
  void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  int type_;
  friend struct protobuf_hdmap_5ftopo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Node : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.MapData.Node) */ {
 public:
  Node();
  virtual ~Node();

  Node(const Node& from);

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Node& default_instance();

  static inline const Node* internal_default_instance() {
    return reinterpret_cast<const Node*>(
               &_Node_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Node* other);

  // implements Message ----------------------------------------------

  inline Node* New() const PROTOBUF_FINAL { return New(NULL); }

  Node* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Node& from);
  void MergeFrom(const Node& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Node* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .COWA.MapData.TopoId id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::COWA::MapData::TopoId& id() const;
  ::COWA::MapData::TopoId* mutable_id();
  ::COWA::MapData::TopoId* release_id();
  void set_allocated_id(::COWA::MapData::TopoId* id);

  // optional double cost = 2;
  bool has_cost() const;
  void clear_cost();
  static const int kCostFieldNumber = 2;
  double cost() const;
  void set_cost(double value);

  // @@protoc_insertion_point(class_scope:COWA.MapData.Node)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_cost();
  void clear_has_cost();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::COWA::MapData::TopoId* id_;
  double cost_;
  friend struct protobuf_hdmap_5ftopo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Edge : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.MapData.Edge) */ {
 public:
  Edge();
  virtual ~Edge();

  Edge(const Edge& from);

  inline Edge& operator=(const Edge& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Edge& default_instance();

  static inline const Edge* internal_default_instance() {
    return reinterpret_cast<const Edge*>(
               &_Edge_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Edge* other);

  // implements Message ----------------------------------------------

  inline Edge* New() const PROTOBUF_FINAL { return New(NULL); }

  Edge* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Edge& from);
  void MergeFrom(const Edge& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Edge* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Edge_DirectionType DirectionType;
  static const DirectionType FORWARD =
    Edge_DirectionType_FORWARD;
  static const DirectionType LEFT =
    Edge_DirectionType_LEFT;
  static const DirectionType RIGHT =
    Edge_DirectionType_RIGHT;
  static const DirectionType BIDIRECTION =
    Edge_DirectionType_BIDIRECTION;
  static inline bool DirectionType_IsValid(int value) {
    return Edge_DirectionType_IsValid(value);
  }
  static const DirectionType DirectionType_MIN =
    Edge_DirectionType_DirectionType_MIN;
  static const DirectionType DirectionType_MAX =
    Edge_DirectionType_DirectionType_MAX;
  static const int DirectionType_ARRAYSIZE =
    Edge_DirectionType_DirectionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DirectionType_descriptor() {
    return Edge_DirectionType_descriptor();
  }
  static inline const ::std::string& DirectionType_Name(DirectionType value) {
    return Edge_DirectionType_Name(value);
  }
  static inline bool DirectionType_Parse(const ::std::string& name,
      DirectionType* value) {
    return Edge_DirectionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .COWA.MapData.TopoId from = 1;
  bool has_from() const;
  void clear_from();
  static const int kFromFieldNumber = 1;
  const ::COWA::MapData::TopoId& from() const;
  ::COWA::MapData::TopoId* mutable_from();
  ::COWA::MapData::TopoId* release_from();
  void set_allocated_from(::COWA::MapData::TopoId* from);

  // optional .COWA.MapData.TopoId to = 2;
  bool has_to() const;
  void clear_to();
  static const int kToFieldNumber = 2;
  const ::COWA::MapData::TopoId& to() const;
  ::COWA::MapData::TopoId* mutable_to();
  ::COWA::MapData::TopoId* release_to();
  void set_allocated_to(::COWA::MapData::TopoId* to);

  // optional double cost = 3;
  bool has_cost() const;
  void clear_cost();
  static const int kCostFieldNumber = 3;
  double cost() const;
  void set_cost(double value);

  // optional .COWA.MapData.Edge.DirectionType type = 4;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  ::COWA::MapData::Edge_DirectionType type() const;
  void set_type(::COWA::MapData::Edge_DirectionType value);

  // @@protoc_insertion_point(class_scope:COWA.MapData.Edge)
 private:
  void set_has_from();
  void clear_has_from();
  void set_has_to();
  void clear_has_to();
  void set_has_cost();
  void clear_has_cost();
  void set_has_type();
  void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::COWA::MapData::TopoId* from_;
  ::COWA::MapData::TopoId* to_;
  double cost_;
  int type_;
  friend struct protobuf_hdmap_5ftopo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Graph : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.MapData.Graph) */ {
 public:
  Graph();
  virtual ~Graph();

  Graph(const Graph& from);

  inline Graph& operator=(const Graph& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Graph& default_instance();

  static inline const Graph* internal_default_instance() {
    return reinterpret_cast<const Graph*>(
               &_Graph_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Graph* other);

  // implements Message ----------------------------------------------

  inline Graph* New() const PROTOBUF_FINAL { return New(NULL); }

  Graph* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Graph& from);
  void MergeFrom(const Graph& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Graph* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .COWA.MapData.Node node = 3;
  int node_size() const;
  void clear_node();
  static const int kNodeFieldNumber = 3;
  const ::COWA::MapData::Node& node(int index) const;
  ::COWA::MapData::Node* mutable_node(int index);
  ::COWA::MapData::Node* add_node();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Node >*
      mutable_node();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Node >&
      node() const;

  // repeated .COWA.MapData.Edge edge = 4;
  int edge_size() const;
  void clear_edge();
  static const int kEdgeFieldNumber = 4;
  const ::COWA::MapData::Edge& edge(int index) const;
  ::COWA::MapData::Edge* mutable_edge(int index);
  ::COWA::MapData::Edge* add_edge();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Edge >*
      mutable_edge();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Edge >&
      edge() const;

  // optional .COWA.MapData.Header hdmap = 1;
  bool has_hdmap() const;
  void clear_hdmap();
  static const int kHdmapFieldNumber = 1;
  const ::COWA::MapData::Header& hdmap() const;
  ::COWA::MapData::Header* mutable_hdmap();
  ::COWA::MapData::Header* release_hdmap();
  void set_allocated_hdmap(::COWA::MapData::Header* hdmap);

  // @@protoc_insertion_point(class_scope:COWA.MapData.Graph)
 private:
  void set_has_hdmap();
  void clear_has_hdmap();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Node > node_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Edge > edge_;
  ::COWA::MapData::Header* hdmap_;
  friend struct protobuf_hdmap_5ftopo_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// TopoId

// optional string id = 1;
inline bool TopoId::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TopoId::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TopoId::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TopoId::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& TopoId::id() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.TopoId.id)
  return id_.GetNoArena();
}
inline void TopoId::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:COWA.MapData.TopoId.id)
}
#if LANG_CXX11
inline void TopoId::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:COWA.MapData.TopoId.id)
}
#endif
inline void TopoId::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:COWA.MapData.TopoId.id)
}
inline void TopoId::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:COWA.MapData.TopoId.id)
}
inline ::std::string* TopoId::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:COWA.MapData.TopoId.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TopoId::release_id() {
  // @@protoc_insertion_point(field_release:COWA.MapData.TopoId.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopoId::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.TopoId.id)
}

// optional .COWA.MapData.TopoType type = 2;
inline bool TopoId::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TopoId::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TopoId::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TopoId::clear_type() {
  type_ = 2;
  clear_has_type();
}
inline ::COWA::MapData::TopoType TopoId::type() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.TopoId.type)
  return static_cast< ::COWA::MapData::TopoType >(type_);
}
inline void TopoId::set_type(::COWA::MapData::TopoType value) {
  assert(::COWA::MapData::TopoType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.TopoId.type)
}

// -------------------------------------------------------------------

// Node

// optional .COWA.MapData.TopoId id = 1;
inline bool Node::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Node::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Node::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Node::clear_id() {
  if (id_ != NULL) id_->::COWA::MapData::TopoId::Clear();
  clear_has_id();
}
inline const ::COWA::MapData::TopoId& Node::id() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Node.id)
  return id_ != NULL ? *id_
                         : *::COWA::MapData::TopoId::internal_default_instance();
}
inline ::COWA::MapData::TopoId* Node::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    id_ = new ::COWA::MapData::TopoId;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Node.id)
  return id_;
}
inline ::COWA::MapData::TopoId* Node::release_id() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Node.id)
  clear_has_id();
  ::COWA::MapData::TopoId* temp = id_;
  id_ = NULL;
  return temp;
}
inline void Node::set_allocated_id(::COWA::MapData::TopoId* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Node.id)
}

// optional double cost = 2;
inline bool Node::has_cost() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Node::set_has_cost() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Node::clear_has_cost() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Node::clear_cost() {
  cost_ = 0;
  clear_has_cost();
}
inline double Node::cost() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Node.cost)
  return cost_;
}
inline void Node::set_cost(double value) {
  set_has_cost();
  cost_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.Node.cost)
}

// -------------------------------------------------------------------

// Edge

// optional .COWA.MapData.TopoId from = 1;
inline bool Edge::has_from() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Edge::set_has_from() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Edge::clear_has_from() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Edge::clear_from() {
  if (from_ != NULL) from_->::COWA::MapData::TopoId::Clear();
  clear_has_from();
}
inline const ::COWA::MapData::TopoId& Edge::from() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Edge.from)
  return from_ != NULL ? *from_
                         : *::COWA::MapData::TopoId::internal_default_instance();
}
inline ::COWA::MapData::TopoId* Edge::mutable_from() {
  set_has_from();
  if (from_ == NULL) {
    from_ = new ::COWA::MapData::TopoId;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Edge.from)
  return from_;
}
inline ::COWA::MapData::TopoId* Edge::release_from() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Edge.from)
  clear_has_from();
  ::COWA::MapData::TopoId* temp = from_;
  from_ = NULL;
  return temp;
}
inline void Edge::set_allocated_from(::COWA::MapData::TopoId* from) {
  delete from_;
  from_ = from;
  if (from) {
    set_has_from();
  } else {
    clear_has_from();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Edge.from)
}

// optional .COWA.MapData.TopoId to = 2;
inline bool Edge::has_to() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Edge::set_has_to() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Edge::clear_has_to() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Edge::clear_to() {
  if (to_ != NULL) to_->::COWA::MapData::TopoId::Clear();
  clear_has_to();
}
inline const ::COWA::MapData::TopoId& Edge::to() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Edge.to)
  return to_ != NULL ? *to_
                         : *::COWA::MapData::TopoId::internal_default_instance();
}
inline ::COWA::MapData::TopoId* Edge::mutable_to() {
  set_has_to();
  if (to_ == NULL) {
    to_ = new ::COWA::MapData::TopoId;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Edge.to)
  return to_;
}
inline ::COWA::MapData::TopoId* Edge::release_to() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Edge.to)
  clear_has_to();
  ::COWA::MapData::TopoId* temp = to_;
  to_ = NULL;
  return temp;
}
inline void Edge::set_allocated_to(::COWA::MapData::TopoId* to) {
  delete to_;
  to_ = to;
  if (to) {
    set_has_to();
  } else {
    clear_has_to();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Edge.to)
}

// optional double cost = 3;
inline bool Edge::has_cost() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Edge::set_has_cost() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Edge::clear_has_cost() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Edge::clear_cost() {
  cost_ = 0;
  clear_has_cost();
}
inline double Edge::cost() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Edge.cost)
  return cost_;
}
inline void Edge::set_cost(double value) {
  set_has_cost();
  cost_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.Edge.cost)
}

// optional .COWA.MapData.Edge.DirectionType type = 4;
inline bool Edge::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Edge::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Edge::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Edge::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::COWA::MapData::Edge_DirectionType Edge::type() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Edge.type)
  return static_cast< ::COWA::MapData::Edge_DirectionType >(type_);
}
inline void Edge::set_type(::COWA::MapData::Edge_DirectionType value) {
  assert(::COWA::MapData::Edge_DirectionType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.Edge.type)
}

// -------------------------------------------------------------------

// Graph

// optional .COWA.MapData.Header hdmap = 1;
inline bool Graph::has_hdmap() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Graph::set_has_hdmap() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Graph::clear_has_hdmap() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Graph::clear_hdmap() {
  if (hdmap_ != NULL) hdmap_->::COWA::MapData::Header::Clear();
  clear_has_hdmap();
}
inline const ::COWA::MapData::Header& Graph::hdmap() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Graph.hdmap)
  return hdmap_ != NULL ? *hdmap_
                         : *::COWA::MapData::Header::internal_default_instance();
}
inline ::COWA::MapData::Header* Graph::mutable_hdmap() {
  set_has_hdmap();
  if (hdmap_ == NULL) {
    hdmap_ = new ::COWA::MapData::Header;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Graph.hdmap)
  return hdmap_;
}
inline ::COWA::MapData::Header* Graph::release_hdmap() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Graph.hdmap)
  clear_has_hdmap();
  ::COWA::MapData::Header* temp = hdmap_;
  hdmap_ = NULL;
  return temp;
}
inline void Graph::set_allocated_hdmap(::COWA::MapData::Header* hdmap) {
  delete hdmap_;
  hdmap_ = hdmap;
  if (hdmap) {
    set_has_hdmap();
  } else {
    clear_has_hdmap();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Graph.hdmap)
}

// repeated .COWA.MapData.Node node = 3;
inline int Graph::node_size() const {
  return node_.size();
}
inline void Graph::clear_node() {
  node_.Clear();
}
inline const ::COWA::MapData::Node& Graph::node(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Graph.node)
  return node_.Get(index);
}
inline ::COWA::MapData::Node* Graph::mutable_node(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Graph.node)
  return node_.Mutable(index);
}
inline ::COWA::MapData::Node* Graph::add_node() {
  // @@protoc_insertion_point(field_add:COWA.MapData.Graph.node)
  return node_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Node >*
Graph::mutable_node() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.Graph.node)
  return &node_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Node >&
Graph::node() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.Graph.node)
  return node_;
}

// repeated .COWA.MapData.Edge edge = 4;
inline int Graph::edge_size() const {
  return edge_.size();
}
inline void Graph::clear_edge() {
  edge_.Clear();
}
inline const ::COWA::MapData::Edge& Graph::edge(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Graph.edge)
  return edge_.Get(index);
}
inline ::COWA::MapData::Edge* Graph::mutable_edge(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Graph.edge)
  return edge_.Mutable(index);
}
inline ::COWA::MapData::Edge* Graph::add_edge() {
  // @@protoc_insertion_point(field_add:COWA.MapData.Graph.edge)
  return edge_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Edge >*
Graph::mutable_edge() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.Graph.edge)
  return &edge_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Edge >&
Graph::edge() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.Graph.edge)
  return edge_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace MapData
}  // namespace COWA

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::COWA::MapData::Edge_DirectionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::COWA::MapData::Edge_DirectionType>() {
  return ::COWA::MapData::Edge_DirectionType_descriptor();
}
template <> struct is_proto_enum< ::COWA::MapData::TopoType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::COWA::MapData::TopoType>() {
  return ::COWA::MapData::TopoType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_hdmap_5ftopo_2eproto__INCLUDED
