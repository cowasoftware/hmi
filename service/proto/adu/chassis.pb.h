// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chassis.proto

#ifndef PROTOBUF_chassis_2eproto__INCLUDED
#define PROTOBUF_chassis_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace COWA {
namespace NavMsg {
class DebugField;
class DebugFieldDefaultTypeInternal;
extern DebugFieldDefaultTypeInternal _DebugField_default_instance_;
class VehicleBCM;
class VehicleBCMDefaultTypeInternal;
extern VehicleBCMDefaultTypeInternal _VehicleBCM_default_instance_;
class VehicleCommond;
class VehicleCommondDefaultTypeInternal;
extern VehicleCommondDefaultTypeInternal _VehicleCommond_default_instance_;
class VehicleDrive;
class VehicleDriveDefaultTypeInternal;
extern VehicleDriveDefaultTypeInternal _VehicleDrive_default_instance_;
class VehicleInfo;
class VehicleInfoDefaultTypeInternal;
extern VehicleInfoDefaultTypeInternal _VehicleInfo_default_instance_;
class VehicleSoc;
class VehicleSocDefaultTypeInternal;
extern VehicleSocDefaultTypeInternal _VehicleSoc_default_instance_;
}  // namespace NavMsg
}  // namespace COWA

namespace COWA {
namespace NavMsg {

namespace protobuf_chassis_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_chassis_2eproto

enum VehicleBCM_TurnSignal {
  VehicleBCM_TurnSignal_TURN_NONE = 0,
  VehicleBCM_TurnSignal_TURN_LEFT = 1,
  VehicleBCM_TurnSignal_TURN_RIGHT = 2
};
bool VehicleBCM_TurnSignal_IsValid(int value);
const VehicleBCM_TurnSignal VehicleBCM_TurnSignal_TurnSignal_MIN = VehicleBCM_TurnSignal_TURN_NONE;
const VehicleBCM_TurnSignal VehicleBCM_TurnSignal_TurnSignal_MAX = VehicleBCM_TurnSignal_TURN_RIGHT;
const int VehicleBCM_TurnSignal_TurnSignal_ARRAYSIZE = VehicleBCM_TurnSignal_TurnSignal_MAX + 1;

const ::google::protobuf::EnumDescriptor* VehicleBCM_TurnSignal_descriptor();
inline const ::std::string& VehicleBCM_TurnSignal_Name(VehicleBCM_TurnSignal value) {
  return ::google::protobuf::internal::NameOfEnum(
    VehicleBCM_TurnSignal_descriptor(), value);
}
inline bool VehicleBCM_TurnSignal_Parse(
    const ::std::string& name, VehicleBCM_TurnSignal* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VehicleBCM_TurnSignal>(
    VehicleBCM_TurnSignal_descriptor(), name, value);
}
enum VehicleDrive_DrivingMode {
  VehicleDrive_DrivingMode_MANUAL = 0,
  VehicleDrive_DrivingMode_AUTO_DRIVE = 1,
  VehicleDrive_DrivingMode_AUTO_STEER_ONLY = 2,
  VehicleDrive_DrivingMode_AUTO_SPEED_ONLY = 3,
  VehicleDrive_DrivingMode_EMERGENCY_MODE = 4,
  VehicleDrive_DrivingMode_STANDBY = 5,
  VehicleDrive_DrivingMode_PARKING = 6
};
bool VehicleDrive_DrivingMode_IsValid(int value);
const VehicleDrive_DrivingMode VehicleDrive_DrivingMode_DrivingMode_MIN = VehicleDrive_DrivingMode_MANUAL;
const VehicleDrive_DrivingMode VehicleDrive_DrivingMode_DrivingMode_MAX = VehicleDrive_DrivingMode_PARKING;
const int VehicleDrive_DrivingMode_DrivingMode_ARRAYSIZE = VehicleDrive_DrivingMode_DrivingMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* VehicleDrive_DrivingMode_descriptor();
inline const ::std::string& VehicleDrive_DrivingMode_Name(VehicleDrive_DrivingMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    VehicleDrive_DrivingMode_descriptor(), value);
}
inline bool VehicleDrive_DrivingMode_Parse(
    const ::std::string& name, VehicleDrive_DrivingMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VehicleDrive_DrivingMode>(
    VehicleDrive_DrivingMode_descriptor(), name, value);
}
enum VehicleDrive_GearPosition {
  VehicleDrive_GearPosition_GEAR_NEUTRAL = 0,
  VehicleDrive_GearPosition_GEAR_DRIVE = 1,
  VehicleDrive_GearPosition_GEAR_REVERSE = 2,
  VehicleDrive_GearPosition_GEAR_PARKING = 3,
  VehicleDrive_GearPosition_GEAR_NONE = 4
};
bool VehicleDrive_GearPosition_IsValid(int value);
const VehicleDrive_GearPosition VehicleDrive_GearPosition_GearPosition_MIN = VehicleDrive_GearPosition_GEAR_NEUTRAL;
const VehicleDrive_GearPosition VehicleDrive_GearPosition_GearPosition_MAX = VehicleDrive_GearPosition_GEAR_NONE;
const int VehicleDrive_GearPosition_GearPosition_ARRAYSIZE = VehicleDrive_GearPosition_GearPosition_MAX + 1;

const ::google::protobuf::EnumDescriptor* VehicleDrive_GearPosition_descriptor();
inline const ::std::string& VehicleDrive_GearPosition_Name(VehicleDrive_GearPosition value) {
  return ::google::protobuf::internal::NameOfEnum(
    VehicleDrive_GearPosition_descriptor(), value);
}
inline bool VehicleDrive_GearPosition_Parse(
    const ::std::string& name, VehicleDrive_GearPosition* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VehicleDrive_GearPosition>(
    VehicleDrive_GearPosition_descriptor(), name, value);
}
enum VehicleDrive_SpeedMode {
  VehicleDrive_SpeedMode_TORQUE = 0,
  VehicleDrive_SpeedMode_SPEED = 1
};
bool VehicleDrive_SpeedMode_IsValid(int value);
const VehicleDrive_SpeedMode VehicleDrive_SpeedMode_SpeedMode_MIN = VehicleDrive_SpeedMode_TORQUE;
const VehicleDrive_SpeedMode VehicleDrive_SpeedMode_SpeedMode_MAX = VehicleDrive_SpeedMode_SPEED;
const int VehicleDrive_SpeedMode_SpeedMode_ARRAYSIZE = VehicleDrive_SpeedMode_SpeedMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* VehicleDrive_SpeedMode_descriptor();
inline const ::std::string& VehicleDrive_SpeedMode_Name(VehicleDrive_SpeedMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    VehicleDrive_SpeedMode_descriptor(), value);
}
inline bool VehicleDrive_SpeedMode_Parse(
    const ::std::string& name, VehicleDrive_SpeedMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VehicleDrive_SpeedMode>(
    VehicleDrive_SpeedMode_descriptor(), name, value);
}
enum DrivingError {
  NO_ERROR = 0,
  CONTROL_TIMEOUT = 1,
  STEER_ERROR = 2,
  THROTTLE_ERROR = 3,
  BRAKE_ERROR = 4,
  GEAR_ERROR = 5,
  MANUAL_INTERVENTION = 6,
  CAN_ERROR = 7
};
bool DrivingError_IsValid(int value);
const DrivingError DrivingError_MIN = NO_ERROR;
const DrivingError DrivingError_MAX = CAN_ERROR;
const int DrivingError_ARRAYSIZE = DrivingError_MAX + 1;

const ::google::protobuf::EnumDescriptor* DrivingError_descriptor();
inline const ::std::string& DrivingError_Name(DrivingError value) {
  return ::google::protobuf::internal::NameOfEnum(
    DrivingError_descriptor(), value);
}
inline bool DrivingError_Parse(
    const ::std::string& name, DrivingError* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DrivingError>(
    DrivingError_descriptor(), name, value);
}
// ===================================================================

class VehicleBCM : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.NavMsg.VehicleBCM) */ {
 public:
  VehicleBCM();
  virtual ~VehicleBCM();

  VehicleBCM(const VehicleBCM& from);

  inline VehicleBCM& operator=(const VehicleBCM& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VehicleBCM& default_instance();

  static inline const VehicleBCM* internal_default_instance() {
    return reinterpret_cast<const VehicleBCM*>(
               &_VehicleBCM_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(VehicleBCM* other);

  // implements Message ----------------------------------------------

  inline VehicleBCM* New() const PROTOBUF_FINAL { return New(NULL); }

  VehicleBCM* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VehicleBCM& from);
  void MergeFrom(const VehicleBCM& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VehicleBCM* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef VehicleBCM_TurnSignal TurnSignal;
  static const TurnSignal TURN_NONE =
    VehicleBCM_TurnSignal_TURN_NONE;
  static const TurnSignal TURN_LEFT =
    VehicleBCM_TurnSignal_TURN_LEFT;
  static const TurnSignal TURN_RIGHT =
    VehicleBCM_TurnSignal_TURN_RIGHT;
  static inline bool TurnSignal_IsValid(int value) {
    return VehicleBCM_TurnSignal_IsValid(value);
  }
  static const TurnSignal TurnSignal_MIN =
    VehicleBCM_TurnSignal_TurnSignal_MIN;
  static const TurnSignal TurnSignal_MAX =
    VehicleBCM_TurnSignal_TurnSignal_MAX;
  static const int TurnSignal_ARRAYSIZE =
    VehicleBCM_TurnSignal_TurnSignal_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TurnSignal_descriptor() {
    return VehicleBCM_TurnSignal_descriptor();
  }
  static inline const ::std::string& TurnSignal_Name(TurnSignal value) {
    return VehicleBCM_TurnSignal_Name(value);
  }
  static inline bool TurnSignal_Parse(const ::std::string& name,
      TurnSignal* value) {
    return VehicleBCM_TurnSignal_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .COWA.NavMsg.VehicleBCM.TurnSignal turn_signal = 1;
  bool has_turn_signal() const;
  void clear_turn_signal();
  static const int kTurnSignalFieldNumber = 1;
  ::COWA::NavMsg::VehicleBCM_TurnSignal turn_signal() const;
  void set_turn_signal(::COWA::NavMsg::VehicleBCM_TurnSignal value);

  // optional bool high_beam = 2;
  bool has_high_beam() const;
  void clear_high_beam();
  static const int kHighBeamFieldNumber = 2;
  bool high_beam() const;
  void set_high_beam(bool value);

  // optional bool low_beam = 3;
  bool has_low_beam() const;
  void clear_low_beam();
  static const int kLowBeamFieldNumber = 3;
  bool low_beam() const;
  void set_low_beam(bool value);

  // optional bool horn = 4;
  bool has_horn() const;
  void clear_horn();
  static const int kHornFieldNumber = 4;
  bool horn() const;
  void set_horn(bool value);

  // optional bool emergency_light = 5;
  bool has_emergency_light() const;
  void clear_emergency_light();
  static const int kEmergencyLightFieldNumber = 5;
  bool emergency_light() const;
  void set_emergency_light(bool value);

  // optional bool wiper = 6;
  bool has_wiper() const;
  void clear_wiper();
  static const int kWiperFieldNumber = 6;
  bool wiper() const;
  void set_wiper(bool value);

  // optional float sweep = 10;
  bool has_sweep() const;
  void clear_sweep();
  static const int kSweepFieldNumber = 10;
  float sweep() const;
  void set_sweep(float value);

  // optional float vacuum = 11;
  bool has_vacuum() const;
  void clear_vacuum();
  static const int kVacuumFieldNumber = 11;
  float vacuum() const;
  void set_vacuum(float value);

  // optional float spray = 12;
  bool has_spray() const;
  void clear_spray();
  static const int kSprayFieldNumber = 12;
  float spray() const;
  void set_spray(float value);

  // optional float left_sweep_servo = 13;
  bool has_left_sweep_servo() const;
  void clear_left_sweep_servo();
  static const int kLeftSweepServoFieldNumber = 13;
  float left_sweep_servo() const;
  void set_left_sweep_servo(float value);

  // optional float right_sweep_servo = 14;
  bool has_right_sweep_servo() const;
  void clear_right_sweep_servo();
  static const int kRightSweepServoFieldNumber = 14;
  float right_sweep_servo() const;
  void set_right_sweep_servo(float value);

  // @@protoc_insertion_point(class_scope:COWA.NavMsg.VehicleBCM)
 private:
  void set_has_turn_signal();
  void clear_has_turn_signal();
  void set_has_high_beam();
  void clear_has_high_beam();
  void set_has_low_beam();
  void clear_has_low_beam();
  void set_has_horn();
  void clear_has_horn();
  void set_has_emergency_light();
  void clear_has_emergency_light();
  void set_has_wiper();
  void clear_has_wiper();
  void set_has_sweep();
  void clear_has_sweep();
  void set_has_vacuum();
  void clear_has_vacuum();
  void set_has_spray();
  void clear_has_spray();
  void set_has_left_sweep_servo();
  void clear_has_left_sweep_servo();
  void set_has_right_sweep_servo();
  void clear_has_right_sweep_servo();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int turn_signal_;
  bool high_beam_;
  bool low_beam_;
  bool horn_;
  bool emergency_light_;
  bool wiper_;
  float sweep_;
  float vacuum_;
  float spray_;
  float left_sweep_servo_;
  float right_sweep_servo_;
  friend struct protobuf_chassis_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VehicleSoc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.NavMsg.VehicleSoc) */ {
 public:
  VehicleSoc();
  virtual ~VehicleSoc();

  VehicleSoc(const VehicleSoc& from);

  inline VehicleSoc& operator=(const VehicleSoc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VehicleSoc& default_instance();

  static inline const VehicleSoc* internal_default_instance() {
    return reinterpret_cast<const VehicleSoc*>(
               &_VehicleSoc_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(VehicleSoc* other);

  // implements Message ----------------------------------------------

  inline VehicleSoc* New() const PROTOBUF_FINAL { return New(NULL); }

  VehicleSoc* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VehicleSoc& from);
  void MergeFrom(const VehicleSoc& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VehicleSoc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float battery = 1;
  bool has_battery() const;
  void clear_battery();
  static const int kBatteryFieldNumber = 1;
  float battery() const;
  void set_battery(float value);

  // optional float engine_rpm = 2;
  bool has_engine_rpm() const;
  void clear_engine_rpm();
  static const int kEngineRpmFieldNumber = 2;
  float engine_rpm() const;
  void set_engine_rpm(float value);

  // optional float mileage = 3;
  bool has_mileage() const;
  void clear_mileage();
  static const int kMileageFieldNumber = 3;
  float mileage() const;
  void set_mileage(float value);

  // optional float sla = 4;
  bool has_sla() const;
  void clear_sla();
  static const int kSlaFieldNumber = 4;
  float sla() const;
  void set_sla(float value);

  // optional float garbage_capacity = 10;
  bool has_garbage_capacity() const;
  void clear_garbage_capacity();
  static const int kGarbageCapacityFieldNumber = 10;
  float garbage_capacity() const;
  void set_garbage_capacity(float value);

  // optional float water_capacity = 11;
  bool has_water_capacity() const;
  void clear_water_capacity();
  static const int kWaterCapacityFieldNumber = 11;
  float water_capacity() const;
  void set_water_capacity(float value);

  // @@protoc_insertion_point(class_scope:COWA.NavMsg.VehicleSoc)
 private:
  void set_has_battery();
  void clear_has_battery();
  void set_has_engine_rpm();
  void clear_has_engine_rpm();
  void set_has_mileage();
  void clear_has_mileage();
  void set_has_sla();
  void clear_has_sla();
  void set_has_garbage_capacity();
  void clear_has_garbage_capacity();
  void set_has_water_capacity();
  void clear_has_water_capacity();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float battery_;
  float engine_rpm_;
  float mileage_;
  float sla_;
  float garbage_capacity_;
  float water_capacity_;
  friend struct protobuf_chassis_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VehicleDrive : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.NavMsg.VehicleDrive) */ {
 public:
  VehicleDrive();
  virtual ~VehicleDrive();

  VehicleDrive(const VehicleDrive& from);

  inline VehicleDrive& operator=(const VehicleDrive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VehicleDrive& default_instance();

  static inline const VehicleDrive* internal_default_instance() {
    return reinterpret_cast<const VehicleDrive*>(
               &_VehicleDrive_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(VehicleDrive* other);

  // implements Message ----------------------------------------------

  inline VehicleDrive* New() const PROTOBUF_FINAL { return New(NULL); }

  VehicleDrive* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VehicleDrive& from);
  void MergeFrom(const VehicleDrive& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VehicleDrive* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef VehicleDrive_DrivingMode DrivingMode;
  static const DrivingMode MANUAL =
    VehicleDrive_DrivingMode_MANUAL;
  static const DrivingMode AUTO_DRIVE =
    VehicleDrive_DrivingMode_AUTO_DRIVE;
  static const DrivingMode AUTO_STEER_ONLY =
    VehicleDrive_DrivingMode_AUTO_STEER_ONLY;
  static const DrivingMode AUTO_SPEED_ONLY =
    VehicleDrive_DrivingMode_AUTO_SPEED_ONLY;
  static const DrivingMode EMERGENCY_MODE =
    VehicleDrive_DrivingMode_EMERGENCY_MODE;
  static const DrivingMode STANDBY =
    VehicleDrive_DrivingMode_STANDBY;
  static const DrivingMode PARKING =
    VehicleDrive_DrivingMode_PARKING;
  static inline bool DrivingMode_IsValid(int value) {
    return VehicleDrive_DrivingMode_IsValid(value);
  }
  static const DrivingMode DrivingMode_MIN =
    VehicleDrive_DrivingMode_DrivingMode_MIN;
  static const DrivingMode DrivingMode_MAX =
    VehicleDrive_DrivingMode_DrivingMode_MAX;
  static const int DrivingMode_ARRAYSIZE =
    VehicleDrive_DrivingMode_DrivingMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DrivingMode_descriptor() {
    return VehicleDrive_DrivingMode_descriptor();
  }
  static inline const ::std::string& DrivingMode_Name(DrivingMode value) {
    return VehicleDrive_DrivingMode_Name(value);
  }
  static inline bool DrivingMode_Parse(const ::std::string& name,
      DrivingMode* value) {
    return VehicleDrive_DrivingMode_Parse(name, value);
  }

  typedef VehicleDrive_GearPosition GearPosition;
  static const GearPosition GEAR_NEUTRAL =
    VehicleDrive_GearPosition_GEAR_NEUTRAL;
  static const GearPosition GEAR_DRIVE =
    VehicleDrive_GearPosition_GEAR_DRIVE;
  static const GearPosition GEAR_REVERSE =
    VehicleDrive_GearPosition_GEAR_REVERSE;
  static const GearPosition GEAR_PARKING =
    VehicleDrive_GearPosition_GEAR_PARKING;
  static const GearPosition GEAR_NONE =
    VehicleDrive_GearPosition_GEAR_NONE;
  static inline bool GearPosition_IsValid(int value) {
    return VehicleDrive_GearPosition_IsValid(value);
  }
  static const GearPosition GearPosition_MIN =
    VehicleDrive_GearPosition_GearPosition_MIN;
  static const GearPosition GearPosition_MAX =
    VehicleDrive_GearPosition_GearPosition_MAX;
  static const int GearPosition_ARRAYSIZE =
    VehicleDrive_GearPosition_GearPosition_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GearPosition_descriptor() {
    return VehicleDrive_GearPosition_descriptor();
  }
  static inline const ::std::string& GearPosition_Name(GearPosition value) {
    return VehicleDrive_GearPosition_Name(value);
  }
  static inline bool GearPosition_Parse(const ::std::string& name,
      GearPosition* value) {
    return VehicleDrive_GearPosition_Parse(name, value);
  }

  typedef VehicleDrive_SpeedMode SpeedMode;
  static const SpeedMode TORQUE =
    VehicleDrive_SpeedMode_TORQUE;
  static const SpeedMode SPEED =
    VehicleDrive_SpeedMode_SPEED;
  static inline bool SpeedMode_IsValid(int value) {
    return VehicleDrive_SpeedMode_IsValid(value);
  }
  static const SpeedMode SpeedMode_MIN =
    VehicleDrive_SpeedMode_SpeedMode_MIN;
  static const SpeedMode SpeedMode_MAX =
    VehicleDrive_SpeedMode_SpeedMode_MAX;
  static const int SpeedMode_ARRAYSIZE =
    VehicleDrive_SpeedMode_SpeedMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SpeedMode_descriptor() {
    return VehicleDrive_SpeedMode_descriptor();
  }
  static inline const ::std::string& SpeedMode_Name(SpeedMode value) {
    return VehicleDrive_SpeedMode_Name(value);
  }
  static inline bool SpeedMode_Parse(const ::std::string& name,
      SpeedMode* value) {
    return VehicleDrive_SpeedMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .COWA.NavMsg.VehicleDrive.DrivingMode driving_mode = 1;
  bool has_driving_mode() const;
  void clear_driving_mode();
  static const int kDrivingModeFieldNumber = 1;
  ::COWA::NavMsg::VehicleDrive_DrivingMode driving_mode() const;
  void set_driving_mode(::COWA::NavMsg::VehicleDrive_DrivingMode value);

  // optional .COWA.NavMsg.VehicleDrive.GearPosition gear = 2;
  bool has_gear() const;
  void clear_gear();
  static const int kGearFieldNumber = 2;
  ::COWA::NavMsg::VehicleDrive_GearPosition gear() const;
  void set_gear(::COWA::NavMsg::VehicleDrive_GearPosition value);

  // optional .COWA.NavMsg.VehicleDrive.SpeedMode speed_mode = 3;
  bool has_speed_mode() const;
  void clear_speed_mode();
  static const int kSpeedModeFieldNumber = 3;
  ::COWA::NavMsg::VehicleDrive_SpeedMode speed_mode() const;
  void set_speed_mode(::COWA::NavMsg::VehicleDrive_SpeedMode value);

  // optional float speed = 4;
  bool has_speed() const;
  void clear_speed();
  static const int kSpeedFieldNumber = 4;
  float speed() const;
  void set_speed(float value);

  // optional float throttle = 5;
  bool has_throttle() const;
  void clear_throttle();
  static const int kThrottleFieldNumber = 5;
  float throttle() const;
  void set_throttle(float value);

  // optional float steer = 6;
  bool has_steer() const;
  void clear_steer();
  static const int kSteerFieldNumber = 6;
  float steer() const;
  void set_steer(float value);

  // optional float steer_speed = 7;
  bool has_steer_speed() const;
  void clear_steer_speed();
  static const int kSteerSpeedFieldNumber = 7;
  float steer_speed() const;
  void set_steer_speed(float value);

  // @@protoc_insertion_point(class_scope:COWA.NavMsg.VehicleDrive)
 private:
  void set_has_driving_mode();
  void clear_has_driving_mode();
  void set_has_gear();
  void clear_has_gear();
  void set_has_speed_mode();
  void clear_has_speed_mode();
  void set_has_speed();
  void clear_has_speed();
  void set_has_throttle();
  void clear_has_throttle();
  void set_has_steer();
  void clear_has_steer();
  void set_has_steer_speed();
  void clear_has_steer_speed();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int driving_mode_;
  int gear_;
  int speed_mode_;
  float speed_;
  float throttle_;
  float steer_;
  float steer_speed_;
  friend struct protobuf_chassis_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DebugField : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.NavMsg.DebugField) */ {
 public:
  DebugField();
  virtual ~DebugField();

  DebugField(const DebugField& from);

  inline DebugField& operator=(const DebugField& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugField& default_instance();

  static inline const DebugField* internal_default_instance() {
    return reinterpret_cast<const DebugField*>(
               &_DebugField_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(DebugField* other);

  // implements Message ----------------------------------------------

  inline DebugField* New() const PROTOBUF_FINAL { return New(NULL); }

  DebugField* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DebugField& from);
  void MergeFrom(const DebugField& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DebugField* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes field = 1;
  bool has_field() const;
  void clear_field();
  static const int kFieldFieldNumber = 1;
  const ::std::string& field() const;
  void set_field(const ::std::string& value);
  #if LANG_CXX11
  void set_field(::std::string&& value);
  #endif
  void set_field(const char* value);
  void set_field(const void* value, size_t size);
  ::std::string* mutable_field();
  ::std::string* release_field();
  void set_allocated_field(::std::string* field);

  // optional float value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  float value() const;
  void set_value(float value);

  // @@protoc_insertion_point(class_scope:COWA.NavMsg.DebugField)
 private:
  void set_has_field();
  void clear_has_field();
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr field_;
  float value_;
  friend struct protobuf_chassis_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VehicleInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.NavMsg.VehicleInfo) */ {
 public:
  VehicleInfo();
  virtual ~VehicleInfo();

  VehicleInfo(const VehicleInfo& from);

  inline VehicleInfo& operator=(const VehicleInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VehicleInfo& default_instance();

  static inline const VehicleInfo* internal_default_instance() {
    return reinterpret_cast<const VehicleInfo*>(
               &_VehicleInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(VehicleInfo* other);

  // implements Message ----------------------------------------------

  inline VehicleInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  VehicleInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VehicleInfo& from);
  void MergeFrom(const VehicleInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VehicleInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .COWA.NavMsg.DebugField debug = 6;
  int debug_size() const;
  void clear_debug();
  static const int kDebugFieldNumber = 6;
  const ::COWA::NavMsg::DebugField& debug(int index) const;
  ::COWA::NavMsg::DebugField* mutable_debug(int index);
  ::COWA::NavMsg::DebugField* add_debug();
  ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::DebugField >*
      mutable_debug();
  const ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::DebugField >&
      debug() const;

  // repeated float wheel_speed = 10;
  int wheel_speed_size() const;
  void clear_wheel_speed();
  static const int kWheelSpeedFieldNumber = 10;
  float wheel_speed(int index) const;
  void set_wheel_speed(int index, float value);
  void add_wheel_speed(float value);
  const ::google::protobuf::RepeatedField< float >&
      wheel_speed() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_wheel_speed();

  // repeated float wheel_position = 11;
  int wheel_position_size() const;
  void clear_wheel_position();
  static const int kWheelPositionFieldNumber = 11;
  float wheel_position(int index) const;
  void set_wheel_position(int index, float value);
  void add_wheel_position(float value);
  const ::google::protobuf::RepeatedField< float >&
      wheel_position() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_wheel_position();

  // optional .COWA.NavMsg.VehicleDrive drive = 3;
  bool has_drive() const;
  void clear_drive();
  static const int kDriveFieldNumber = 3;
  const ::COWA::NavMsg::VehicleDrive& drive() const;
  ::COWA::NavMsg::VehicleDrive* mutable_drive();
  ::COWA::NavMsg::VehicleDrive* release_drive();
  void set_allocated_drive(::COWA::NavMsg::VehicleDrive* drive);

  // optional .COWA.NavMsg.VehicleBCM bcm = 4;
  bool has_bcm() const;
  void clear_bcm();
  static const int kBcmFieldNumber = 4;
  const ::COWA::NavMsg::VehicleBCM& bcm() const;
  ::COWA::NavMsg::VehicleBCM* mutable_bcm();
  ::COWA::NavMsg::VehicleBCM* release_bcm();
  void set_allocated_bcm(::COWA::NavMsg::VehicleBCM* bcm);

  // optional .COWA.NavMsg.VehicleSoc soc = 5;
  bool has_soc() const;
  void clear_soc();
  static const int kSocFieldNumber = 5;
  const ::COWA::NavMsg::VehicleSoc& soc() const;
  ::COWA::NavMsg::VehicleSoc* mutable_soc();
  ::COWA::NavMsg::VehicleSoc* release_soc();
  void set_allocated_soc(::COWA::NavMsg::VehicleSoc* soc);

  // optional uint64 timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // optional uint32 sequence = 2;
  bool has_sequence() const;
  void clear_sequence();
  static const int kSequenceFieldNumber = 2;
  ::google::protobuf::uint32 sequence() const;
  void set_sequence(::google::protobuf::uint32 value);

  // optional .COWA.NavMsg.DrivingError error = 12;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 12;
  ::COWA::NavMsg::DrivingError error() const;
  void set_error(::COWA::NavMsg::DrivingError value);

  // optional uint64 timestamp_speed = 13;
  bool has_timestamp_speed() const;
  void clear_timestamp_speed();
  static const int kTimestampSpeedFieldNumber = 13;
  ::google::protobuf::uint64 timestamp_speed() const;
  void set_timestamp_speed(::google::protobuf::uint64 value);

  // optional int32 latency_ms = 15;
  bool has_latency_ms() const;
  void clear_latency_ms();
  static const int kLatencyMsFieldNumber = 15;
  ::google::protobuf::int32 latency_ms() const;
  void set_latency_ms(::google::protobuf::int32 value);

  // optional uint64 timestamp_steer = 14;
  bool has_timestamp_steer() const;
  void clear_timestamp_steer();
  static const int kTimestampSteerFieldNumber = 14;
  ::google::protobuf::uint64 timestamp_steer() const;
  void set_timestamp_steer(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:COWA.NavMsg.VehicleInfo)
 private:
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_sequence();
  void clear_has_sequence();
  void set_has_drive();
  void clear_has_drive();
  void set_has_bcm();
  void clear_has_bcm();
  void set_has_soc();
  void clear_has_soc();
  void set_has_timestamp_speed();
  void clear_has_timestamp_speed();
  void set_has_timestamp_steer();
  void clear_has_timestamp_steer();
  void set_has_error();
  void clear_has_error();
  void set_has_latency_ms();
  void clear_has_latency_ms();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::DebugField > debug_;
  ::google::protobuf::RepeatedField< float > wheel_speed_;
  ::google::protobuf::RepeatedField< float > wheel_position_;
  ::COWA::NavMsg::VehicleDrive* drive_;
  ::COWA::NavMsg::VehicleBCM* bcm_;
  ::COWA::NavMsg::VehicleSoc* soc_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::uint32 sequence_;
  int error_;
  ::google::protobuf::uint64 timestamp_speed_;
  ::google::protobuf::int32 latency_ms_;
  ::google::protobuf::uint64 timestamp_steer_;
  friend struct protobuf_chassis_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VehicleCommond : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.NavMsg.VehicleCommond) */ {
 public:
  VehicleCommond();
  virtual ~VehicleCommond();

  VehicleCommond(const VehicleCommond& from);

  inline VehicleCommond& operator=(const VehicleCommond& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VehicleCommond& default_instance();

  static inline const VehicleCommond* internal_default_instance() {
    return reinterpret_cast<const VehicleCommond*>(
               &_VehicleCommond_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(VehicleCommond* other);

  // implements Message ----------------------------------------------

  inline VehicleCommond* New() const PROTOBUF_FINAL { return New(NULL); }

  VehicleCommond* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VehicleCommond& from);
  void MergeFrom(const VehicleCommond& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VehicleCommond* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .COWA.NavMsg.VehicleDrive drive = 3;
  bool has_drive() const;
  void clear_drive();
  static const int kDriveFieldNumber = 3;
  const ::COWA::NavMsg::VehicleDrive& drive() const;
  ::COWA::NavMsg::VehicleDrive* mutable_drive();
  ::COWA::NavMsg::VehicleDrive* release_drive();
  void set_allocated_drive(::COWA::NavMsg::VehicleDrive* drive);

  // optional .COWA.NavMsg.VehicleBCM bcm = 4;
  bool has_bcm() const;
  void clear_bcm();
  static const int kBcmFieldNumber = 4;
  const ::COWA::NavMsg::VehicleBCM& bcm() const;
  ::COWA::NavMsg::VehicleBCM* mutable_bcm();
  ::COWA::NavMsg::VehicleBCM* release_bcm();
  void set_allocated_bcm(::COWA::NavMsg::VehicleBCM* bcm);

  // optional uint64 timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // optional uint32 sequence = 2;
  bool has_sequence() const;
  void clear_sequence();
  static const int kSequenceFieldNumber = 2;
  ::google::protobuf::uint32 sequence() const;
  void set_sequence(::google::protobuf::uint32 value);

  // optional int32 latency_ms = 5;
  bool has_latency_ms() const;
  void clear_latency_ms();
  static const int kLatencyMsFieldNumber = 5;
  ::google::protobuf::int32 latency_ms() const;
  void set_latency_ms(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:COWA.NavMsg.VehicleCommond)
 private:
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_sequence();
  void clear_has_sequence();
  void set_has_drive();
  void clear_has_drive();
  void set_has_bcm();
  void clear_has_bcm();
  void set_has_latency_ms();
  void clear_has_latency_ms();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::COWA::NavMsg::VehicleDrive* drive_;
  ::COWA::NavMsg::VehicleBCM* bcm_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::uint32 sequence_;
  ::google::protobuf::int32 latency_ms_;
  friend struct protobuf_chassis_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// VehicleBCM

// optional .COWA.NavMsg.VehicleBCM.TurnSignal turn_signal = 1;
inline bool VehicleBCM::has_turn_signal() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VehicleBCM::set_has_turn_signal() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VehicleBCM::clear_has_turn_signal() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VehicleBCM::clear_turn_signal() {
  turn_signal_ = 0;
  clear_has_turn_signal();
}
inline ::COWA::NavMsg::VehicleBCM_TurnSignal VehicleBCM::turn_signal() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleBCM.turn_signal)
  return static_cast< ::COWA::NavMsg::VehicleBCM_TurnSignal >(turn_signal_);
}
inline void VehicleBCM::set_turn_signal(::COWA::NavMsg::VehicleBCM_TurnSignal value) {
  assert(::COWA::NavMsg::VehicleBCM_TurnSignal_IsValid(value));
  set_has_turn_signal();
  turn_signal_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.VehicleBCM.turn_signal)
}

// optional bool high_beam = 2;
inline bool VehicleBCM::has_high_beam() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VehicleBCM::set_has_high_beam() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VehicleBCM::clear_has_high_beam() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VehicleBCM::clear_high_beam() {
  high_beam_ = false;
  clear_has_high_beam();
}
inline bool VehicleBCM::high_beam() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleBCM.high_beam)
  return high_beam_;
}
inline void VehicleBCM::set_high_beam(bool value) {
  set_has_high_beam();
  high_beam_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.VehicleBCM.high_beam)
}

// optional bool low_beam = 3;
inline bool VehicleBCM::has_low_beam() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VehicleBCM::set_has_low_beam() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VehicleBCM::clear_has_low_beam() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VehicleBCM::clear_low_beam() {
  low_beam_ = false;
  clear_has_low_beam();
}
inline bool VehicleBCM::low_beam() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleBCM.low_beam)
  return low_beam_;
}
inline void VehicleBCM::set_low_beam(bool value) {
  set_has_low_beam();
  low_beam_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.VehicleBCM.low_beam)
}

// optional bool horn = 4;
inline bool VehicleBCM::has_horn() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VehicleBCM::set_has_horn() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VehicleBCM::clear_has_horn() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VehicleBCM::clear_horn() {
  horn_ = false;
  clear_has_horn();
}
inline bool VehicleBCM::horn() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleBCM.horn)
  return horn_;
}
inline void VehicleBCM::set_horn(bool value) {
  set_has_horn();
  horn_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.VehicleBCM.horn)
}

// optional bool emergency_light = 5;
inline bool VehicleBCM::has_emergency_light() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VehicleBCM::set_has_emergency_light() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VehicleBCM::clear_has_emergency_light() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VehicleBCM::clear_emergency_light() {
  emergency_light_ = false;
  clear_has_emergency_light();
}
inline bool VehicleBCM::emergency_light() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleBCM.emergency_light)
  return emergency_light_;
}
inline void VehicleBCM::set_emergency_light(bool value) {
  set_has_emergency_light();
  emergency_light_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.VehicleBCM.emergency_light)
}

// optional bool wiper = 6;
inline bool VehicleBCM::has_wiper() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VehicleBCM::set_has_wiper() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VehicleBCM::clear_has_wiper() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VehicleBCM::clear_wiper() {
  wiper_ = false;
  clear_has_wiper();
}
inline bool VehicleBCM::wiper() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleBCM.wiper)
  return wiper_;
}
inline void VehicleBCM::set_wiper(bool value) {
  set_has_wiper();
  wiper_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.VehicleBCM.wiper)
}

// optional float sweep = 10;
inline bool VehicleBCM::has_sweep() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VehicleBCM::set_has_sweep() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VehicleBCM::clear_has_sweep() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VehicleBCM::clear_sweep() {
  sweep_ = 0;
  clear_has_sweep();
}
inline float VehicleBCM::sweep() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleBCM.sweep)
  return sweep_;
}
inline void VehicleBCM::set_sweep(float value) {
  set_has_sweep();
  sweep_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.VehicleBCM.sweep)
}

// optional float vacuum = 11;
inline bool VehicleBCM::has_vacuum() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void VehicleBCM::set_has_vacuum() {
  _has_bits_[0] |= 0x00000080u;
}
inline void VehicleBCM::clear_has_vacuum() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void VehicleBCM::clear_vacuum() {
  vacuum_ = 0;
  clear_has_vacuum();
}
inline float VehicleBCM::vacuum() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleBCM.vacuum)
  return vacuum_;
}
inline void VehicleBCM::set_vacuum(float value) {
  set_has_vacuum();
  vacuum_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.VehicleBCM.vacuum)
}

// optional float spray = 12;
inline bool VehicleBCM::has_spray() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void VehicleBCM::set_has_spray() {
  _has_bits_[0] |= 0x00000100u;
}
inline void VehicleBCM::clear_has_spray() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void VehicleBCM::clear_spray() {
  spray_ = 0;
  clear_has_spray();
}
inline float VehicleBCM::spray() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleBCM.spray)
  return spray_;
}
inline void VehicleBCM::set_spray(float value) {
  set_has_spray();
  spray_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.VehicleBCM.spray)
}

// optional float left_sweep_servo = 13;
inline bool VehicleBCM::has_left_sweep_servo() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void VehicleBCM::set_has_left_sweep_servo() {
  _has_bits_[0] |= 0x00000200u;
}
inline void VehicleBCM::clear_has_left_sweep_servo() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void VehicleBCM::clear_left_sweep_servo() {
  left_sweep_servo_ = 0;
  clear_has_left_sweep_servo();
}
inline float VehicleBCM::left_sweep_servo() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleBCM.left_sweep_servo)
  return left_sweep_servo_;
}
inline void VehicleBCM::set_left_sweep_servo(float value) {
  set_has_left_sweep_servo();
  left_sweep_servo_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.VehicleBCM.left_sweep_servo)
}

// optional float right_sweep_servo = 14;
inline bool VehicleBCM::has_right_sweep_servo() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void VehicleBCM::set_has_right_sweep_servo() {
  _has_bits_[0] |= 0x00000400u;
}
inline void VehicleBCM::clear_has_right_sweep_servo() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void VehicleBCM::clear_right_sweep_servo() {
  right_sweep_servo_ = 0;
  clear_has_right_sweep_servo();
}
inline float VehicleBCM::right_sweep_servo() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleBCM.right_sweep_servo)
  return right_sweep_servo_;
}
inline void VehicleBCM::set_right_sweep_servo(float value) {
  set_has_right_sweep_servo();
  right_sweep_servo_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.VehicleBCM.right_sweep_servo)
}

// -------------------------------------------------------------------

// VehicleSoc

// optional float battery = 1;
inline bool VehicleSoc::has_battery() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VehicleSoc::set_has_battery() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VehicleSoc::clear_has_battery() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VehicleSoc::clear_battery() {
  battery_ = 0;
  clear_has_battery();
}
inline float VehicleSoc::battery() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleSoc.battery)
  return battery_;
}
inline void VehicleSoc::set_battery(float value) {
  set_has_battery();
  battery_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.VehicleSoc.battery)
}

// optional float engine_rpm = 2;
inline bool VehicleSoc::has_engine_rpm() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VehicleSoc::set_has_engine_rpm() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VehicleSoc::clear_has_engine_rpm() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VehicleSoc::clear_engine_rpm() {
  engine_rpm_ = 0;
  clear_has_engine_rpm();
}
inline float VehicleSoc::engine_rpm() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleSoc.engine_rpm)
  return engine_rpm_;
}
inline void VehicleSoc::set_engine_rpm(float value) {
  set_has_engine_rpm();
  engine_rpm_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.VehicleSoc.engine_rpm)
}

// optional float mileage = 3;
inline bool VehicleSoc::has_mileage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VehicleSoc::set_has_mileage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VehicleSoc::clear_has_mileage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VehicleSoc::clear_mileage() {
  mileage_ = 0;
  clear_has_mileage();
}
inline float VehicleSoc::mileage() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleSoc.mileage)
  return mileage_;
}
inline void VehicleSoc::set_mileage(float value) {
  set_has_mileage();
  mileage_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.VehicleSoc.mileage)
}

// optional float sla = 4;
inline bool VehicleSoc::has_sla() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VehicleSoc::set_has_sla() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VehicleSoc::clear_has_sla() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VehicleSoc::clear_sla() {
  sla_ = 0;
  clear_has_sla();
}
inline float VehicleSoc::sla() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleSoc.sla)
  return sla_;
}
inline void VehicleSoc::set_sla(float value) {
  set_has_sla();
  sla_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.VehicleSoc.sla)
}

// optional float garbage_capacity = 10;
inline bool VehicleSoc::has_garbage_capacity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VehicleSoc::set_has_garbage_capacity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VehicleSoc::clear_has_garbage_capacity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VehicleSoc::clear_garbage_capacity() {
  garbage_capacity_ = 0;
  clear_has_garbage_capacity();
}
inline float VehicleSoc::garbage_capacity() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleSoc.garbage_capacity)
  return garbage_capacity_;
}
inline void VehicleSoc::set_garbage_capacity(float value) {
  set_has_garbage_capacity();
  garbage_capacity_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.VehicleSoc.garbage_capacity)
}

// optional float water_capacity = 11;
inline bool VehicleSoc::has_water_capacity() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VehicleSoc::set_has_water_capacity() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VehicleSoc::clear_has_water_capacity() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VehicleSoc::clear_water_capacity() {
  water_capacity_ = 0;
  clear_has_water_capacity();
}
inline float VehicleSoc::water_capacity() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleSoc.water_capacity)
  return water_capacity_;
}
inline void VehicleSoc::set_water_capacity(float value) {
  set_has_water_capacity();
  water_capacity_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.VehicleSoc.water_capacity)
}

// -------------------------------------------------------------------

// VehicleDrive

// optional .COWA.NavMsg.VehicleDrive.DrivingMode driving_mode = 1;
inline bool VehicleDrive::has_driving_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VehicleDrive::set_has_driving_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VehicleDrive::clear_has_driving_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VehicleDrive::clear_driving_mode() {
  driving_mode_ = 0;
  clear_has_driving_mode();
}
inline ::COWA::NavMsg::VehicleDrive_DrivingMode VehicleDrive::driving_mode() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleDrive.driving_mode)
  return static_cast< ::COWA::NavMsg::VehicleDrive_DrivingMode >(driving_mode_);
}
inline void VehicleDrive::set_driving_mode(::COWA::NavMsg::VehicleDrive_DrivingMode value) {
  assert(::COWA::NavMsg::VehicleDrive_DrivingMode_IsValid(value));
  set_has_driving_mode();
  driving_mode_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.VehicleDrive.driving_mode)
}

// optional .COWA.NavMsg.VehicleDrive.GearPosition gear = 2;
inline bool VehicleDrive::has_gear() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VehicleDrive::set_has_gear() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VehicleDrive::clear_has_gear() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VehicleDrive::clear_gear() {
  gear_ = 0;
  clear_has_gear();
}
inline ::COWA::NavMsg::VehicleDrive_GearPosition VehicleDrive::gear() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleDrive.gear)
  return static_cast< ::COWA::NavMsg::VehicleDrive_GearPosition >(gear_);
}
inline void VehicleDrive::set_gear(::COWA::NavMsg::VehicleDrive_GearPosition value) {
  assert(::COWA::NavMsg::VehicleDrive_GearPosition_IsValid(value));
  set_has_gear();
  gear_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.VehicleDrive.gear)
}

// optional .COWA.NavMsg.VehicleDrive.SpeedMode speed_mode = 3;
inline bool VehicleDrive::has_speed_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VehicleDrive::set_has_speed_mode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VehicleDrive::clear_has_speed_mode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VehicleDrive::clear_speed_mode() {
  speed_mode_ = 0;
  clear_has_speed_mode();
}
inline ::COWA::NavMsg::VehicleDrive_SpeedMode VehicleDrive::speed_mode() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleDrive.speed_mode)
  return static_cast< ::COWA::NavMsg::VehicleDrive_SpeedMode >(speed_mode_);
}
inline void VehicleDrive::set_speed_mode(::COWA::NavMsg::VehicleDrive_SpeedMode value) {
  assert(::COWA::NavMsg::VehicleDrive_SpeedMode_IsValid(value));
  set_has_speed_mode();
  speed_mode_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.VehicleDrive.speed_mode)
}

// optional float speed = 4;
inline bool VehicleDrive::has_speed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VehicleDrive::set_has_speed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VehicleDrive::clear_has_speed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VehicleDrive::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline float VehicleDrive::speed() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleDrive.speed)
  return speed_;
}
inline void VehicleDrive::set_speed(float value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.VehicleDrive.speed)
}

// optional float throttle = 5;
inline bool VehicleDrive::has_throttle() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VehicleDrive::set_has_throttle() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VehicleDrive::clear_has_throttle() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VehicleDrive::clear_throttle() {
  throttle_ = 0;
  clear_has_throttle();
}
inline float VehicleDrive::throttle() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleDrive.throttle)
  return throttle_;
}
inline void VehicleDrive::set_throttle(float value) {
  set_has_throttle();
  throttle_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.VehicleDrive.throttle)
}

// optional float steer = 6;
inline bool VehicleDrive::has_steer() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VehicleDrive::set_has_steer() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VehicleDrive::clear_has_steer() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VehicleDrive::clear_steer() {
  steer_ = 0;
  clear_has_steer();
}
inline float VehicleDrive::steer() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleDrive.steer)
  return steer_;
}
inline void VehicleDrive::set_steer(float value) {
  set_has_steer();
  steer_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.VehicleDrive.steer)
}

// optional float steer_speed = 7;
inline bool VehicleDrive::has_steer_speed() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VehicleDrive::set_has_steer_speed() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VehicleDrive::clear_has_steer_speed() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VehicleDrive::clear_steer_speed() {
  steer_speed_ = 0;
  clear_has_steer_speed();
}
inline float VehicleDrive::steer_speed() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleDrive.steer_speed)
  return steer_speed_;
}
inline void VehicleDrive::set_steer_speed(float value) {
  set_has_steer_speed();
  steer_speed_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.VehicleDrive.steer_speed)
}

// -------------------------------------------------------------------

// DebugField

// optional bytes field = 1;
inline bool DebugField::has_field() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugField::set_has_field() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugField::clear_has_field() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DebugField::clear_field() {
  field_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_field();
}
inline const ::std::string& DebugField::field() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.DebugField.field)
  return field_.GetNoArena();
}
inline void DebugField::set_field(const ::std::string& value) {
  set_has_field();
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:COWA.NavMsg.DebugField.field)
}
#if LANG_CXX11
inline void DebugField::set_field(::std::string&& value) {
  set_has_field();
  field_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:COWA.NavMsg.DebugField.field)
}
#endif
inline void DebugField::set_field(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_field();
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:COWA.NavMsg.DebugField.field)
}
inline void DebugField::set_field(const void* value, size_t size) {
  set_has_field();
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:COWA.NavMsg.DebugField.field)
}
inline ::std::string* DebugField::mutable_field() {
  set_has_field();
  // @@protoc_insertion_point(field_mutable:COWA.NavMsg.DebugField.field)
  return field_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugField::release_field() {
  // @@protoc_insertion_point(field_release:COWA.NavMsg.DebugField.field)
  clear_has_field();
  return field_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugField::set_allocated_field(::std::string* field) {
  if (field != NULL) {
    set_has_field();
  } else {
    clear_has_field();
  }
  field_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), field);
  // @@protoc_insertion_point(field_set_allocated:COWA.NavMsg.DebugField.field)
}

// optional float value = 2;
inline bool DebugField::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DebugField::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DebugField::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DebugField::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline float DebugField::value() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.DebugField.value)
  return value_;
}
inline void DebugField::set_value(float value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.DebugField.value)
}

// -------------------------------------------------------------------

// VehicleInfo

// optional uint64 timestamp = 1;
inline bool VehicleInfo::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VehicleInfo::set_has_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VehicleInfo::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VehicleInfo::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 VehicleInfo::timestamp() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleInfo.timestamp)
  return timestamp_;
}
inline void VehicleInfo::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.VehicleInfo.timestamp)
}

// optional uint32 sequence = 2;
inline bool VehicleInfo::has_sequence() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VehicleInfo::set_has_sequence() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VehicleInfo::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VehicleInfo::clear_sequence() {
  sequence_ = 0u;
  clear_has_sequence();
}
inline ::google::protobuf::uint32 VehicleInfo::sequence() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleInfo.sequence)
  return sequence_;
}
inline void VehicleInfo::set_sequence(::google::protobuf::uint32 value) {
  set_has_sequence();
  sequence_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.VehicleInfo.sequence)
}

// optional .COWA.NavMsg.VehicleDrive drive = 3;
inline bool VehicleInfo::has_drive() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VehicleInfo::set_has_drive() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VehicleInfo::clear_has_drive() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VehicleInfo::clear_drive() {
  if (drive_ != NULL) drive_->::COWA::NavMsg::VehicleDrive::Clear();
  clear_has_drive();
}
inline const ::COWA::NavMsg::VehicleDrive& VehicleInfo::drive() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleInfo.drive)
  return drive_ != NULL ? *drive_
                         : *::COWA::NavMsg::VehicleDrive::internal_default_instance();
}
inline ::COWA::NavMsg::VehicleDrive* VehicleInfo::mutable_drive() {
  set_has_drive();
  if (drive_ == NULL) {
    drive_ = new ::COWA::NavMsg::VehicleDrive;
  }
  // @@protoc_insertion_point(field_mutable:COWA.NavMsg.VehicleInfo.drive)
  return drive_;
}
inline ::COWA::NavMsg::VehicleDrive* VehicleInfo::release_drive() {
  // @@protoc_insertion_point(field_release:COWA.NavMsg.VehicleInfo.drive)
  clear_has_drive();
  ::COWA::NavMsg::VehicleDrive* temp = drive_;
  drive_ = NULL;
  return temp;
}
inline void VehicleInfo::set_allocated_drive(::COWA::NavMsg::VehicleDrive* drive) {
  delete drive_;
  drive_ = drive;
  if (drive) {
    set_has_drive();
  } else {
    clear_has_drive();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.NavMsg.VehicleInfo.drive)
}

// optional .COWA.NavMsg.VehicleBCM bcm = 4;
inline bool VehicleInfo::has_bcm() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VehicleInfo::set_has_bcm() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VehicleInfo::clear_has_bcm() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VehicleInfo::clear_bcm() {
  if (bcm_ != NULL) bcm_->::COWA::NavMsg::VehicleBCM::Clear();
  clear_has_bcm();
}
inline const ::COWA::NavMsg::VehicleBCM& VehicleInfo::bcm() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleInfo.bcm)
  return bcm_ != NULL ? *bcm_
                         : *::COWA::NavMsg::VehicleBCM::internal_default_instance();
}
inline ::COWA::NavMsg::VehicleBCM* VehicleInfo::mutable_bcm() {
  set_has_bcm();
  if (bcm_ == NULL) {
    bcm_ = new ::COWA::NavMsg::VehicleBCM;
  }
  // @@protoc_insertion_point(field_mutable:COWA.NavMsg.VehicleInfo.bcm)
  return bcm_;
}
inline ::COWA::NavMsg::VehicleBCM* VehicleInfo::release_bcm() {
  // @@protoc_insertion_point(field_release:COWA.NavMsg.VehicleInfo.bcm)
  clear_has_bcm();
  ::COWA::NavMsg::VehicleBCM* temp = bcm_;
  bcm_ = NULL;
  return temp;
}
inline void VehicleInfo::set_allocated_bcm(::COWA::NavMsg::VehicleBCM* bcm) {
  delete bcm_;
  bcm_ = bcm;
  if (bcm) {
    set_has_bcm();
  } else {
    clear_has_bcm();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.NavMsg.VehicleInfo.bcm)
}

// optional .COWA.NavMsg.VehicleSoc soc = 5;
inline bool VehicleInfo::has_soc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VehicleInfo::set_has_soc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VehicleInfo::clear_has_soc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VehicleInfo::clear_soc() {
  if (soc_ != NULL) soc_->::COWA::NavMsg::VehicleSoc::Clear();
  clear_has_soc();
}
inline const ::COWA::NavMsg::VehicleSoc& VehicleInfo::soc() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleInfo.soc)
  return soc_ != NULL ? *soc_
                         : *::COWA::NavMsg::VehicleSoc::internal_default_instance();
}
inline ::COWA::NavMsg::VehicleSoc* VehicleInfo::mutable_soc() {
  set_has_soc();
  if (soc_ == NULL) {
    soc_ = new ::COWA::NavMsg::VehicleSoc;
  }
  // @@protoc_insertion_point(field_mutable:COWA.NavMsg.VehicleInfo.soc)
  return soc_;
}
inline ::COWA::NavMsg::VehicleSoc* VehicleInfo::release_soc() {
  // @@protoc_insertion_point(field_release:COWA.NavMsg.VehicleInfo.soc)
  clear_has_soc();
  ::COWA::NavMsg::VehicleSoc* temp = soc_;
  soc_ = NULL;
  return temp;
}
inline void VehicleInfo::set_allocated_soc(::COWA::NavMsg::VehicleSoc* soc) {
  delete soc_;
  soc_ = soc;
  if (soc) {
    set_has_soc();
  } else {
    clear_has_soc();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.NavMsg.VehicleInfo.soc)
}

// repeated .COWA.NavMsg.DebugField debug = 6;
inline int VehicleInfo::debug_size() const {
  return debug_.size();
}
inline void VehicleInfo::clear_debug() {
  debug_.Clear();
}
inline const ::COWA::NavMsg::DebugField& VehicleInfo::debug(int index) const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleInfo.debug)
  return debug_.Get(index);
}
inline ::COWA::NavMsg::DebugField* VehicleInfo::mutable_debug(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.NavMsg.VehicleInfo.debug)
  return debug_.Mutable(index);
}
inline ::COWA::NavMsg::DebugField* VehicleInfo::add_debug() {
  // @@protoc_insertion_point(field_add:COWA.NavMsg.VehicleInfo.debug)
  return debug_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::DebugField >*
VehicleInfo::mutable_debug() {
  // @@protoc_insertion_point(field_mutable_list:COWA.NavMsg.VehicleInfo.debug)
  return &debug_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::NavMsg::DebugField >&
VehicleInfo::debug() const {
  // @@protoc_insertion_point(field_list:COWA.NavMsg.VehicleInfo.debug)
  return debug_;
}

// repeated float wheel_speed = 10;
inline int VehicleInfo::wheel_speed_size() const {
  return wheel_speed_.size();
}
inline void VehicleInfo::clear_wheel_speed() {
  wheel_speed_.Clear();
}
inline float VehicleInfo::wheel_speed(int index) const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleInfo.wheel_speed)
  return wheel_speed_.Get(index);
}
inline void VehicleInfo::set_wheel_speed(int index, float value) {
  wheel_speed_.Set(index, value);
  // @@protoc_insertion_point(field_set:COWA.NavMsg.VehicleInfo.wheel_speed)
}
inline void VehicleInfo::add_wheel_speed(float value) {
  wheel_speed_.Add(value);
  // @@protoc_insertion_point(field_add:COWA.NavMsg.VehicleInfo.wheel_speed)
}
inline const ::google::protobuf::RepeatedField< float >&
VehicleInfo::wheel_speed() const {
  // @@protoc_insertion_point(field_list:COWA.NavMsg.VehicleInfo.wheel_speed)
  return wheel_speed_;
}
inline ::google::protobuf::RepeatedField< float >*
VehicleInfo::mutable_wheel_speed() {
  // @@protoc_insertion_point(field_mutable_list:COWA.NavMsg.VehicleInfo.wheel_speed)
  return &wheel_speed_;
}

// repeated float wheel_position = 11;
inline int VehicleInfo::wheel_position_size() const {
  return wheel_position_.size();
}
inline void VehicleInfo::clear_wheel_position() {
  wheel_position_.Clear();
}
inline float VehicleInfo::wheel_position(int index) const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleInfo.wheel_position)
  return wheel_position_.Get(index);
}
inline void VehicleInfo::set_wheel_position(int index, float value) {
  wheel_position_.Set(index, value);
  // @@protoc_insertion_point(field_set:COWA.NavMsg.VehicleInfo.wheel_position)
}
inline void VehicleInfo::add_wheel_position(float value) {
  wheel_position_.Add(value);
  // @@protoc_insertion_point(field_add:COWA.NavMsg.VehicleInfo.wheel_position)
}
inline const ::google::protobuf::RepeatedField< float >&
VehicleInfo::wheel_position() const {
  // @@protoc_insertion_point(field_list:COWA.NavMsg.VehicleInfo.wheel_position)
  return wheel_position_;
}
inline ::google::protobuf::RepeatedField< float >*
VehicleInfo::mutable_wheel_position() {
  // @@protoc_insertion_point(field_mutable_list:COWA.NavMsg.VehicleInfo.wheel_position)
  return &wheel_position_;
}

// optional uint64 timestamp_speed = 13;
inline bool VehicleInfo::has_timestamp_speed() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VehicleInfo::set_has_timestamp_speed() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VehicleInfo::clear_has_timestamp_speed() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VehicleInfo::clear_timestamp_speed() {
  timestamp_speed_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp_speed();
}
inline ::google::protobuf::uint64 VehicleInfo::timestamp_speed() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleInfo.timestamp_speed)
  return timestamp_speed_;
}
inline void VehicleInfo::set_timestamp_speed(::google::protobuf::uint64 value) {
  set_has_timestamp_speed();
  timestamp_speed_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.VehicleInfo.timestamp_speed)
}

// optional uint64 timestamp_steer = 14;
inline bool VehicleInfo::has_timestamp_steer() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void VehicleInfo::set_has_timestamp_steer() {
  _has_bits_[0] |= 0x00000100u;
}
inline void VehicleInfo::clear_has_timestamp_steer() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void VehicleInfo::clear_timestamp_steer() {
  timestamp_steer_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp_steer();
}
inline ::google::protobuf::uint64 VehicleInfo::timestamp_steer() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleInfo.timestamp_steer)
  return timestamp_steer_;
}
inline void VehicleInfo::set_timestamp_steer(::google::protobuf::uint64 value) {
  set_has_timestamp_steer();
  timestamp_steer_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.VehicleInfo.timestamp_steer)
}

// optional .COWA.NavMsg.DrivingError error = 12;
inline bool VehicleInfo::has_error() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VehicleInfo::set_has_error() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VehicleInfo::clear_has_error() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VehicleInfo::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::COWA::NavMsg::DrivingError VehicleInfo::error() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleInfo.error)
  return static_cast< ::COWA::NavMsg::DrivingError >(error_);
}
inline void VehicleInfo::set_error(::COWA::NavMsg::DrivingError value) {
  assert(::COWA::NavMsg::DrivingError_IsValid(value));
  set_has_error();
  error_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.VehicleInfo.error)
}

// optional int32 latency_ms = 15;
inline bool VehicleInfo::has_latency_ms() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void VehicleInfo::set_has_latency_ms() {
  _has_bits_[0] |= 0x00000080u;
}
inline void VehicleInfo::clear_has_latency_ms() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void VehicleInfo::clear_latency_ms() {
  latency_ms_ = 0;
  clear_has_latency_ms();
}
inline ::google::protobuf::int32 VehicleInfo::latency_ms() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleInfo.latency_ms)
  return latency_ms_;
}
inline void VehicleInfo::set_latency_ms(::google::protobuf::int32 value) {
  set_has_latency_ms();
  latency_ms_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.VehicleInfo.latency_ms)
}

// -------------------------------------------------------------------

// VehicleCommond

// optional uint64 timestamp = 1;
inline bool VehicleCommond::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VehicleCommond::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VehicleCommond::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VehicleCommond::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 VehicleCommond::timestamp() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleCommond.timestamp)
  return timestamp_;
}
inline void VehicleCommond::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.VehicleCommond.timestamp)
}

// optional uint32 sequence = 2;
inline bool VehicleCommond::has_sequence() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VehicleCommond::set_has_sequence() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VehicleCommond::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VehicleCommond::clear_sequence() {
  sequence_ = 0u;
  clear_has_sequence();
}
inline ::google::protobuf::uint32 VehicleCommond::sequence() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleCommond.sequence)
  return sequence_;
}
inline void VehicleCommond::set_sequence(::google::protobuf::uint32 value) {
  set_has_sequence();
  sequence_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.VehicleCommond.sequence)
}

// optional .COWA.NavMsg.VehicleDrive drive = 3;
inline bool VehicleCommond::has_drive() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VehicleCommond::set_has_drive() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VehicleCommond::clear_has_drive() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VehicleCommond::clear_drive() {
  if (drive_ != NULL) drive_->::COWA::NavMsg::VehicleDrive::Clear();
  clear_has_drive();
}
inline const ::COWA::NavMsg::VehicleDrive& VehicleCommond::drive() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleCommond.drive)
  return drive_ != NULL ? *drive_
                         : *::COWA::NavMsg::VehicleDrive::internal_default_instance();
}
inline ::COWA::NavMsg::VehicleDrive* VehicleCommond::mutable_drive() {
  set_has_drive();
  if (drive_ == NULL) {
    drive_ = new ::COWA::NavMsg::VehicleDrive;
  }
  // @@protoc_insertion_point(field_mutable:COWA.NavMsg.VehicleCommond.drive)
  return drive_;
}
inline ::COWA::NavMsg::VehicleDrive* VehicleCommond::release_drive() {
  // @@protoc_insertion_point(field_release:COWA.NavMsg.VehicleCommond.drive)
  clear_has_drive();
  ::COWA::NavMsg::VehicleDrive* temp = drive_;
  drive_ = NULL;
  return temp;
}
inline void VehicleCommond::set_allocated_drive(::COWA::NavMsg::VehicleDrive* drive) {
  delete drive_;
  drive_ = drive;
  if (drive) {
    set_has_drive();
  } else {
    clear_has_drive();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.NavMsg.VehicleCommond.drive)
}

// optional .COWA.NavMsg.VehicleBCM bcm = 4;
inline bool VehicleCommond::has_bcm() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VehicleCommond::set_has_bcm() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VehicleCommond::clear_has_bcm() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VehicleCommond::clear_bcm() {
  if (bcm_ != NULL) bcm_->::COWA::NavMsg::VehicleBCM::Clear();
  clear_has_bcm();
}
inline const ::COWA::NavMsg::VehicleBCM& VehicleCommond::bcm() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleCommond.bcm)
  return bcm_ != NULL ? *bcm_
                         : *::COWA::NavMsg::VehicleBCM::internal_default_instance();
}
inline ::COWA::NavMsg::VehicleBCM* VehicleCommond::mutable_bcm() {
  set_has_bcm();
  if (bcm_ == NULL) {
    bcm_ = new ::COWA::NavMsg::VehicleBCM;
  }
  // @@protoc_insertion_point(field_mutable:COWA.NavMsg.VehicleCommond.bcm)
  return bcm_;
}
inline ::COWA::NavMsg::VehicleBCM* VehicleCommond::release_bcm() {
  // @@protoc_insertion_point(field_release:COWA.NavMsg.VehicleCommond.bcm)
  clear_has_bcm();
  ::COWA::NavMsg::VehicleBCM* temp = bcm_;
  bcm_ = NULL;
  return temp;
}
inline void VehicleCommond::set_allocated_bcm(::COWA::NavMsg::VehicleBCM* bcm) {
  delete bcm_;
  bcm_ = bcm;
  if (bcm) {
    set_has_bcm();
  } else {
    clear_has_bcm();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.NavMsg.VehicleCommond.bcm)
}

// optional int32 latency_ms = 5;
inline bool VehicleCommond::has_latency_ms() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VehicleCommond::set_has_latency_ms() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VehicleCommond::clear_has_latency_ms() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VehicleCommond::clear_latency_ms() {
  latency_ms_ = 0;
  clear_has_latency_ms();
}
inline ::google::protobuf::int32 VehicleCommond::latency_ms() const {
  // @@protoc_insertion_point(field_get:COWA.NavMsg.VehicleCommond.latency_ms)
  return latency_ms_;
}
inline void VehicleCommond::set_latency_ms(::google::protobuf::int32 value) {
  set_has_latency_ms();
  latency_ms_ = value;
  // @@protoc_insertion_point(field_set:COWA.NavMsg.VehicleCommond.latency_ms)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace NavMsg
}  // namespace COWA

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::COWA::NavMsg::VehicleBCM_TurnSignal> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::COWA::NavMsg::VehicleBCM_TurnSignal>() {
  return ::COWA::NavMsg::VehicleBCM_TurnSignal_descriptor();
}
template <> struct is_proto_enum< ::COWA::NavMsg::VehicleDrive_DrivingMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::COWA::NavMsg::VehicleDrive_DrivingMode>() {
  return ::COWA::NavMsg::VehicleDrive_DrivingMode_descriptor();
}
template <> struct is_proto_enum< ::COWA::NavMsg::VehicleDrive_GearPosition> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::COWA::NavMsg::VehicleDrive_GearPosition>() {
  return ::COWA::NavMsg::VehicleDrive_GearPosition_descriptor();
}
template <> struct is_proto_enum< ::COWA::NavMsg::VehicleDrive_SpeedMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::COWA::NavMsg::VehicleDrive_SpeedMode>() {
  return ::COWA::NavMsg::VehicleDrive_SpeedMode_descriptor();
}
template <> struct is_proto_enum< ::COWA::NavMsg::DrivingError> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::COWA::NavMsg::DrivingError>() {
  return ::COWA::NavMsg::DrivingError_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_chassis_2eproto__INCLUDED
