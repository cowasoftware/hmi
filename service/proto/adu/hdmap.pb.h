// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: hdmap.proto

#ifndef PROTOBUF_hdmap_2eproto__INCLUDED
#define PROTOBUF_hdmap_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "hdmap_common.pb.h"
// @@protoc_insertion_point(includes)
namespace COWA {
namespace MapData {
class Cloud;
class CloudDefaultTypeInternal;
extern CloudDefaultTypeInternal _Cloud_default_instance_;
class Crossroad;
class CrossroadDefaultTypeInternal;
extern CrossroadDefaultTypeInternal _Crossroad_default_instance_;
class CrossroadOverlapInfo;
class CrossroadOverlapInfoDefaultTypeInternal;
extern CrossroadOverlapInfoDefaultTypeInternal _CrossroadOverlapInfo_default_instance_;
class Crossroad_Line;
class Crossroad_LineDefaultTypeInternal;
extern Crossroad_LineDefaultTypeInternal _Crossroad_Line_default_instance_;
class Crosswalk;
class CrosswalkDefaultTypeInternal;
extern CrosswalkDefaultTypeInternal _Crosswalk_default_instance_;
class CrosswalkOverlapInfo;
class CrosswalkOverlapInfoDefaultTypeInternal;
extern CrosswalkOverlapInfoDefaultTypeInternal _CrosswalkOverlapInfo_default_instance_;
class HdMap;
class HdMapDefaultTypeInternal;
extern HdMapDefaultTypeInternal _HdMap_default_instance_;
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class Id;
class IdDefaultTypeInternal;
extern IdDefaultTypeInternal _Id_default_instance_;
class Lane;
class LaneDefaultTypeInternal;
extern LaneDefaultTypeInternal _Lane_default_instance_;
class LaneChange;
class LaneChangeDefaultTypeInternal;
extern LaneChangeDefaultTypeInternal _LaneChange_default_instance_;
class LaneCurve;
class LaneCurveDefaultTypeInternal;
extern LaneCurveDefaultTypeInternal _LaneCurve_default_instance_;
class LaneOverlapInfo;
class LaneOverlapInfoDefaultTypeInternal;
extern LaneOverlapInfoDefaultTypeInternal _LaneOverlapInfo_default_instance_;
class LanePoint;
class LanePointDefaultTypeInternal;
extern LanePointDefaultTypeInternal _LanePoint_default_instance_;
class LaneStrip;
class LaneStripDefaultTypeInternal;
extern LaneStripDefaultTypeInternal _LaneStrip_default_instance_;
class LaneTide;
class LaneTideDefaultTypeInternal;
extern LaneTideDefaultTypeInternal _LaneTide_default_instance_;
class LaneTide_Item;
class LaneTide_ItemDefaultTypeInternal;
extern LaneTide_ItemDefaultTypeInternal _LaneTide_Item_default_instance_;
class LaneTide_Item_Time;
class LaneTide_Item_TimeDefaultTypeInternal;
extern LaneTide_Item_TimeDefaultTypeInternal _LaneTide_Item_Time_default_instance_;
class Lane_LaneMark;
class Lane_LaneMarkDefaultTypeInternal;
extern Lane_LaneMarkDefaultTypeInternal _Lane_LaneMark_default_instance_;
class Object;
class ObjectDefaultTypeInternal;
extern ObjectDefaultTypeInternal _Object_default_instance_;
class Overlap;
class OverlapDefaultTypeInternal;
extern OverlapDefaultTypeInternal _Overlap_default_instance_;
class Overlap_ObjectOverlapInfo;
class Overlap_ObjectOverlapInfoDefaultTypeInternal;
extern Overlap_ObjectOverlapInfoDefaultTypeInternal _Overlap_ObjectOverlapInfo_default_instance_;
class ParkingSpace;
class ParkingSpaceDefaultTypeInternal;
extern ParkingSpaceDefaultTypeInternal _ParkingSpace_default_instance_;
class PointENU;
class PointENUDefaultTypeInternal;
extern PointENUDefaultTypeInternal _PointENU_default_instance_;
class Polygon;
class PolygonDefaultTypeInternal;
extern PolygonDefaultTypeInternal _Polygon_default_instance_;
class Ramp;
class RampDefaultTypeInternal;
extern RampDefaultTypeInternal _Ramp_default_instance_;
class RampOverlapInfo;
class RampOverlapInfoDefaultTypeInternal;
extern RampOverlapInfoDefaultTypeInternal _RampOverlapInfo_default_instance_;
class Road;
class RoadDefaultTypeInternal;
extern RoadDefaultTypeInternal _Road_default_instance_;
class RoadOverlapInfo;
class RoadOverlapInfoDefaultTypeInternal;
extern RoadOverlapInfoDefaultTypeInternal _RoadOverlapInfo_default_instance_;
class Roadmark;
class RoadmarkDefaultTypeInternal;
extern RoadmarkDefaultTypeInternal _Roadmark_default_instance_;
class RoadmarkOverlapInfo;
class RoadmarkOverlapInfoDefaultTypeInternal;
extern RoadmarkOverlapInfoDefaultTypeInternal _RoadmarkOverlapInfo_default_instance_;
class Signal;
class SignalDefaultTypeInternal;
extern SignalDefaultTypeInternal _Signal_default_instance_;
class SignalOverlapInfo;
class SignalOverlapInfoDefaultTypeInternal;
extern SignalOverlapInfoDefaultTypeInternal _SignalOverlapInfo_default_instance_;
class Square;
class SquareDefaultTypeInternal;
extern SquareDefaultTypeInternal _Square_default_instance_;
class Subsignal;
class SubsignalDefaultTypeInternal;
extern SubsignalDefaultTypeInternal _Subsignal_default_instance_;
}  // namespace MapData
}  // namespace COWA

namespace COWA {
namespace MapData {

namespace protobuf_hdmap_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_hdmap_2eproto

enum LaneStrip_Type {
  LaneStrip_Type_WALL = 1,
  LaneStrip_Type_FENCE = 2,
  LaneStrip_Type_GREEN = 3
};
bool LaneStrip_Type_IsValid(int value);
const LaneStrip_Type LaneStrip_Type_Type_MIN = LaneStrip_Type_WALL;
const LaneStrip_Type LaneStrip_Type_Type_MAX = LaneStrip_Type_GREEN;
const int LaneStrip_Type_Type_ARRAYSIZE = LaneStrip_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* LaneStrip_Type_descriptor();
inline const ::std::string& LaneStrip_Type_Name(LaneStrip_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    LaneStrip_Type_descriptor(), value);
}
inline bool LaneStrip_Type_Parse(
    const ::std::string& name, LaneStrip_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaneStrip_Type>(
    LaneStrip_Type_descriptor(), name, value);
}
enum LanePoint_Type {
  LanePoint_Type_UNKNOWN = 0,
  LanePoint_Type_DOTTED_YELLOW = 1,
  LanePoint_Type_DOTTED_WHITE = 2,
  LanePoint_Type_SOLID_YELLOW = 3,
  LanePoint_Type_SOLID_WHITE = 4,
  LanePoint_Type_DOUBLE_YELLOW = 5,
  LanePoint_Type_CURB = 6,
  LanePoint_Type_BLANK = 7,
  LanePoint_Type_VIRTUAL = 9
};
bool LanePoint_Type_IsValid(int value);
const LanePoint_Type LanePoint_Type_Type_MIN = LanePoint_Type_UNKNOWN;
const LanePoint_Type LanePoint_Type_Type_MAX = LanePoint_Type_VIRTUAL;
const int LanePoint_Type_Type_ARRAYSIZE = LanePoint_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* LanePoint_Type_descriptor();
inline const ::std::string& LanePoint_Type_Name(LanePoint_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    LanePoint_Type_descriptor(), value);
}
inline bool LanePoint_Type_Parse(
    const ::std::string& name, LanePoint_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LanePoint_Type>(
    LanePoint_Type_descriptor(), name, value);
}
enum LaneCurve_Type {
  LaneCurve_Type_REALITY = 0,
  LaneCurve_Type_VIRTUAL = 1,
  LaneCurve_Type_CENTRAL = 2
};
bool LaneCurve_Type_IsValid(int value);
const LaneCurve_Type LaneCurve_Type_Type_MIN = LaneCurve_Type_REALITY;
const LaneCurve_Type LaneCurve_Type_Type_MAX = LaneCurve_Type_CENTRAL;
const int LaneCurve_Type_Type_ARRAYSIZE = LaneCurve_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* LaneCurve_Type_descriptor();
inline const ::std::string& LaneCurve_Type_Name(LaneCurve_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    LaneCurve_Type_descriptor(), value);
}
inline bool LaneCurve_Type_Parse(
    const ::std::string& name, LaneCurve_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaneCurve_Type>(
    LaneCurve_Type_descriptor(), name, value);
}
enum Lane_LaneMark_Type {
  Lane_LaneMark_Type_TEXT = 0,
  Lane_LaneMark_Type_TURN_FORWORD = 1,
  Lane_LaneMark_Type_TURN_UTURN = 2,
  Lane_LaneMark_Type_TURN_LEFT = 3,
  Lane_LaneMark_Type_TURN_RIGHT = 4,
  Lane_LaneMark_Type_TURN_FORWORD_LEFT = 5,
  Lane_LaneMark_Type_TURN_FORWORD_RIGHT = 6,
  Lane_LaneMark_Type_TURN_FORWORD_UTURN = 7,
  Lane_LaneMark_Type_TURN_LEFT_UTURN = 8,
  Lane_LaneMark_Type_TURN_LEFT_RIGHT = 9,
  Lane_LaneMark_Type_TURN_UTURN_FORBIDEN = 10,
  Lane_LaneMark_Type_TURN_LEFT_FORBIDEN = 11,
  Lane_LaneMark_Type_TURN_RIGHT_FORBIDEN = 12
};
bool Lane_LaneMark_Type_IsValid(int value);
const Lane_LaneMark_Type Lane_LaneMark_Type_Type_MIN = Lane_LaneMark_Type_TEXT;
const Lane_LaneMark_Type Lane_LaneMark_Type_Type_MAX = Lane_LaneMark_Type_TURN_RIGHT_FORBIDEN;
const int Lane_LaneMark_Type_Type_ARRAYSIZE = Lane_LaneMark_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Lane_LaneMark_Type_descriptor();
inline const ::std::string& Lane_LaneMark_Type_Name(Lane_LaneMark_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Lane_LaneMark_Type_descriptor(), value);
}
inline bool Lane_LaneMark_Type_Parse(
    const ::std::string& name, Lane_LaneMark_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Lane_LaneMark_Type>(
    Lane_LaneMark_Type_descriptor(), name, value);
}
enum Lane_LaneType {
  Lane_LaneType_NONE = 1,
  Lane_LaneType_CITY_DRIVING = 2,
  Lane_LaneType_BIKING = 3,
  Lane_LaneType_PARKING = 7,
  Lane_LaneType_EMERGENCY_LINE = 8,
  Lane_LaneType_SIDEWALK = 4,
  Lane_LaneType_WAITINGAREA = 5,
  Lane_LaneType_HYBRID = 6
};
bool Lane_LaneType_IsValid(int value);
const Lane_LaneType Lane_LaneType_LaneType_MIN = Lane_LaneType_NONE;
const Lane_LaneType Lane_LaneType_LaneType_MAX = Lane_LaneType_EMERGENCY_LINE;
const int Lane_LaneType_LaneType_ARRAYSIZE = Lane_LaneType_LaneType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Lane_LaneType_descriptor();
inline const ::std::string& Lane_LaneType_Name(Lane_LaneType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Lane_LaneType_descriptor(), value);
}
inline bool Lane_LaneType_Parse(
    const ::std::string& name, Lane_LaneType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Lane_LaneType>(
    Lane_LaneType_descriptor(), name, value);
}
enum Lane_LaneDirection {
  Lane_LaneDirection_FORWARD = 1,
  Lane_LaneDirection_BACKWARD = 2,
  Lane_LaneDirection_BIDIRECTION = 3
};
bool Lane_LaneDirection_IsValid(int value);
const Lane_LaneDirection Lane_LaneDirection_LaneDirection_MIN = Lane_LaneDirection_FORWARD;
const Lane_LaneDirection Lane_LaneDirection_LaneDirection_MAX = Lane_LaneDirection_BIDIRECTION;
const int Lane_LaneDirection_LaneDirection_ARRAYSIZE = Lane_LaneDirection_LaneDirection_MAX + 1;

const ::google::protobuf::EnumDescriptor* Lane_LaneDirection_descriptor();
inline const ::std::string& Lane_LaneDirection_Name(Lane_LaneDirection value) {
  return ::google::protobuf::internal::NameOfEnum(
    Lane_LaneDirection_descriptor(), value);
}
inline bool Lane_LaneDirection_Parse(
    const ::std::string& name, Lane_LaneDirection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Lane_LaneDirection>(
    Lane_LaneDirection_descriptor(), name, value);
}
enum Lane_LaneTurn {
  Lane_LaneTurn_NO_TURN = 1,
  Lane_LaneTurn_LEFT_TURN = 2,
  Lane_LaneTurn_RIGHT_TURN = 3,
  Lane_LaneTurn_U_TURN = 4
};
bool Lane_LaneTurn_IsValid(int value);
const Lane_LaneTurn Lane_LaneTurn_LaneTurn_MIN = Lane_LaneTurn_NO_TURN;
const Lane_LaneTurn Lane_LaneTurn_LaneTurn_MAX = Lane_LaneTurn_U_TURN;
const int Lane_LaneTurn_LaneTurn_ARRAYSIZE = Lane_LaneTurn_LaneTurn_MAX + 1;

const ::google::protobuf::EnumDescriptor* Lane_LaneTurn_descriptor();
inline const ::std::string& Lane_LaneTurn_Name(Lane_LaneTurn value) {
  return ::google::protobuf::internal::NameOfEnum(
    Lane_LaneTurn_descriptor(), value);
}
inline bool Lane_LaneTurn_Parse(
    const ::std::string& name, Lane_LaneTurn* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Lane_LaneTurn>(
    Lane_LaneTurn_descriptor(), name, value);
}
enum Road_RoadType {
  Road_RoadType_NONE = 1,
  Road_RoadType_CITY_DRIVING = 2,
  Road_RoadType_VIADUCT = 3,
  Road_RoadType_EXPRESSWAY = 4,
  Road_RoadType_TUNNEL = 5
};
bool Road_RoadType_IsValid(int value);
const Road_RoadType Road_RoadType_RoadType_MIN = Road_RoadType_NONE;
const Road_RoadType Road_RoadType_RoadType_MAX = Road_RoadType_TUNNEL;
const int Road_RoadType_RoadType_ARRAYSIZE = Road_RoadType_RoadType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Road_RoadType_descriptor();
inline const ::std::string& Road_RoadType_Name(Road_RoadType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Road_RoadType_descriptor(), value);
}
inline bool Road_RoadType_Parse(
    const ::std::string& name, Road_RoadType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Road_RoadType>(
    Road_RoadType_descriptor(), name, value);
}
enum Roadmark_RoadmarkType {
  Roadmark_RoadmarkType_NONE = 1,
  Roadmark_RoadmarkType_SPEEDBUMP = 2,
  Roadmark_RoadmarkType_STOPLINE = 3,
  Roadmark_RoadmarkType_YEILDLINE = 4,
  Roadmark_RoadmarkType_TEXT = 6,
  Roadmark_RoadmarkType_CLEARAREA = 7
};
bool Roadmark_RoadmarkType_IsValid(int value);
const Roadmark_RoadmarkType Roadmark_RoadmarkType_RoadmarkType_MIN = Roadmark_RoadmarkType_NONE;
const Roadmark_RoadmarkType Roadmark_RoadmarkType_RoadmarkType_MAX = Roadmark_RoadmarkType_CLEARAREA;
const int Roadmark_RoadmarkType_RoadmarkType_ARRAYSIZE = Roadmark_RoadmarkType_RoadmarkType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Roadmark_RoadmarkType_descriptor();
inline const ::std::string& Roadmark_RoadmarkType_Name(Roadmark_RoadmarkType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Roadmark_RoadmarkType_descriptor(), value);
}
inline bool Roadmark_RoadmarkType_Parse(
    const ::std::string& name, Roadmark_RoadmarkType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Roadmark_RoadmarkType>(
    Roadmark_RoadmarkType_descriptor(), name, value);
}
enum Object_Type {
  Object_Type_TREE_TRUNK = 1,
  Object_Type_POLE = 2,
  Object_Type_PILES = 3,
  Object_Type_DUSTBIN = 5,
  Object_Type_BLOCK = 6,
  Object_Type_BUILDING = 7,
  Object_Type_CURB = 8,
  Object_Type_LANE_SOLID = 9,
  Object_Type_LANE_DOTTED = 10,
  Object_Type_STOPLINE = 11,
  Object_Type_CROSSWALK = 12,
  Object_Type_ARROW = 13,
  Object_Type_HIGH_REFLECTIVITY = 14
};
bool Object_Type_IsValid(int value);
const Object_Type Object_Type_Type_MIN = Object_Type_TREE_TRUNK;
const Object_Type Object_Type_Type_MAX = Object_Type_HIGH_REFLECTIVITY;
const int Object_Type_Type_ARRAYSIZE = Object_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Object_Type_descriptor();
inline const ::std::string& Object_Type_Name(Object_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Object_Type_descriptor(), value);
}
inline bool Object_Type_Parse(
    const ::std::string& name, Object_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Object_Type>(
    Object_Type_descriptor(), name, value);
}
enum Subsignal_Type {
  Subsignal_Type_UNKNOWN = 1,
  Subsignal_Type_MIX_2_HORIZONTAL = 2,
  Subsignal_Type_MIX_2_VERTICAL = 3,
  Subsignal_Type_MIX_3_HORIZONTAL = 4,
  Subsignal_Type_MIX_3_VERTICAL = 5,
  Subsignal_Type_SINGLE = 6,
  Subsignal_Type_LED_SCREEN = 7
};
bool Subsignal_Type_IsValid(int value);
const Subsignal_Type Subsignal_Type_Type_MIN = Subsignal_Type_UNKNOWN;
const Subsignal_Type Subsignal_Type_Type_MAX = Subsignal_Type_LED_SCREEN;
const int Subsignal_Type_Type_ARRAYSIZE = Subsignal_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Subsignal_Type_descriptor();
inline const ::std::string& Subsignal_Type_Name(Subsignal_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Subsignal_Type_descriptor(), value);
}
inline bool Subsignal_Type_Parse(
    const ::std::string& name, Subsignal_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Subsignal_Type>(
    Subsignal_Type_descriptor(), name, value);
}
enum Signal_Type {
  Signal_Type_UNKNOWN = 1,
  Signal_Type_FOWARD = 2,
  Signal_Type_LEFT = 3,
  Signal_Type_RIGHT = 4,
  Signal_Type_UTURN = 5,
  Signal_Type_TIDE = 6
};
bool Signal_Type_IsValid(int value);
const Signal_Type Signal_Type_Type_MIN = Signal_Type_UNKNOWN;
const Signal_Type Signal_Type_Type_MAX = Signal_Type_TIDE;
const int Signal_Type_Type_ARRAYSIZE = Signal_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Signal_Type_descriptor();
inline const ::std::string& Signal_Type_Name(Signal_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Signal_Type_descriptor(), value);
}
inline bool Signal_Type_Parse(
    const ::std::string& name, Signal_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Signal_Type>(
    Signal_Type_descriptor(), name, value);
}
enum Crossroad_Type {
  Crossroad_Type_CROSS = 1,
  Crossroad_Type_INTERSECTION = 2
};
bool Crossroad_Type_IsValid(int value);
const Crossroad_Type Crossroad_Type_Type_MIN = Crossroad_Type_CROSS;
const Crossroad_Type Crossroad_Type_Type_MAX = Crossroad_Type_INTERSECTION;
const int Crossroad_Type_Type_ARRAYSIZE = Crossroad_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Crossroad_Type_descriptor();
inline const ::std::string& Crossroad_Type_Name(Crossroad_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Crossroad_Type_descriptor(), value);
}
inline bool Crossroad_Type_Parse(
    const ::std::string& name, Crossroad_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Crossroad_Type>(
    Crossroad_Type_descriptor(), name, value);
}
// ===================================================================

class LaneStrip : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.MapData.LaneStrip) */ {
 public:
  LaneStrip();
  virtual ~LaneStrip();

  LaneStrip(const LaneStrip& from);

  inline LaneStrip& operator=(const LaneStrip& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneStrip& default_instance();

  static inline const LaneStrip* internal_default_instance() {
    return reinterpret_cast<const LaneStrip*>(
               &_LaneStrip_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(LaneStrip* other);

  // implements Message ----------------------------------------------

  inline LaneStrip* New() const PROTOBUF_FINAL { return New(NULL); }

  LaneStrip* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LaneStrip& from);
  void MergeFrom(const LaneStrip& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LaneStrip* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef LaneStrip_Type Type;
  static const Type WALL =
    LaneStrip_Type_WALL;
  static const Type FENCE =
    LaneStrip_Type_FENCE;
  static const Type GREEN =
    LaneStrip_Type_GREEN;
  static inline bool Type_IsValid(int value) {
    return LaneStrip_Type_IsValid(value);
  }
  static const Type Type_MIN =
    LaneStrip_Type_Type_MIN;
  static const Type Type_MAX =
    LaneStrip_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    LaneStrip_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return LaneStrip_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return LaneStrip_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return LaneStrip_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional float start_s = 1;
  bool has_start_s() const;
  void clear_start_s();
  static const int kStartSFieldNumber = 1;
  float start_s() const;
  void set_start_s(float value);

  // optional float end_s = 2;
  bool has_end_s() const;
  void clear_end_s();
  static const int kEndSFieldNumber = 2;
  float end_s() const;
  void set_end_s(float value);

  // optional float height = 3;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 3;
  float height() const;
  void set_height(float value);

  // @@protoc_insertion_point(class_scope:COWA.MapData.LaneStrip)
 private:
  void set_has_start_s();
  void clear_has_start_s();
  void set_has_end_s();
  void clear_has_end_s();
  void set_has_height();
  void clear_has_height();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float start_s_;
  float end_s_;
  float height_;
  friend struct protobuf_hdmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LanePoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.MapData.LanePoint) */ {
 public:
  LanePoint();
  virtual ~LanePoint();

  LanePoint(const LanePoint& from);

  inline LanePoint& operator=(const LanePoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LanePoint& default_instance();

  static inline const LanePoint* internal_default_instance() {
    return reinterpret_cast<const LanePoint*>(
               &_LanePoint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(LanePoint* other);

  // implements Message ----------------------------------------------

  inline LanePoint* New() const PROTOBUF_FINAL { return New(NULL); }

  LanePoint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LanePoint& from);
  void MergeFrom(const LanePoint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LanePoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef LanePoint_Type Type;
  static const Type UNKNOWN =
    LanePoint_Type_UNKNOWN;
  static const Type DOTTED_YELLOW =
    LanePoint_Type_DOTTED_YELLOW;
  static const Type DOTTED_WHITE =
    LanePoint_Type_DOTTED_WHITE;
  static const Type SOLID_YELLOW =
    LanePoint_Type_SOLID_YELLOW;
  static const Type SOLID_WHITE =
    LanePoint_Type_SOLID_WHITE;
  static const Type DOUBLE_YELLOW =
    LanePoint_Type_DOUBLE_YELLOW;
  static const Type CURB =
    LanePoint_Type_CURB;
  static const Type BLANK =
    LanePoint_Type_BLANK;
  static const Type VIRTUAL =
    LanePoint_Type_VIRTUAL;
  static inline bool Type_IsValid(int value) {
    return LanePoint_Type_IsValid(value);
  }
  static const Type Type_MIN =
    LanePoint_Type_Type_MIN;
  static const Type Type_MAX =
    LanePoint_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    LanePoint_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return LanePoint_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return LanePoint_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return LanePoint_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // optional float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // optional float z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // optional .COWA.MapData.LanePoint.Type type = 4;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  ::COWA::MapData::LanePoint_Type type() const;
  void set_type(::COWA::MapData::LanePoint_Type value);

  // optional float height = 5;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 5;
  float height() const;
  void set_height(float value);

  // @@protoc_insertion_point(class_scope:COWA.MapData.LanePoint)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();
  void set_has_type();
  void clear_has_type();
  void set_has_height();
  void clear_has_height();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  int type_;
  float height_;
  friend struct protobuf_hdmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LaneCurve : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.MapData.LaneCurve) */ {
 public:
  LaneCurve();
  virtual ~LaneCurve();

  LaneCurve(const LaneCurve& from);

  inline LaneCurve& operator=(const LaneCurve& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneCurve& default_instance();

  static inline const LaneCurve* internal_default_instance() {
    return reinterpret_cast<const LaneCurve*>(
               &_LaneCurve_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(LaneCurve* other);

  // implements Message ----------------------------------------------

  inline LaneCurve* New() const PROTOBUF_FINAL { return New(NULL); }

  LaneCurve* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LaneCurve& from);
  void MergeFrom(const LaneCurve& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LaneCurve* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef LaneCurve_Type Type;
  static const Type REALITY =
    LaneCurve_Type_REALITY;
  static const Type VIRTUAL =
    LaneCurve_Type_VIRTUAL;
  static const Type CENTRAL =
    LaneCurve_Type_CENTRAL;
  static inline bool Type_IsValid(int value) {
    return LaneCurve_Type_IsValid(value);
  }
  static const Type Type_MIN =
    LaneCurve_Type_Type_MIN;
  static const Type Type_MAX =
    LaneCurve_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    LaneCurve_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return LaneCurve_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return LaneCurve_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return LaneCurve_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .COWA.MapData.LanePoint point = 1;
  int point_size() const;
  void clear_point();
  static const int kPointFieldNumber = 1;
  const ::COWA::MapData::LanePoint& point(int index) const;
  ::COWA::MapData::LanePoint* mutable_point(int index);
  ::COWA::MapData::LanePoint* add_point();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::LanePoint >*
      mutable_point();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::LanePoint >&
      point() const;

  // repeated .COWA.MapData.LaneStrip strip = 6;
  int strip_size() const;
  void clear_strip();
  static const int kStripFieldNumber = 6;
  const ::COWA::MapData::LaneStrip& strip(int index) const;
  ::COWA::MapData::LaneStrip* mutable_strip(int index);
  ::COWA::MapData::LaneStrip* add_strip();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::LaneStrip >*
      mutable_strip();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::LaneStrip >&
      strip() const;

  // optional .COWA.MapData.Id id = 2;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 2;
  const ::COWA::MapData::Id& id() const;
  ::COWA::MapData::Id* mutable_id();
  ::COWA::MapData::Id* release_id();
  void set_allocated_id(::COWA::MapData::Id* id);

  // optional double offset_x = 3;
  bool has_offset_x() const;
  void clear_offset_x();
  static const int kOffsetXFieldNumber = 3;
  double offset_x() const;
  void set_offset_x(double value);

  // optional double offset_y = 4;
  bool has_offset_y() const;
  void clear_offset_y();
  static const int kOffsetYFieldNumber = 4;
  double offset_y() const;
  void set_offset_y(double value);

  // optional .COWA.MapData.LaneCurve.Type type = 5;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 5;
  ::COWA::MapData::LaneCurve_Type type() const;
  void set_type(::COWA::MapData::LaneCurve_Type value);

  // @@protoc_insertion_point(class_scope:COWA.MapData.LaneCurve)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_offset_x();
  void clear_has_offset_x();
  void set_has_offset_y();
  void clear_has_offset_y();
  void set_has_type();
  void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::LanePoint > point_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::LaneStrip > strip_;
  ::COWA::MapData::Id* id_;
  double offset_x_;
  double offset_y_;
  int type_;
  friend struct protobuf_hdmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Lane_LaneMark : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.MapData.Lane.LaneMark) */ {
 public:
  Lane_LaneMark();
  virtual ~Lane_LaneMark();

  Lane_LaneMark(const Lane_LaneMark& from);

  inline Lane_LaneMark& operator=(const Lane_LaneMark& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Lane_LaneMark& default_instance();

  static inline const Lane_LaneMark* internal_default_instance() {
    return reinterpret_cast<const Lane_LaneMark*>(
               &_Lane_LaneMark_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Lane_LaneMark* other);

  // implements Message ----------------------------------------------

  inline Lane_LaneMark* New() const PROTOBUF_FINAL { return New(NULL); }

  Lane_LaneMark* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Lane_LaneMark& from);
  void MergeFrom(const Lane_LaneMark& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Lane_LaneMark* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Lane_LaneMark_Type Type;
  static const Type TEXT =
    Lane_LaneMark_Type_TEXT;
  static const Type TURN_FORWORD =
    Lane_LaneMark_Type_TURN_FORWORD;
  static const Type TURN_UTURN =
    Lane_LaneMark_Type_TURN_UTURN;
  static const Type TURN_LEFT =
    Lane_LaneMark_Type_TURN_LEFT;
  static const Type TURN_RIGHT =
    Lane_LaneMark_Type_TURN_RIGHT;
  static const Type TURN_FORWORD_LEFT =
    Lane_LaneMark_Type_TURN_FORWORD_LEFT;
  static const Type TURN_FORWORD_RIGHT =
    Lane_LaneMark_Type_TURN_FORWORD_RIGHT;
  static const Type TURN_FORWORD_UTURN =
    Lane_LaneMark_Type_TURN_FORWORD_UTURN;
  static const Type TURN_LEFT_UTURN =
    Lane_LaneMark_Type_TURN_LEFT_UTURN;
  static const Type TURN_LEFT_RIGHT =
    Lane_LaneMark_Type_TURN_LEFT_RIGHT;
  static const Type TURN_UTURN_FORBIDEN =
    Lane_LaneMark_Type_TURN_UTURN_FORBIDEN;
  static const Type TURN_LEFT_FORBIDEN =
    Lane_LaneMark_Type_TURN_LEFT_FORBIDEN;
  static const Type TURN_RIGHT_FORBIDEN =
    Lane_LaneMark_Type_TURN_RIGHT_FORBIDEN;
  static inline bool Type_IsValid(int value) {
    return Lane_LaneMark_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Lane_LaneMark_Type_Type_MIN;
  static const Type Type_MAX =
    Lane_LaneMark_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Lane_LaneMark_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Lane_LaneMark_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Lane_LaneMark_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Lane_LaneMark_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string text = 3;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 3;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // optional .COWA.MapData.PointENU centroid = 2;
  bool has_centroid() const;
  void clear_centroid();
  static const int kCentroidFieldNumber = 2;
  const ::COWA::MapData::PointENU& centroid() const;
  ::COWA::MapData::PointENU* mutable_centroid();
  ::COWA::MapData::PointENU* release_centroid();
  void set_allocated_centroid(::COWA::MapData::PointENU* centroid);

  // optional .COWA.MapData.Polygon polygon = 4;
  bool has_polygon() const;
  void clear_polygon();
  static const int kPolygonFieldNumber = 4;
  const ::COWA::MapData::Polygon& polygon() const;
  ::COWA::MapData::Polygon* mutable_polygon();
  ::COWA::MapData::Polygon* release_polygon();
  void set_allocated_polygon(::COWA::MapData::Polygon* polygon);

  // optional .COWA.MapData.Lane.LaneMark.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::COWA::MapData::Lane_LaneMark_Type type() const;
  void set_type(::COWA::MapData::Lane_LaneMark_Type value);

  // optional float direction = 5;
  bool has_direction() const;
  void clear_direction();
  static const int kDirectionFieldNumber = 5;
  float direction() const;
  void set_direction(float value);

  // @@protoc_insertion_point(class_scope:COWA.MapData.Lane.LaneMark)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_centroid();
  void clear_has_centroid();
  void set_has_text();
  void clear_has_text();
  void set_has_polygon();
  void clear_has_polygon();
  void set_has_direction();
  void clear_has_direction();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::COWA::MapData::PointENU* centroid_;
  ::COWA::MapData::Polygon* polygon_;
  int type_;
  float direction_;
  friend struct protobuf_hdmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Lane : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.MapData.Lane) */ {
 public:
  Lane();
  virtual ~Lane();

  Lane(const Lane& from);

  inline Lane& operator=(const Lane& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Lane& default_instance();

  static inline const Lane* internal_default_instance() {
    return reinterpret_cast<const Lane*>(
               &_Lane_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Lane* other);

  // implements Message ----------------------------------------------

  inline Lane* New() const PROTOBUF_FINAL { return New(NULL); }

  Lane* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Lane& from);
  void MergeFrom(const Lane& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Lane* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Lane_LaneMark LaneMark;

  typedef Lane_LaneType LaneType;
  static const LaneType NONE =
    Lane_LaneType_NONE;
  static const LaneType CITY_DRIVING =
    Lane_LaneType_CITY_DRIVING;
  static const LaneType BIKING =
    Lane_LaneType_BIKING;
  static const LaneType PARKING =
    Lane_LaneType_PARKING;
  static const LaneType EMERGENCY_LINE =
    Lane_LaneType_EMERGENCY_LINE;
  static const LaneType SIDEWALK =
    Lane_LaneType_SIDEWALK;
  static const LaneType WAITINGAREA =
    Lane_LaneType_WAITINGAREA;
  static const LaneType HYBRID =
    Lane_LaneType_HYBRID;
  static inline bool LaneType_IsValid(int value) {
    return Lane_LaneType_IsValid(value);
  }
  static const LaneType LaneType_MIN =
    Lane_LaneType_LaneType_MIN;
  static const LaneType LaneType_MAX =
    Lane_LaneType_LaneType_MAX;
  static const int LaneType_ARRAYSIZE =
    Lane_LaneType_LaneType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LaneType_descriptor() {
    return Lane_LaneType_descriptor();
  }
  static inline const ::std::string& LaneType_Name(LaneType value) {
    return Lane_LaneType_Name(value);
  }
  static inline bool LaneType_Parse(const ::std::string& name,
      LaneType* value) {
    return Lane_LaneType_Parse(name, value);
  }

  typedef Lane_LaneDirection LaneDirection;
  static const LaneDirection FORWARD =
    Lane_LaneDirection_FORWARD;
  static const LaneDirection BACKWARD =
    Lane_LaneDirection_BACKWARD;
  static const LaneDirection BIDIRECTION =
    Lane_LaneDirection_BIDIRECTION;
  static inline bool LaneDirection_IsValid(int value) {
    return Lane_LaneDirection_IsValid(value);
  }
  static const LaneDirection LaneDirection_MIN =
    Lane_LaneDirection_LaneDirection_MIN;
  static const LaneDirection LaneDirection_MAX =
    Lane_LaneDirection_LaneDirection_MAX;
  static const int LaneDirection_ARRAYSIZE =
    Lane_LaneDirection_LaneDirection_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LaneDirection_descriptor() {
    return Lane_LaneDirection_descriptor();
  }
  static inline const ::std::string& LaneDirection_Name(LaneDirection value) {
    return Lane_LaneDirection_Name(value);
  }
  static inline bool LaneDirection_Parse(const ::std::string& name,
      LaneDirection* value) {
    return Lane_LaneDirection_Parse(name, value);
  }

  typedef Lane_LaneTurn LaneTurn;
  static const LaneTurn NO_TURN =
    Lane_LaneTurn_NO_TURN;
  static const LaneTurn LEFT_TURN =
    Lane_LaneTurn_LEFT_TURN;
  static const LaneTurn RIGHT_TURN =
    Lane_LaneTurn_RIGHT_TURN;
  static const LaneTurn U_TURN =
    Lane_LaneTurn_U_TURN;
  static inline bool LaneTurn_IsValid(int value) {
    return Lane_LaneTurn_IsValid(value);
  }
  static const LaneTurn LaneTurn_MIN =
    Lane_LaneTurn_LaneTurn_MIN;
  static const LaneTurn LaneTurn_MAX =
    Lane_LaneTurn_LaneTurn_MAX;
  static const int LaneTurn_ARRAYSIZE =
    Lane_LaneTurn_LaneTurn_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LaneTurn_descriptor() {
    return Lane_LaneTurn_descriptor();
  }
  static inline const ::std::string& LaneTurn_Name(LaneTurn value) {
    return Lane_LaneTurn_Name(value);
  }
  static inline bool LaneTurn_Parse(const ::std::string& name,
      LaneTurn* value) {
    return Lane_LaneTurn_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .COWA.MapData.Id left_line = 4;
  int left_line_size() const;
  void clear_left_line();
  static const int kLeftLineFieldNumber = 4;
  const ::COWA::MapData::Id& left_line(int index) const;
  ::COWA::MapData::Id* mutable_left_line(int index);
  ::COWA::MapData::Id* add_left_line();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >*
      mutable_left_line();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >&
      left_line() const;

  // repeated .COWA.MapData.Id right_line = 5;
  int right_line_size() const;
  void clear_right_line();
  static const int kRightLineFieldNumber = 5;
  const ::COWA::MapData::Id& right_line(int index) const;
  ::COWA::MapData::Id* mutable_right_line(int index);
  ::COWA::MapData::Id* add_right_line();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >*
      mutable_right_line();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >&
      right_line() const;

  // repeated .COWA.MapData.Id predecessor_id = 8;
  int predecessor_id_size() const;
  void clear_predecessor_id();
  static const int kPredecessorIdFieldNumber = 8;
  const ::COWA::MapData::Id& predecessor_id(int index) const;
  ::COWA::MapData::Id* mutable_predecessor_id(int index);
  ::COWA::MapData::Id* add_predecessor_id();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >*
      mutable_predecessor_id();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >&
      predecessor_id() const;

  // repeated .COWA.MapData.Id successor_id = 9;
  int successor_id_size() const;
  void clear_successor_id();
  static const int kSuccessorIdFieldNumber = 9;
  const ::COWA::MapData::Id& successor_id(int index) const;
  ::COWA::MapData::Id* mutable_successor_id(int index);
  ::COWA::MapData::Id* add_successor_id();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >*
      mutable_successor_id();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >&
      successor_id() const;

  // repeated .COWA.MapData.Id left_neighbor_forward_lane_id = 10;
  int left_neighbor_forward_lane_id_size() const;
  void clear_left_neighbor_forward_lane_id();
  static const int kLeftNeighborForwardLaneIdFieldNumber = 10;
  const ::COWA::MapData::Id& left_neighbor_forward_lane_id(int index) const;
  ::COWA::MapData::Id* mutable_left_neighbor_forward_lane_id(int index);
  ::COWA::MapData::Id* add_left_neighbor_forward_lane_id();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >*
      mutable_left_neighbor_forward_lane_id();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >&
      left_neighbor_forward_lane_id() const;

  // repeated .COWA.MapData.Id right_neighbor_forward_lane_id = 11;
  int right_neighbor_forward_lane_id_size() const;
  void clear_right_neighbor_forward_lane_id();
  static const int kRightNeighborForwardLaneIdFieldNumber = 11;
  const ::COWA::MapData::Id& right_neighbor_forward_lane_id(int index) const;
  ::COWA::MapData::Id* mutable_right_neighbor_forward_lane_id(int index);
  ::COWA::MapData::Id* add_right_neighbor_forward_lane_id();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >*
      mutable_right_neighbor_forward_lane_id();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >&
      right_neighbor_forward_lane_id() const;

  // repeated .COWA.MapData.Id left_neighbor_reverse_lane_id = 12;
  int left_neighbor_reverse_lane_id_size() const;
  void clear_left_neighbor_reverse_lane_id();
  static const int kLeftNeighborReverseLaneIdFieldNumber = 12;
  const ::COWA::MapData::Id& left_neighbor_reverse_lane_id(int index) const;
  ::COWA::MapData::Id* mutable_left_neighbor_reverse_lane_id(int index);
  ::COWA::MapData::Id* add_left_neighbor_reverse_lane_id();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >*
      mutable_left_neighbor_reverse_lane_id();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >&
      left_neighbor_reverse_lane_id() const;

  // repeated .COWA.MapData.Id right_neighbor_reverse_lane_id = 13;
  int right_neighbor_reverse_lane_id_size() const;
  void clear_right_neighbor_reverse_lane_id();
  static const int kRightNeighborReverseLaneIdFieldNumber = 13;
  const ::COWA::MapData::Id& right_neighbor_reverse_lane_id(int index) const;
  ::COWA::MapData::Id* mutable_right_neighbor_reverse_lane_id(int index);
  ::COWA::MapData::Id* add_right_neighbor_reverse_lane_id();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >*
      mutable_right_neighbor_reverse_lane_id();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >&
      right_neighbor_reverse_lane_id() const;

  // repeated .COWA.MapData.Lane.LaneMark mark = 17;
  int mark_size() const;
  void clear_mark();
  static const int kMarkFieldNumber = 17;
  const ::COWA::MapData::Lane_LaneMark& mark(int index) const;
  ::COWA::MapData::Lane_LaneMark* mutable_mark(int index);
  ::COWA::MapData::Lane_LaneMark* add_mark();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Lane_LaneMark >*
      mutable_mark();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Lane_LaneMark >&
      mark() const;

  // optional .COWA.MapData.Id id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::COWA::MapData::Id& id() const;
  ::COWA::MapData::Id* mutable_id();
  ::COWA::MapData::Id* release_id();
  void set_allocated_id(::COWA::MapData::Id* id);

  // optional .COWA.MapData.Id central_line = 3;
  bool has_central_line() const;
  void clear_central_line();
  static const int kCentralLineFieldNumber = 3;
  const ::COWA::MapData::Id& central_line() const;
  ::COWA::MapData::Id* mutable_central_line();
  ::COWA::MapData::Id* release_central_line();
  void set_allocated_central_line(::COWA::MapData::Id* central_line);

  // optional float length = 6;
  bool has_length() const;
  void clear_length();
  static const int kLengthFieldNumber = 6;
  float length() const;
  void set_length(float value);

  // optional float speed_limit = 7;
  bool has_speed_limit() const;
  void clear_speed_limit();
  static const int kSpeedLimitFieldNumber = 7;
  float speed_limit() const;
  void set_speed_limit(float value);

  // optional float min_speed_limit = 16;
  bool has_min_speed_limit() const;
  void clear_min_speed_limit();
  static const int kMinSpeedLimitFieldNumber = 16;
  float min_speed_limit() const;
  void set_min_speed_limit(float value);

  // optional .COWA.MapData.Lane.LaneTurn turn = 15;
  bool has_turn() const;
  void clear_turn();
  static const int kTurnFieldNumber = 15;
  ::COWA::MapData::Lane_LaneTurn turn() const;
  void set_turn(::COWA::MapData::Lane_LaneTurn value);

  // optional .COWA.MapData.Lane.LaneType type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::COWA::MapData::Lane_LaneType type() const;
  void set_type(::COWA::MapData::Lane_LaneType value);

  // optional .COWA.MapData.Lane.LaneDirection direction = 14;
  bool has_direction() const;
  void clear_direction();
  static const int kDirectionFieldNumber = 14;
  ::COWA::MapData::Lane_LaneDirection direction() const;
  void set_direction(::COWA::MapData::Lane_LaneDirection value);

  // @@protoc_insertion_point(class_scope:COWA.MapData.Lane)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_type();
  void clear_has_type();
  void set_has_central_line();
  void clear_has_central_line();
  void set_has_length();
  void clear_has_length();
  void set_has_speed_limit();
  void clear_has_speed_limit();
  void set_has_min_speed_limit();
  void clear_has_min_speed_limit();
  void set_has_direction();
  void clear_has_direction();
  void set_has_turn();
  void clear_has_turn();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id > left_line_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id > right_line_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id > predecessor_id_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id > successor_id_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id > left_neighbor_forward_lane_id_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id > right_neighbor_forward_lane_id_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id > left_neighbor_reverse_lane_id_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id > right_neighbor_reverse_lane_id_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Lane_LaneMark > mark_;
  ::COWA::MapData::Id* id_;
  ::COWA::MapData::Id* central_line_;
  float length_;
  float speed_limit_;
  float min_speed_limit_;
  int turn_;
  int type_;
  int direction_;
  friend struct protobuf_hdmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LaneTide_Item_Time : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.MapData.LaneTide.Item.Time) */ {
 public:
  LaneTide_Item_Time();
  virtual ~LaneTide_Item_Time();

  LaneTide_Item_Time(const LaneTide_Item_Time& from);

  inline LaneTide_Item_Time& operator=(const LaneTide_Item_Time& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneTide_Item_Time& default_instance();

  static inline const LaneTide_Item_Time* internal_default_instance() {
    return reinterpret_cast<const LaneTide_Item_Time*>(
               &_LaneTide_Item_Time_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(LaneTide_Item_Time* other);

  // implements Message ----------------------------------------------

  inline LaneTide_Item_Time* New() const PROTOBUF_FINAL { return New(NULL); }

  LaneTide_Item_Time* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LaneTide_Item_Time& from);
  void MergeFrom(const LaneTide_Item_Time& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LaneTide_Item_Time* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float start_time = 1;
  bool has_start_time() const;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 1;
  float start_time() const;
  void set_start_time(float value);

  // optional float end_time = 2;
  bool has_end_time() const;
  void clear_end_time();
  static const int kEndTimeFieldNumber = 2;
  float end_time() const;
  void set_end_time(float value);

  // @@protoc_insertion_point(class_scope:COWA.MapData.LaneTide.Item.Time)
 private:
  void set_has_start_time();
  void clear_has_start_time();
  void set_has_end_time();
  void clear_has_end_time();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float start_time_;
  float end_time_;
  friend struct protobuf_hdmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LaneTide_Item : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.MapData.LaneTide.Item) */ {
 public:
  LaneTide_Item();
  virtual ~LaneTide_Item();

  LaneTide_Item(const LaneTide_Item& from);

  inline LaneTide_Item& operator=(const LaneTide_Item& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneTide_Item& default_instance();

  static inline const LaneTide_Item* internal_default_instance() {
    return reinterpret_cast<const LaneTide_Item*>(
               &_LaneTide_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(LaneTide_Item* other);

  // implements Message ----------------------------------------------

  inline LaneTide_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  LaneTide_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LaneTide_Item& from);
  void MergeFrom(const LaneTide_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LaneTide_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef LaneTide_Item_Time Time;

  // accessors -------------------------------------------------------

  // repeated .COWA.MapData.Id lane_id = 1;
  int lane_id_size() const;
  void clear_lane_id();
  static const int kLaneIdFieldNumber = 1;
  const ::COWA::MapData::Id& lane_id(int index) const;
  ::COWA::MapData::Id* mutable_lane_id(int index);
  ::COWA::MapData::Id* add_lane_id();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >*
      mutable_lane_id();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >&
      lane_id() const;

  // repeated .COWA.MapData.LaneTide.Item.Time time = 2;
  int time_size() const;
  void clear_time();
  static const int kTimeFieldNumber = 2;
  const ::COWA::MapData::LaneTide_Item_Time& time(int index) const;
  ::COWA::MapData::LaneTide_Item_Time* mutable_time(int index);
  ::COWA::MapData::LaneTide_Item_Time* add_time();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::LaneTide_Item_Time >*
      mutable_time();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::LaneTide_Item_Time >&
      time() const;

  // @@protoc_insertion_point(class_scope:COWA.MapData.LaneTide.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id > lane_id_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::LaneTide_Item_Time > time_;
  friend struct protobuf_hdmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LaneTide : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.MapData.LaneTide) */ {
 public:
  LaneTide();
  virtual ~LaneTide();

  LaneTide(const LaneTide& from);

  inline LaneTide& operator=(const LaneTide& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneTide& default_instance();

  static inline const LaneTide* internal_default_instance() {
    return reinterpret_cast<const LaneTide*>(
               &_LaneTide_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(LaneTide* other);

  // implements Message ----------------------------------------------

  inline LaneTide* New() const PROTOBUF_FINAL { return New(NULL); }

  LaneTide* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LaneTide& from);
  void MergeFrom(const LaneTide& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LaneTide* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef LaneTide_Item Item;

  // accessors -------------------------------------------------------

  // repeated .COWA.MapData.Id signal = 5;
  int signal_size() const;
  void clear_signal();
  static const int kSignalFieldNumber = 5;
  const ::COWA::MapData::Id& signal(int index) const;
  ::COWA::MapData::Id* mutable_signal(int index);
  ::COWA::MapData::Id* add_signal();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >*
      mutable_signal();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >&
      signal() const;

  // optional .COWA.MapData.Id id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::COWA::MapData::Id& id() const;
  ::COWA::MapData::Id* mutable_id();
  ::COWA::MapData::Id* release_id();
  void set_allocated_id(::COWA::MapData::Id* id);

  // optional .COWA.MapData.LaneTide.Item a = 2;
  bool has_a() const;
  void clear_a();
  static const int kAFieldNumber = 2;
  const ::COWA::MapData::LaneTide_Item& a() const;
  ::COWA::MapData::LaneTide_Item* mutable_a();
  ::COWA::MapData::LaneTide_Item* release_a();
  void set_allocated_a(::COWA::MapData::LaneTide_Item* a);

  // optional .COWA.MapData.LaneTide.Item b = 3;
  bool has_b() const;
  void clear_b();
  static const int kBFieldNumber = 3;
  const ::COWA::MapData::LaneTide_Item& b() const;
  ::COWA::MapData::LaneTide_Item* mutable_b();
  ::COWA::MapData::LaneTide_Item* release_b();
  void set_allocated_b(::COWA::MapData::LaneTide_Item* b);

  // @@protoc_insertion_point(class_scope:COWA.MapData.LaneTide)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_a();
  void clear_has_a();
  void set_has_b();
  void clear_has_b();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id > signal_;
  ::COWA::MapData::Id* id_;
  ::COWA::MapData::LaneTide_Item* a_;
  ::COWA::MapData::LaneTide_Item* b_;
  friend struct protobuf_hdmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Road : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.MapData.Road) */ {
 public:
  Road();
  virtual ~Road();

  Road(const Road& from);

  inline Road& operator=(const Road& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Road& default_instance();

  static inline const Road* internal_default_instance() {
    return reinterpret_cast<const Road*>(
               &_Road_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(Road* other);

  // implements Message ----------------------------------------------

  inline Road* New() const PROTOBUF_FINAL { return New(NULL); }

  Road* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Road& from);
  void MergeFrom(const Road& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Road* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Road_RoadType RoadType;
  static const RoadType NONE =
    Road_RoadType_NONE;
  static const RoadType CITY_DRIVING =
    Road_RoadType_CITY_DRIVING;
  static const RoadType VIADUCT =
    Road_RoadType_VIADUCT;
  static const RoadType EXPRESSWAY =
    Road_RoadType_EXPRESSWAY;
  static const RoadType TUNNEL =
    Road_RoadType_TUNNEL;
  static inline bool RoadType_IsValid(int value) {
    return Road_RoadType_IsValid(value);
  }
  static const RoadType RoadType_MIN =
    Road_RoadType_RoadType_MIN;
  static const RoadType RoadType_MAX =
    Road_RoadType_RoadType_MAX;
  static const int RoadType_ARRAYSIZE =
    Road_RoadType_RoadType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RoadType_descriptor() {
    return Road_RoadType_descriptor();
  }
  static inline const ::std::string& RoadType_Name(RoadType value) {
    return Road_RoadType_Name(value);
  }
  static inline bool RoadType_Parse(const ::std::string& name,
      RoadType* value) {
    return Road_RoadType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .COWA.MapData.Id lane_id_a = 3;
  int lane_id_a_size() const;
  void clear_lane_id_a();
  static const int kLaneIdAFieldNumber = 3;
  const ::COWA::MapData::Id& lane_id_a(int index) const;
  ::COWA::MapData::Id* mutable_lane_id_a(int index);
  ::COWA::MapData::Id* add_lane_id_a();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >*
      mutable_lane_id_a();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >&
      lane_id_a() const;

  // repeated .COWA.MapData.Id lane_id_b = 4;
  int lane_id_b_size() const;
  void clear_lane_id_b();
  static const int kLaneIdBFieldNumber = 4;
  const ::COWA::MapData::Id& lane_id_b(int index) const;
  ::COWA::MapData::Id* mutable_lane_id_b(int index);
  ::COWA::MapData::Id* add_lane_id_b();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >*
      mutable_lane_id_b();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >&
      lane_id_b() const;

  // optional .COWA.MapData.Id id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::COWA::MapData::Id& id() const;
  ::COWA::MapData::Id* mutable_id();
  ::COWA::MapData::Id* release_id();
  void set_allocated_id(::COWA::MapData::Id* id);

  // optional .COWA.MapData.LaneCurve boundary = 5;
  bool has_boundary() const;
  void clear_boundary();
  static const int kBoundaryFieldNumber = 5;
  const ::COWA::MapData::LaneCurve& boundary() const;
  ::COWA::MapData::LaneCurve* mutable_boundary();
  ::COWA::MapData::LaneCurve* release_boundary();
  void set_allocated_boundary(::COWA::MapData::LaneCurve* boundary);

  // optional .COWA.MapData.Road.RoadType type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::COWA::MapData::Road_RoadType type() const;
  void set_type(::COWA::MapData::Road_RoadType value);

  // @@protoc_insertion_point(class_scope:COWA.MapData.Road)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_type();
  void clear_has_type();
  void set_has_boundary();
  void clear_has_boundary();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id > lane_id_a_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id > lane_id_b_;
  ::COWA::MapData::Id* id_;
  ::COWA::MapData::LaneCurve* boundary_;
  int type_;
  friend struct protobuf_hdmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Square : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.MapData.Square) */ {
 public:
  Square();
  virtual ~Square();

  Square(const Square& from);

  inline Square& operator=(const Square& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Square& default_instance();

  static inline const Square* internal_default_instance() {
    return reinterpret_cast<const Square*>(
               &_Square_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(Square* other);

  // implements Message ----------------------------------------------

  inline Square* New() const PROTOBUF_FINAL { return New(NULL); }

  Square* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Square& from);
  void MergeFrom(const Square& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Square* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .COWA.MapData.Id id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::COWA::MapData::Id& id() const;
  ::COWA::MapData::Id* mutable_id();
  ::COWA::MapData::Id* release_id();
  void set_allocated_id(::COWA::MapData::Id* id);

  // optional .COWA.MapData.Polygon polygon = 3;
  bool has_polygon() const;
  void clear_polygon();
  static const int kPolygonFieldNumber = 3;
  const ::COWA::MapData::Polygon& polygon() const;
  ::COWA::MapData::Polygon* mutable_polygon();
  ::COWA::MapData::Polygon* release_polygon();
  void set_allocated_polygon(::COWA::MapData::Polygon* polygon);

  // @@protoc_insertion_point(class_scope:COWA.MapData.Square)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_polygon();
  void clear_has_polygon();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::COWA::MapData::Id* id_;
  ::COWA::MapData::Polygon* polygon_;
  friend struct protobuf_hdmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Ramp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.MapData.Ramp) */ {
 public:
  Ramp();
  virtual ~Ramp();

  Ramp(const Ramp& from);

  inline Ramp& operator=(const Ramp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ramp& default_instance();

  static inline const Ramp* internal_default_instance() {
    return reinterpret_cast<const Ramp*>(
               &_Ramp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(Ramp* other);

  // implements Message ----------------------------------------------

  inline Ramp* New() const PROTOBUF_FINAL { return New(NULL); }

  Ramp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Ramp& from);
  void MergeFrom(const Ramp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Ramp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .COWA.MapData.Id id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::COWA::MapData::Id& id() const;
  ::COWA::MapData::Id* mutable_id();
  ::COWA::MapData::Id* release_id();
  void set_allocated_id(::COWA::MapData::Id* id);

  // optional .COWA.MapData.Polygon polygon = 2;
  bool has_polygon() const;
  void clear_polygon();
  static const int kPolygonFieldNumber = 2;
  const ::COWA::MapData::Polygon& polygon() const;
  ::COWA::MapData::Polygon* mutable_polygon();
  ::COWA::MapData::Polygon* release_polygon();
  void set_allocated_polygon(::COWA::MapData::Polygon* polygon);

  // optional float oriention = 3;
  bool has_oriention() const;
  void clear_oriention();
  static const int kOrientionFieldNumber = 3;
  float oriention() const;
  void set_oriention(float value);

  // @@protoc_insertion_point(class_scope:COWA.MapData.Ramp)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_polygon();
  void clear_has_polygon();
  void set_has_oriention();
  void clear_has_oriention();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::COWA::MapData::Id* id_;
  ::COWA::MapData::Polygon* polygon_;
  float oriention_;
  friend struct protobuf_hdmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Crosswalk : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.MapData.Crosswalk) */ {
 public:
  Crosswalk();
  virtual ~Crosswalk();

  Crosswalk(const Crosswalk& from);

  inline Crosswalk& operator=(const Crosswalk& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Crosswalk& default_instance();

  static inline const Crosswalk* internal_default_instance() {
    return reinterpret_cast<const Crosswalk*>(
               &_Crosswalk_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(Crosswalk* other);

  // implements Message ----------------------------------------------

  inline Crosswalk* New() const PROTOBUF_FINAL { return New(NULL); }

  Crosswalk* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Crosswalk& from);
  void MergeFrom(const Crosswalk& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Crosswalk* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .COWA.MapData.Id id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::COWA::MapData::Id& id() const;
  ::COWA::MapData::Id* mutable_id();
  ::COWA::MapData::Id* release_id();
  void set_allocated_id(::COWA::MapData::Id* id);

  // optional .COWA.MapData.Polygon polygon = 2;
  bool has_polygon() const;
  void clear_polygon();
  static const int kPolygonFieldNumber = 2;
  const ::COWA::MapData::Polygon& polygon() const;
  ::COWA::MapData::Polygon* mutable_polygon();
  ::COWA::MapData::Polygon* release_polygon();
  void set_allocated_polygon(::COWA::MapData::Polygon* polygon);

  // optional float oriention = 3;
  bool has_oriention() const;
  void clear_oriention();
  static const int kOrientionFieldNumber = 3;
  float oriention() const;
  void set_oriention(float value);

  // optional bool hybrid = 4;
  bool has_hybrid() const;
  void clear_hybrid();
  static const int kHybridFieldNumber = 4;
  bool hybrid() const;
  void set_hybrid(bool value);

  // @@protoc_insertion_point(class_scope:COWA.MapData.Crosswalk)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_polygon();
  void clear_has_polygon();
  void set_has_oriention();
  void clear_has_oriention();
  void set_has_hybrid();
  void clear_has_hybrid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::COWA::MapData::Id* id_;
  ::COWA::MapData::Polygon* polygon_;
  float oriention_;
  bool hybrid_;
  friend struct protobuf_hdmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Roadmark : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.MapData.Roadmark) */ {
 public:
  Roadmark();
  virtual ~Roadmark();

  Roadmark(const Roadmark& from);

  inline Roadmark& operator=(const Roadmark& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Roadmark& default_instance();

  static inline const Roadmark* internal_default_instance() {
    return reinterpret_cast<const Roadmark*>(
               &_Roadmark_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(Roadmark* other);

  // implements Message ----------------------------------------------

  inline Roadmark* New() const PROTOBUF_FINAL { return New(NULL); }

  Roadmark* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Roadmark& from);
  void MergeFrom(const Roadmark& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Roadmark* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Roadmark_RoadmarkType RoadmarkType;
  static const RoadmarkType NONE =
    Roadmark_RoadmarkType_NONE;
  static const RoadmarkType SPEEDBUMP =
    Roadmark_RoadmarkType_SPEEDBUMP;
  static const RoadmarkType STOPLINE =
    Roadmark_RoadmarkType_STOPLINE;
  static const RoadmarkType YEILDLINE =
    Roadmark_RoadmarkType_YEILDLINE;
  static const RoadmarkType TEXT =
    Roadmark_RoadmarkType_TEXT;
  static const RoadmarkType CLEARAREA =
    Roadmark_RoadmarkType_CLEARAREA;
  static inline bool RoadmarkType_IsValid(int value) {
    return Roadmark_RoadmarkType_IsValid(value);
  }
  static const RoadmarkType RoadmarkType_MIN =
    Roadmark_RoadmarkType_RoadmarkType_MIN;
  static const RoadmarkType RoadmarkType_MAX =
    Roadmark_RoadmarkType_RoadmarkType_MAX;
  static const int RoadmarkType_ARRAYSIZE =
    Roadmark_RoadmarkType_RoadmarkType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RoadmarkType_descriptor() {
    return Roadmark_RoadmarkType_descriptor();
  }
  static inline const ::std::string& RoadmarkType_Name(RoadmarkType value) {
    return Roadmark_RoadmarkType_Name(value);
  }
  static inline bool RoadmarkType_Parse(const ::std::string& name,
      RoadmarkType* value) {
    return Roadmark_RoadmarkType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .COWA.MapData.Id id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::COWA::MapData::Id& id() const;
  ::COWA::MapData::Id* mutable_id();
  ::COWA::MapData::Id* release_id();
  void set_allocated_id(::COWA::MapData::Id* id);

  // optional .COWA.MapData.Polygon polygon = 2;
  bool has_polygon() const;
  void clear_polygon();
  static const int kPolygonFieldNumber = 2;
  const ::COWA::MapData::Polygon& polygon() const;
  ::COWA::MapData::Polygon* mutable_polygon();
  ::COWA::MapData::Polygon* release_polygon();
  void set_allocated_polygon(::COWA::MapData::Polygon* polygon);

  // optional .COWA.MapData.Roadmark.RoadmarkType type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::COWA::MapData::Roadmark_RoadmarkType type() const;
  void set_type(::COWA::MapData::Roadmark_RoadmarkType value);

  // @@protoc_insertion_point(class_scope:COWA.MapData.Roadmark)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_polygon();
  void clear_has_polygon();
  void set_has_type();
  void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::COWA::MapData::Id* id_;
  ::COWA::MapData::Polygon* polygon_;
  int type_;
  friend struct protobuf_hdmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ParkingSpace : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.MapData.ParkingSpace) */ {
 public:
  ParkingSpace();
  virtual ~ParkingSpace();

  ParkingSpace(const ParkingSpace& from);

  inline ParkingSpace& operator=(const ParkingSpace& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParkingSpace& default_instance();

  static inline const ParkingSpace* internal_default_instance() {
    return reinterpret_cast<const ParkingSpace*>(
               &_ParkingSpace_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(ParkingSpace* other);

  // implements Message ----------------------------------------------

  inline ParkingSpace* New() const PROTOBUF_FINAL { return New(NULL); }

  ParkingSpace* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ParkingSpace& from);
  void MergeFrom(const ParkingSpace& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ParkingSpace* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .COWA.MapData.Id id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::COWA::MapData::Id& id() const;
  ::COWA::MapData::Id* mutable_id();
  ::COWA::MapData::Id* release_id();
  void set_allocated_id(::COWA::MapData::Id* id);

  // optional .COWA.MapData.Polygon polygon = 2;
  bool has_polygon() const;
  void clear_polygon();
  static const int kPolygonFieldNumber = 2;
  const ::COWA::MapData::Polygon& polygon() const;
  ::COWA::MapData::Polygon* mutable_polygon();
  ::COWA::MapData::Polygon* release_polygon();
  void set_allocated_polygon(::COWA::MapData::Polygon* polygon);

  // optional .COWA.MapData.Polygon boundary = 3;
  bool has_boundary() const;
  void clear_boundary();
  static const int kBoundaryFieldNumber = 3;
  const ::COWA::MapData::Polygon& boundary() const;
  ::COWA::MapData::Polygon* mutable_boundary();
  ::COWA::MapData::Polygon* release_boundary();
  void set_allocated_boundary(::COWA::MapData::Polygon* boundary);

  // optional float oriention = 4;
  bool has_oriention() const;
  void clear_oriention();
  static const int kOrientionFieldNumber = 4;
  float oriention() const;
  void set_oriention(float value);

  // @@protoc_insertion_point(class_scope:COWA.MapData.ParkingSpace)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_polygon();
  void clear_has_polygon();
  void set_has_boundary();
  void clear_has_boundary();
  void set_has_oriention();
  void clear_has_oriention();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::COWA::MapData::Id* id_;
  ::COWA::MapData::Polygon* polygon_;
  ::COWA::MapData::Polygon* boundary_;
  float oriention_;
  friend struct protobuf_hdmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Object : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.MapData.Object) */ {
 public:
  Object();
  virtual ~Object();

  Object(const Object& from);

  inline Object& operator=(const Object& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Object& default_instance();

  static inline const Object* internal_default_instance() {
    return reinterpret_cast<const Object*>(
               &_Object_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(Object* other);

  // implements Message ----------------------------------------------

  inline Object* New() const PROTOBUF_FINAL { return New(NULL); }

  Object* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Object& from);
  void MergeFrom(const Object& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Object* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Object_Type Type;
  static const Type TREE_TRUNK =
    Object_Type_TREE_TRUNK;
  static const Type POLE =
    Object_Type_POLE;
  static const Type PILES =
    Object_Type_PILES;
  static const Type DUSTBIN =
    Object_Type_DUSTBIN;
  static const Type BLOCK =
    Object_Type_BLOCK;
  static const Type BUILDING =
    Object_Type_BUILDING;
  static const Type CURB =
    Object_Type_CURB;
  static const Type LANE_SOLID =
    Object_Type_LANE_SOLID;
  static const Type LANE_DOTTED =
    Object_Type_LANE_DOTTED;
  static const Type STOPLINE =
    Object_Type_STOPLINE;
  static const Type CROSSWALK =
    Object_Type_CROSSWALK;
  static const Type ARROW =
    Object_Type_ARROW;
  static const Type HIGH_REFLECTIVITY =
    Object_Type_HIGH_REFLECTIVITY;
  static inline bool Type_IsValid(int value) {
    return Object_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Object_Type_Type_MIN;
  static const Type Type_MAX =
    Object_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Object_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Object_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Object_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Object_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .COWA.MapData.Id id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::COWA::MapData::Id& id() const;
  ::COWA::MapData::Id* mutable_id();
  ::COWA::MapData::Id* release_id();
  void set_allocated_id(::COWA::MapData::Id* id);

  // optional .COWA.MapData.Polygon polygon = 3;
  bool has_polygon() const;
  void clear_polygon();
  static const int kPolygonFieldNumber = 3;
  const ::COWA::MapData::Polygon& polygon() const;
  ::COWA::MapData::Polygon* mutable_polygon();
  ::COWA::MapData::Polygon* release_polygon();
  void set_allocated_polygon(::COWA::MapData::Polygon* polygon);

  // optional .COWA.MapData.Cloud cloud = 4;
  bool has_cloud() const;
  void clear_cloud();
  static const int kCloudFieldNumber = 4;
  const ::COWA::MapData::Cloud& cloud() const;
  ::COWA::MapData::Cloud* mutable_cloud();
  ::COWA::MapData::Cloud* release_cloud();
  void set_allocated_cloud(::COWA::MapData::Cloud* cloud);

  // optional .COWA.MapData.Object.Type type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::COWA::MapData::Object_Type type() const;
  void set_type(::COWA::MapData::Object_Type value);

  // @@protoc_insertion_point(class_scope:COWA.MapData.Object)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_type();
  void clear_has_type();
  void set_has_polygon();
  void clear_has_polygon();
  void set_has_cloud();
  void clear_has_cloud();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::COWA::MapData::Id* id_;
  ::COWA::MapData::Polygon* polygon_;
  ::COWA::MapData::Cloud* cloud_;
  int type_;
  friend struct protobuf_hdmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Subsignal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.MapData.Subsignal) */ {
 public:
  Subsignal();
  virtual ~Subsignal();

  Subsignal(const Subsignal& from);

  inline Subsignal& operator=(const Subsignal& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Subsignal& default_instance();

  static inline const Subsignal* internal_default_instance() {
    return reinterpret_cast<const Subsignal*>(
               &_Subsignal_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(Subsignal* other);

  // implements Message ----------------------------------------------

  inline Subsignal* New() const PROTOBUF_FINAL { return New(NULL); }

  Subsignal* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Subsignal& from);
  void MergeFrom(const Subsignal& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Subsignal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Subsignal_Type Type;
  static const Type UNKNOWN =
    Subsignal_Type_UNKNOWN;
  static const Type MIX_2_HORIZONTAL =
    Subsignal_Type_MIX_2_HORIZONTAL;
  static const Type MIX_2_VERTICAL =
    Subsignal_Type_MIX_2_VERTICAL;
  static const Type MIX_3_HORIZONTAL =
    Subsignal_Type_MIX_3_HORIZONTAL;
  static const Type MIX_3_VERTICAL =
    Subsignal_Type_MIX_3_VERTICAL;
  static const Type SINGLE =
    Subsignal_Type_SINGLE;
  static const Type LED_SCREEN =
    Subsignal_Type_LED_SCREEN;
  static inline bool Type_IsValid(int value) {
    return Subsignal_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Subsignal_Type_Type_MIN;
  static const Type Type_MAX =
    Subsignal_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Subsignal_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Subsignal_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Subsignal_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Subsignal_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .COWA.MapData.Id id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::COWA::MapData::Id& id() const;
  ::COWA::MapData::Id* mutable_id();
  ::COWA::MapData::Id* release_id();
  void set_allocated_id(::COWA::MapData::Id* id);

  // optional .COWA.MapData.Polygon boundary = 3;
  bool has_boundary() const;
  void clear_boundary();
  static const int kBoundaryFieldNumber = 3;
  const ::COWA::MapData::Polygon& boundary() const;
  ::COWA::MapData::Polygon* mutable_boundary();
  ::COWA::MapData::Polygon* release_boundary();
  void set_allocated_boundary(::COWA::MapData::Polygon* boundary);

  // optional .COWA.MapData.Subsignal.Type type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::COWA::MapData::Subsignal_Type type() const;
  void set_type(::COWA::MapData::Subsignal_Type value);

  // @@protoc_insertion_point(class_scope:COWA.MapData.Subsignal)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_type();
  void clear_has_type();
  void set_has_boundary();
  void clear_has_boundary();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::COWA::MapData::Id* id_;
  ::COWA::MapData::Polygon* boundary_;
  int type_;
  friend struct protobuf_hdmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Signal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.MapData.Signal) */ {
 public:
  Signal();
  virtual ~Signal();

  Signal(const Signal& from);

  inline Signal& operator=(const Signal& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Signal& default_instance();

  static inline const Signal* internal_default_instance() {
    return reinterpret_cast<const Signal*>(
               &_Signal_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(Signal* other);

  // implements Message ----------------------------------------------

  inline Signal* New() const PROTOBUF_FINAL { return New(NULL); }

  Signal* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Signal& from);
  void MergeFrom(const Signal& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Signal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Signal_Type Type;
  static const Type UNKNOWN =
    Signal_Type_UNKNOWN;
  static const Type FOWARD =
    Signal_Type_FOWARD;
  static const Type LEFT =
    Signal_Type_LEFT;
  static const Type RIGHT =
    Signal_Type_RIGHT;
  static const Type UTURN =
    Signal_Type_UTURN;
  static const Type TIDE =
    Signal_Type_TIDE;
  static inline bool Type_IsValid(int value) {
    return Signal_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Signal_Type_Type_MIN;
  static const Type Type_MAX =
    Signal_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Signal_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Signal_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Signal_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Signal_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .COWA.MapData.Signal.Type type = 2;
  int type_size() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::COWA::MapData::Signal_Type type(int index) const;
  void set_type(int index, ::COWA::MapData::Signal_Type value);
  void add_type(::COWA::MapData::Signal_Type value);
  const ::google::protobuf::RepeatedField<int>& type() const;
  ::google::protobuf::RepeatedField<int>* mutable_type();

  // repeated .COWA.MapData.Subsignal subsignal = 3;
  int subsignal_size() const;
  void clear_subsignal();
  static const int kSubsignalFieldNumber = 3;
  const ::COWA::MapData::Subsignal& subsignal(int index) const;
  ::COWA::MapData::Subsignal* mutable_subsignal(int index);
  ::COWA::MapData::Subsignal* add_subsignal();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Subsignal >*
      mutable_subsignal();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Subsignal >&
      subsignal() const;

  // repeated .COWA.MapData.PointENU stop_line = 5;
  int stop_line_size() const;
  void clear_stop_line();
  static const int kStopLineFieldNumber = 5;
  const ::COWA::MapData::PointENU& stop_line(int index) const;
  ::COWA::MapData::PointENU* mutable_stop_line(int index);
  ::COWA::MapData::PointENU* add_stop_line();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::PointENU >*
      mutable_stop_line();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::PointENU >&
      stop_line() const;

  // repeated .COWA.MapData.Id wait_lane = 6;
  int wait_lane_size() const;
  void clear_wait_lane();
  static const int kWaitLaneFieldNumber = 6;
  const ::COWA::MapData::Id& wait_lane(int index) const;
  ::COWA::MapData::Id* mutable_wait_lane(int index);
  ::COWA::MapData::Id* add_wait_lane();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >*
      mutable_wait_lane();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >&
      wait_lane() const;

  // optional .COWA.MapData.Id id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::COWA::MapData::Id& id() const;
  ::COWA::MapData::Id* mutable_id();
  ::COWA::MapData::Id* release_id();
  void set_allocated_id(::COWA::MapData::Id* id);

  // optional .COWA.MapData.Id wait_signal = 7;
  bool has_wait_signal() const;
  void clear_wait_signal();
  static const int kWaitSignalFieldNumber = 7;
  const ::COWA::MapData::Id& wait_signal() const;
  ::COWA::MapData::Id* mutable_wait_signal();
  ::COWA::MapData::Id* release_wait_signal();
  void set_allocated_wait_signal(::COWA::MapData::Id* wait_signal);

  // @@protoc_insertion_point(class_scope:COWA.MapData.Signal)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_wait_signal();
  void clear_has_wait_signal();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> type_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Subsignal > subsignal_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::PointENU > stop_line_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id > wait_lane_;
  ::COWA::MapData::Id* id_;
  ::COWA::MapData::Id* wait_signal_;
  friend struct protobuf_hdmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Crossroad_Line : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.MapData.Crossroad.Line) */ {
 public:
  Crossroad_Line();
  virtual ~Crossroad_Line();

  Crossroad_Line(const Crossroad_Line& from);

  inline Crossroad_Line& operator=(const Crossroad_Line& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Crossroad_Line& default_instance();

  static inline const Crossroad_Line* internal_default_instance() {
    return reinterpret_cast<const Crossroad_Line*>(
               &_Crossroad_Line_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(Crossroad_Line* other);

  // implements Message ----------------------------------------------

  inline Crossroad_Line* New() const PROTOBUF_FINAL { return New(NULL); }

  Crossroad_Line* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Crossroad_Line& from);
  void MergeFrom(const Crossroad_Line& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Crossroad_Line* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .COWA.MapData.Id signals = 1;
  int signals_size() const;
  void clear_signals();
  static const int kSignalsFieldNumber = 1;
  const ::COWA::MapData::Id& signals(int index) const;
  ::COWA::MapData::Id* mutable_signals(int index);
  ::COWA::MapData::Id* add_signals();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >*
      mutable_signals();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >&
      signals() const;

  // repeated .COWA.MapData.Id lane_in = 2;
  int lane_in_size() const;
  void clear_lane_in();
  static const int kLaneInFieldNumber = 2;
  const ::COWA::MapData::Id& lane_in(int index) const;
  ::COWA::MapData::Id* mutable_lane_in(int index);
  ::COWA::MapData::Id* add_lane_in();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >*
      mutable_lane_in();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >&
      lane_in() const;

  // repeated .COWA.MapData.Id lane_out = 3;
  int lane_out_size() const;
  void clear_lane_out();
  static const int kLaneOutFieldNumber = 3;
  const ::COWA::MapData::Id& lane_out(int index) const;
  ::COWA::MapData::Id* mutable_lane_out(int index);
  ::COWA::MapData::Id* add_lane_out();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >*
      mutable_lane_out();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >&
      lane_out() const;

  // repeated .COWA.MapData.Id road = 4;
  int road_size() const;
  void clear_road();
  static const int kRoadFieldNumber = 4;
  const ::COWA::MapData::Id& road(int index) const;
  ::COWA::MapData::Id* mutable_road(int index);
  ::COWA::MapData::Id* add_road();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >*
      mutable_road();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >&
      road() const;

  // @@protoc_insertion_point(class_scope:COWA.MapData.Crossroad.Line)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id > signals_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id > lane_in_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id > lane_out_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id > road_;
  friend struct protobuf_hdmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Crossroad : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.MapData.Crossroad) */ {
 public:
  Crossroad();
  virtual ~Crossroad();

  Crossroad(const Crossroad& from);

  inline Crossroad& operator=(const Crossroad& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Crossroad& default_instance();

  static inline const Crossroad* internal_default_instance() {
    return reinterpret_cast<const Crossroad*>(
               &_Crossroad_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(Crossroad* other);

  // implements Message ----------------------------------------------

  inline Crossroad* New() const PROTOBUF_FINAL { return New(NULL); }

  Crossroad* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Crossroad& from);
  void MergeFrom(const Crossroad& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Crossroad* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Crossroad_Line Line;

  typedef Crossroad_Type Type;
  static const Type CROSS =
    Crossroad_Type_CROSS;
  static const Type INTERSECTION =
    Crossroad_Type_INTERSECTION;
  static inline bool Type_IsValid(int value) {
    return Crossroad_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Crossroad_Type_Type_MIN;
  static const Type Type_MAX =
    Crossroad_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Crossroad_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Crossroad_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Crossroad_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Crossroad_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .COWA.MapData.Crossroad.Line group = 2;
  int group_size() const;
  void clear_group();
  static const int kGroupFieldNumber = 2;
  const ::COWA::MapData::Crossroad_Line& group(int index) const;
  ::COWA::MapData::Crossroad_Line* mutable_group(int index);
  ::COWA::MapData::Crossroad_Line* add_group();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Crossroad_Line >*
      mutable_group();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Crossroad_Line >&
      group() const;

  // optional .COWA.MapData.Id id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::COWA::MapData::Id& id() const;
  ::COWA::MapData::Id* mutable_id();
  ::COWA::MapData::Id* release_id();
  void set_allocated_id(::COWA::MapData::Id* id);

  // optional .COWA.MapData.Polygon boundary = 3;
  bool has_boundary() const;
  void clear_boundary();
  static const int kBoundaryFieldNumber = 3;
  const ::COWA::MapData::Polygon& boundary() const;
  ::COWA::MapData::Polygon* mutable_boundary();
  ::COWA::MapData::Polygon* release_boundary();
  void set_allocated_boundary(::COWA::MapData::Polygon* boundary);

  // optional .COWA.MapData.Crossroad.Type type = 4;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  ::COWA::MapData::Crossroad_Type type() const;
  void set_type(::COWA::MapData::Crossroad_Type value);

  // @@protoc_insertion_point(class_scope:COWA.MapData.Crossroad)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_boundary();
  void clear_has_boundary();
  void set_has_type();
  void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Crossroad_Line > group_;
  ::COWA::MapData::Id* id_;
  ::COWA::MapData::Polygon* boundary_;
  int type_;
  friend struct protobuf_hdmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LaneChange : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.MapData.LaneChange) */ {
 public:
  LaneChange();
  virtual ~LaneChange();

  LaneChange(const LaneChange& from);

  inline LaneChange& operator=(const LaneChange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneChange& default_instance();

  static inline const LaneChange* internal_default_instance() {
    return reinterpret_cast<const LaneChange*>(
               &_LaneChange_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(LaneChange* other);

  // implements Message ----------------------------------------------

  inline LaneChange* New() const PROTOBUF_FINAL { return New(NULL); }

  LaneChange* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LaneChange& from);
  void MergeFrom(const LaneChange& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LaneChange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .COWA.MapData.Id lane_in = 2;
  int lane_in_size() const;
  void clear_lane_in();
  static const int kLaneInFieldNumber = 2;
  const ::COWA::MapData::Id& lane_in(int index) const;
  ::COWA::MapData::Id* mutable_lane_in(int index);
  ::COWA::MapData::Id* add_lane_in();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >*
      mutable_lane_in();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >&
      lane_in() const;

  // repeated .COWA.MapData.Id lane_out = 3;
  int lane_out_size() const;
  void clear_lane_out();
  static const int kLaneOutFieldNumber = 3;
  const ::COWA::MapData::Id& lane_out(int index) const;
  ::COWA::MapData::Id* mutable_lane_out(int index);
  ::COWA::MapData::Id* add_lane_out();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >*
      mutable_lane_out();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >&
      lane_out() const;

  // optional .COWA.MapData.Id id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::COWA::MapData::Id& id() const;
  ::COWA::MapData::Id* mutable_id();
  ::COWA::MapData::Id* release_id();
  void set_allocated_id(::COWA::MapData::Id* id);

  // optional .COWA.MapData.Polygon boundary = 4;
  bool has_boundary() const;
  void clear_boundary();
  static const int kBoundaryFieldNumber = 4;
  const ::COWA::MapData::Polygon& boundary() const;
  ::COWA::MapData::Polygon* mutable_boundary();
  ::COWA::MapData::Polygon* release_boundary();
  void set_allocated_boundary(::COWA::MapData::Polygon* boundary);

  // @@protoc_insertion_point(class_scope:COWA.MapData.LaneChange)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_boundary();
  void clear_has_boundary();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id > lane_in_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id > lane_out_;
  ::COWA::MapData::Id* id_;
  ::COWA::MapData::Polygon* boundary_;
  friend struct protobuf_hdmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HdMap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COWA.MapData.HdMap) */ {
 public:
  HdMap();
  virtual ~HdMap();

  HdMap(const HdMap& from);

  inline HdMap& operator=(const HdMap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HdMap& default_instance();

  static inline const HdMap* internal_default_instance() {
    return reinterpret_cast<const HdMap*>(
               &_HdMap_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(HdMap* other);

  // implements Message ----------------------------------------------

  inline HdMap* New() const PROTOBUF_FINAL { return New(NULL); }

  HdMap* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HdMap& from);
  void MergeFrom(const HdMap& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HdMap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .COWA.MapData.Lane lane = 2;
  int lane_size() const;
  void clear_lane();
  static const int kLaneFieldNumber = 2;
  const ::COWA::MapData::Lane& lane(int index) const;
  ::COWA::MapData::Lane* mutable_lane(int index);
  ::COWA::MapData::Lane* add_lane();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Lane >*
      mutable_lane();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Lane >&
      lane() const;

  // repeated .COWA.MapData.Crosswalk crosswalk = 3;
  int crosswalk_size() const;
  void clear_crosswalk();
  static const int kCrosswalkFieldNumber = 3;
  const ::COWA::MapData::Crosswalk& crosswalk(int index) const;
  ::COWA::MapData::Crosswalk* mutable_crosswalk(int index);
  ::COWA::MapData::Crosswalk* add_crosswalk();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Crosswalk >*
      mutable_crosswalk();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Crosswalk >&
      crosswalk() const;

  // repeated .COWA.MapData.Signal signal = 4;
  int signal_size() const;
  void clear_signal();
  static const int kSignalFieldNumber = 4;
  const ::COWA::MapData::Signal& signal(int index) const;
  ::COWA::MapData::Signal* mutable_signal(int index);
  ::COWA::MapData::Signal* add_signal();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Signal >*
      mutable_signal();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Signal >&
      signal() const;

  // repeated .COWA.MapData.Crossroad crossroad = 5;
  int crossroad_size() const;
  void clear_crossroad();
  static const int kCrossroadFieldNumber = 5;
  const ::COWA::MapData::Crossroad& crossroad(int index) const;
  ::COWA::MapData::Crossroad* mutable_crossroad(int index);
  ::COWA::MapData::Crossroad* add_crossroad();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Crossroad >*
      mutable_crossroad();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Crossroad >&
      crossroad() const;

  // repeated .COWA.MapData.Ramp ramp = 6;
  int ramp_size() const;
  void clear_ramp();
  static const int kRampFieldNumber = 6;
  const ::COWA::MapData::Ramp& ramp(int index) const;
  ::COWA::MapData::Ramp* mutable_ramp(int index);
  ::COWA::MapData::Ramp* add_ramp();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Ramp >*
      mutable_ramp();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Ramp >&
      ramp() const;

  // repeated .COWA.MapData.Road road = 7;
  int road_size() const;
  void clear_road();
  static const int kRoadFieldNumber = 7;
  const ::COWA::MapData::Road& road(int index) const;
  ::COWA::MapData::Road* mutable_road(int index);
  ::COWA::MapData::Road* add_road();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Road >*
      mutable_road();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Road >&
      road() const;

  // repeated .COWA.MapData.Roadmark roadmark = 8;
  int roadmark_size() const;
  void clear_roadmark();
  static const int kRoadmarkFieldNumber = 8;
  const ::COWA::MapData::Roadmark& roadmark(int index) const;
  ::COWA::MapData::Roadmark* mutable_roadmark(int index);
  ::COWA::MapData::Roadmark* add_roadmark();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Roadmark >*
      mutable_roadmark();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Roadmark >&
      roadmark() const;

  // repeated .COWA.MapData.ParkingSpace parking_space = 9;
  int parking_space_size() const;
  void clear_parking_space();
  static const int kParkingSpaceFieldNumber = 9;
  const ::COWA::MapData::ParkingSpace& parking_space(int index) const;
  ::COWA::MapData::ParkingSpace* mutable_parking_space(int index);
  ::COWA::MapData::ParkingSpace* add_parking_space();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::ParkingSpace >*
      mutable_parking_space();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::ParkingSpace >&
      parking_space() const;

  // repeated .COWA.MapData.Overlap overlap = 10;
  int overlap_size() const;
  void clear_overlap();
  static const int kOverlapFieldNumber = 10;
  const ::COWA::MapData::Overlap& overlap(int index) const;
  ::COWA::MapData::Overlap* mutable_overlap(int index);
  ::COWA::MapData::Overlap* add_overlap();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Overlap >*
      mutable_overlap();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Overlap >&
      overlap() const;

  // repeated .COWA.MapData.LaneCurve lane_curve = 11;
  int lane_curve_size() const;
  void clear_lane_curve();
  static const int kLaneCurveFieldNumber = 11;
  const ::COWA::MapData::LaneCurve& lane_curve(int index) const;
  ::COWA::MapData::LaneCurve* mutable_lane_curve(int index);
  ::COWA::MapData::LaneCurve* add_lane_curve();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::LaneCurve >*
      mutable_lane_curve();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::LaneCurve >&
      lane_curve() const;

  // repeated .COWA.MapData.Object objects = 12;
  int objects_size() const;
  void clear_objects();
  static const int kObjectsFieldNumber = 12;
  const ::COWA::MapData::Object& objects(int index) const;
  ::COWA::MapData::Object* mutable_objects(int index);
  ::COWA::MapData::Object* add_objects();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Object >*
      mutable_objects();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Object >&
      objects() const;

  // repeated .COWA.MapData.LaneChange lane_change = 13;
  int lane_change_size() const;
  void clear_lane_change();
  static const int kLaneChangeFieldNumber = 13;
  const ::COWA::MapData::LaneChange& lane_change(int index) const;
  ::COWA::MapData::LaneChange* mutable_lane_change(int index);
  ::COWA::MapData::LaneChange* add_lane_change();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::LaneChange >*
      mutable_lane_change();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::LaneChange >&
      lane_change() const;

  // repeated .COWA.MapData.LaneTide tide = 14;
  int tide_size() const;
  void clear_tide();
  static const int kTideFieldNumber = 14;
  const ::COWA::MapData::LaneTide& tide(int index) const;
  ::COWA::MapData::LaneTide* mutable_tide(int index);
  ::COWA::MapData::LaneTide* add_tide();
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::LaneTide >*
      mutable_tide();
  const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::LaneTide >&
      tide() const;

  // optional .COWA.MapData.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::COWA::MapData::Header& header() const;
  ::COWA::MapData::Header* mutable_header();
  ::COWA::MapData::Header* release_header();
  void set_allocated_header(::COWA::MapData::Header* header);

  // @@protoc_insertion_point(class_scope:COWA.MapData.HdMap)
 private:
  void set_has_header();
  void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Lane > lane_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Crosswalk > crosswalk_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Signal > signal_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Crossroad > crossroad_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Ramp > ramp_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Road > road_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Roadmark > roadmark_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::ParkingSpace > parking_space_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Overlap > overlap_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::LaneCurve > lane_curve_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Object > objects_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::LaneChange > lane_change_;
  ::google::protobuf::RepeatedPtrField< ::COWA::MapData::LaneTide > tide_;
  ::COWA::MapData::Header* header_;
  friend struct protobuf_hdmap_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// LaneStrip

// optional float start_s = 1;
inline bool LaneStrip::has_start_s() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaneStrip::set_has_start_s() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LaneStrip::clear_has_start_s() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LaneStrip::clear_start_s() {
  start_s_ = 0;
  clear_has_start_s();
}
inline float LaneStrip::start_s() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.LaneStrip.start_s)
  return start_s_;
}
inline void LaneStrip::set_start_s(float value) {
  set_has_start_s();
  start_s_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.LaneStrip.start_s)
}

// optional float end_s = 2;
inline bool LaneStrip::has_end_s() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaneStrip::set_has_end_s() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LaneStrip::clear_has_end_s() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LaneStrip::clear_end_s() {
  end_s_ = 0;
  clear_has_end_s();
}
inline float LaneStrip::end_s() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.LaneStrip.end_s)
  return end_s_;
}
inline void LaneStrip::set_end_s(float value) {
  set_has_end_s();
  end_s_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.LaneStrip.end_s)
}

// optional float height = 3;
inline bool LaneStrip::has_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LaneStrip::set_has_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LaneStrip::clear_has_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LaneStrip::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline float LaneStrip::height() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.LaneStrip.height)
  return height_;
}
inline void LaneStrip::set_height(float value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.LaneStrip.height)
}

// -------------------------------------------------------------------

// LanePoint

// optional float x = 1;
inline bool LanePoint::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LanePoint::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LanePoint::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LanePoint::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float LanePoint::x() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.LanePoint.x)
  return x_;
}
inline void LanePoint::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.LanePoint.x)
}

// optional float y = 2;
inline bool LanePoint::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LanePoint::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LanePoint::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LanePoint::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float LanePoint::y() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.LanePoint.y)
  return y_;
}
inline void LanePoint::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.LanePoint.y)
}

// optional float z = 3;
inline bool LanePoint::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LanePoint::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LanePoint::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LanePoint::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float LanePoint::z() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.LanePoint.z)
  return z_;
}
inline void LanePoint::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.LanePoint.z)
}

// optional .COWA.MapData.LanePoint.Type type = 4;
inline bool LanePoint::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LanePoint::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LanePoint::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LanePoint::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::COWA::MapData::LanePoint_Type LanePoint::type() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.LanePoint.type)
  return static_cast< ::COWA::MapData::LanePoint_Type >(type_);
}
inline void LanePoint::set_type(::COWA::MapData::LanePoint_Type value) {
  assert(::COWA::MapData::LanePoint_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.LanePoint.type)
}

// optional float height = 5;
inline bool LanePoint::has_height() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LanePoint::set_has_height() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LanePoint::clear_has_height() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LanePoint::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline float LanePoint::height() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.LanePoint.height)
  return height_;
}
inline void LanePoint::set_height(float value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.LanePoint.height)
}

// -------------------------------------------------------------------

// LaneCurve

// optional .COWA.MapData.Id id = 2;
inline bool LaneCurve::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaneCurve::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LaneCurve::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LaneCurve::clear_id() {
  if (id_ != NULL) id_->::COWA::MapData::Id::Clear();
  clear_has_id();
}
inline const ::COWA::MapData::Id& LaneCurve::id() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.LaneCurve.id)
  return id_ != NULL ? *id_
                         : *::COWA::MapData::Id::internal_default_instance();
}
inline ::COWA::MapData::Id* LaneCurve::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    id_ = new ::COWA::MapData::Id;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.LaneCurve.id)
  return id_;
}
inline ::COWA::MapData::Id* LaneCurve::release_id() {
  // @@protoc_insertion_point(field_release:COWA.MapData.LaneCurve.id)
  clear_has_id();
  ::COWA::MapData::Id* temp = id_;
  id_ = NULL;
  return temp;
}
inline void LaneCurve::set_allocated_id(::COWA::MapData::Id* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.LaneCurve.id)
}

// repeated .COWA.MapData.LanePoint point = 1;
inline int LaneCurve::point_size() const {
  return point_.size();
}
inline void LaneCurve::clear_point() {
  point_.Clear();
}
inline const ::COWA::MapData::LanePoint& LaneCurve::point(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.LaneCurve.point)
  return point_.Get(index);
}
inline ::COWA::MapData::LanePoint* LaneCurve::mutable_point(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.LaneCurve.point)
  return point_.Mutable(index);
}
inline ::COWA::MapData::LanePoint* LaneCurve::add_point() {
  // @@protoc_insertion_point(field_add:COWA.MapData.LaneCurve.point)
  return point_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::LanePoint >*
LaneCurve::mutable_point() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.LaneCurve.point)
  return &point_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::LanePoint >&
LaneCurve::point() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.LaneCurve.point)
  return point_;
}

// optional double offset_x = 3;
inline bool LaneCurve::has_offset_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaneCurve::set_has_offset_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LaneCurve::clear_has_offset_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LaneCurve::clear_offset_x() {
  offset_x_ = 0;
  clear_has_offset_x();
}
inline double LaneCurve::offset_x() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.LaneCurve.offset_x)
  return offset_x_;
}
inline void LaneCurve::set_offset_x(double value) {
  set_has_offset_x();
  offset_x_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.LaneCurve.offset_x)
}

// optional double offset_y = 4;
inline bool LaneCurve::has_offset_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LaneCurve::set_has_offset_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LaneCurve::clear_has_offset_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LaneCurve::clear_offset_y() {
  offset_y_ = 0;
  clear_has_offset_y();
}
inline double LaneCurve::offset_y() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.LaneCurve.offset_y)
  return offset_y_;
}
inline void LaneCurve::set_offset_y(double value) {
  set_has_offset_y();
  offset_y_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.LaneCurve.offset_y)
}

// optional .COWA.MapData.LaneCurve.Type type = 5;
inline bool LaneCurve::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LaneCurve::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LaneCurve::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LaneCurve::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::COWA::MapData::LaneCurve_Type LaneCurve::type() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.LaneCurve.type)
  return static_cast< ::COWA::MapData::LaneCurve_Type >(type_);
}
inline void LaneCurve::set_type(::COWA::MapData::LaneCurve_Type value) {
  assert(::COWA::MapData::LaneCurve_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.LaneCurve.type)
}

// repeated .COWA.MapData.LaneStrip strip = 6;
inline int LaneCurve::strip_size() const {
  return strip_.size();
}
inline void LaneCurve::clear_strip() {
  strip_.Clear();
}
inline const ::COWA::MapData::LaneStrip& LaneCurve::strip(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.LaneCurve.strip)
  return strip_.Get(index);
}
inline ::COWA::MapData::LaneStrip* LaneCurve::mutable_strip(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.LaneCurve.strip)
  return strip_.Mutable(index);
}
inline ::COWA::MapData::LaneStrip* LaneCurve::add_strip() {
  // @@protoc_insertion_point(field_add:COWA.MapData.LaneCurve.strip)
  return strip_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::LaneStrip >*
LaneCurve::mutable_strip() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.LaneCurve.strip)
  return &strip_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::LaneStrip >&
LaneCurve::strip() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.LaneCurve.strip)
  return strip_;
}

// -------------------------------------------------------------------

// Lane_LaneMark

// optional .COWA.MapData.Lane.LaneMark.Type type = 1;
inline bool Lane_LaneMark::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Lane_LaneMark::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Lane_LaneMark::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Lane_LaneMark::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::COWA::MapData::Lane_LaneMark_Type Lane_LaneMark::type() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Lane.LaneMark.type)
  return static_cast< ::COWA::MapData::Lane_LaneMark_Type >(type_);
}
inline void Lane_LaneMark::set_type(::COWA::MapData::Lane_LaneMark_Type value) {
  assert(::COWA::MapData::Lane_LaneMark_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.Lane.LaneMark.type)
}

// optional .COWA.MapData.PointENU centroid = 2;
inline bool Lane_LaneMark::has_centroid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Lane_LaneMark::set_has_centroid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Lane_LaneMark::clear_has_centroid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Lane_LaneMark::clear_centroid() {
  if (centroid_ != NULL) centroid_->::COWA::MapData::PointENU::Clear();
  clear_has_centroid();
}
inline const ::COWA::MapData::PointENU& Lane_LaneMark::centroid() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Lane.LaneMark.centroid)
  return centroid_ != NULL ? *centroid_
                         : *::COWA::MapData::PointENU::internal_default_instance();
}
inline ::COWA::MapData::PointENU* Lane_LaneMark::mutable_centroid() {
  set_has_centroid();
  if (centroid_ == NULL) {
    centroid_ = new ::COWA::MapData::PointENU;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Lane.LaneMark.centroid)
  return centroid_;
}
inline ::COWA::MapData::PointENU* Lane_LaneMark::release_centroid() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Lane.LaneMark.centroid)
  clear_has_centroid();
  ::COWA::MapData::PointENU* temp = centroid_;
  centroid_ = NULL;
  return temp;
}
inline void Lane_LaneMark::set_allocated_centroid(::COWA::MapData::PointENU* centroid) {
  delete centroid_;
  centroid_ = centroid;
  if (centroid) {
    set_has_centroid();
  } else {
    clear_has_centroid();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Lane.LaneMark.centroid)
}

// optional string text = 3;
inline bool Lane_LaneMark::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Lane_LaneMark::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Lane_LaneMark::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Lane_LaneMark::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& Lane_LaneMark::text() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Lane.LaneMark.text)
  return text_.GetNoArena();
}
inline void Lane_LaneMark::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:COWA.MapData.Lane.LaneMark.text)
}
#if LANG_CXX11
inline void Lane_LaneMark::set_text(::std::string&& value) {
  set_has_text();
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:COWA.MapData.Lane.LaneMark.text)
}
#endif
inline void Lane_LaneMark::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:COWA.MapData.Lane.LaneMark.text)
}
inline void Lane_LaneMark::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:COWA.MapData.Lane.LaneMark.text)
}
inline ::std::string* Lane_LaneMark::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Lane.LaneMark.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Lane_LaneMark::release_text() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Lane.LaneMark.text)
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Lane_LaneMark::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Lane.LaneMark.text)
}

// optional .COWA.MapData.Polygon polygon = 4;
inline bool Lane_LaneMark::has_polygon() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Lane_LaneMark::set_has_polygon() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Lane_LaneMark::clear_has_polygon() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Lane_LaneMark::clear_polygon() {
  if (polygon_ != NULL) polygon_->::COWA::MapData::Polygon::Clear();
  clear_has_polygon();
}
inline const ::COWA::MapData::Polygon& Lane_LaneMark::polygon() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Lane.LaneMark.polygon)
  return polygon_ != NULL ? *polygon_
                         : *::COWA::MapData::Polygon::internal_default_instance();
}
inline ::COWA::MapData::Polygon* Lane_LaneMark::mutable_polygon() {
  set_has_polygon();
  if (polygon_ == NULL) {
    polygon_ = new ::COWA::MapData::Polygon;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Lane.LaneMark.polygon)
  return polygon_;
}
inline ::COWA::MapData::Polygon* Lane_LaneMark::release_polygon() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Lane.LaneMark.polygon)
  clear_has_polygon();
  ::COWA::MapData::Polygon* temp = polygon_;
  polygon_ = NULL;
  return temp;
}
inline void Lane_LaneMark::set_allocated_polygon(::COWA::MapData::Polygon* polygon) {
  delete polygon_;
  polygon_ = polygon;
  if (polygon) {
    set_has_polygon();
  } else {
    clear_has_polygon();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Lane.LaneMark.polygon)
}

// optional float direction = 5;
inline bool Lane_LaneMark::has_direction() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Lane_LaneMark::set_has_direction() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Lane_LaneMark::clear_has_direction() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Lane_LaneMark::clear_direction() {
  direction_ = 0;
  clear_has_direction();
}
inline float Lane_LaneMark::direction() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Lane.LaneMark.direction)
  return direction_;
}
inline void Lane_LaneMark::set_direction(float value) {
  set_has_direction();
  direction_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.Lane.LaneMark.direction)
}

// -------------------------------------------------------------------

// Lane

// optional .COWA.MapData.Id id = 1;
inline bool Lane::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Lane::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Lane::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Lane::clear_id() {
  if (id_ != NULL) id_->::COWA::MapData::Id::Clear();
  clear_has_id();
}
inline const ::COWA::MapData::Id& Lane::id() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Lane.id)
  return id_ != NULL ? *id_
                         : *::COWA::MapData::Id::internal_default_instance();
}
inline ::COWA::MapData::Id* Lane::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    id_ = new ::COWA::MapData::Id;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Lane.id)
  return id_;
}
inline ::COWA::MapData::Id* Lane::release_id() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Lane.id)
  clear_has_id();
  ::COWA::MapData::Id* temp = id_;
  id_ = NULL;
  return temp;
}
inline void Lane::set_allocated_id(::COWA::MapData::Id* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Lane.id)
}

// optional .COWA.MapData.Lane.LaneType type = 2;
inline bool Lane::has_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Lane::set_has_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Lane::clear_has_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Lane::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::COWA::MapData::Lane_LaneType Lane::type() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Lane.type)
  return static_cast< ::COWA::MapData::Lane_LaneType >(type_);
}
inline void Lane::set_type(::COWA::MapData::Lane_LaneType value) {
  assert(::COWA::MapData::Lane_LaneType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.Lane.type)
}

// optional .COWA.MapData.Id central_line = 3;
inline bool Lane::has_central_line() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Lane::set_has_central_line() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Lane::clear_has_central_line() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Lane::clear_central_line() {
  if (central_line_ != NULL) central_line_->::COWA::MapData::Id::Clear();
  clear_has_central_line();
}
inline const ::COWA::MapData::Id& Lane::central_line() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Lane.central_line)
  return central_line_ != NULL ? *central_line_
                         : *::COWA::MapData::Id::internal_default_instance();
}
inline ::COWA::MapData::Id* Lane::mutable_central_line() {
  set_has_central_line();
  if (central_line_ == NULL) {
    central_line_ = new ::COWA::MapData::Id;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Lane.central_line)
  return central_line_;
}
inline ::COWA::MapData::Id* Lane::release_central_line() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Lane.central_line)
  clear_has_central_line();
  ::COWA::MapData::Id* temp = central_line_;
  central_line_ = NULL;
  return temp;
}
inline void Lane::set_allocated_central_line(::COWA::MapData::Id* central_line) {
  delete central_line_;
  central_line_ = central_line;
  if (central_line) {
    set_has_central_line();
  } else {
    clear_has_central_line();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Lane.central_line)
}

// repeated .COWA.MapData.Id left_line = 4;
inline int Lane::left_line_size() const {
  return left_line_.size();
}
inline void Lane::clear_left_line() {
  left_line_.Clear();
}
inline const ::COWA::MapData::Id& Lane::left_line(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Lane.left_line)
  return left_line_.Get(index);
}
inline ::COWA::MapData::Id* Lane::mutable_left_line(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Lane.left_line)
  return left_line_.Mutable(index);
}
inline ::COWA::MapData::Id* Lane::add_left_line() {
  // @@protoc_insertion_point(field_add:COWA.MapData.Lane.left_line)
  return left_line_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >*
Lane::mutable_left_line() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.Lane.left_line)
  return &left_line_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >&
Lane::left_line() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.Lane.left_line)
  return left_line_;
}

// repeated .COWA.MapData.Id right_line = 5;
inline int Lane::right_line_size() const {
  return right_line_.size();
}
inline void Lane::clear_right_line() {
  right_line_.Clear();
}
inline const ::COWA::MapData::Id& Lane::right_line(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Lane.right_line)
  return right_line_.Get(index);
}
inline ::COWA::MapData::Id* Lane::mutable_right_line(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Lane.right_line)
  return right_line_.Mutable(index);
}
inline ::COWA::MapData::Id* Lane::add_right_line() {
  // @@protoc_insertion_point(field_add:COWA.MapData.Lane.right_line)
  return right_line_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >*
Lane::mutable_right_line() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.Lane.right_line)
  return &right_line_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >&
Lane::right_line() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.Lane.right_line)
  return right_line_;
}

// optional float length = 6;
inline bool Lane::has_length() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Lane::set_has_length() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Lane::clear_has_length() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Lane::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline float Lane::length() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Lane.length)
  return length_;
}
inline void Lane::set_length(float value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.Lane.length)
}

// optional float speed_limit = 7;
inline bool Lane::has_speed_limit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Lane::set_has_speed_limit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Lane::clear_has_speed_limit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Lane::clear_speed_limit() {
  speed_limit_ = 0;
  clear_has_speed_limit();
}
inline float Lane::speed_limit() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Lane.speed_limit)
  return speed_limit_;
}
inline void Lane::set_speed_limit(float value) {
  set_has_speed_limit();
  speed_limit_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.Lane.speed_limit)
}

// optional float min_speed_limit = 16;
inline bool Lane::has_min_speed_limit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Lane::set_has_min_speed_limit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Lane::clear_has_min_speed_limit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Lane::clear_min_speed_limit() {
  min_speed_limit_ = 0;
  clear_has_min_speed_limit();
}
inline float Lane::min_speed_limit() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Lane.min_speed_limit)
  return min_speed_limit_;
}
inline void Lane::set_min_speed_limit(float value) {
  set_has_min_speed_limit();
  min_speed_limit_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.Lane.min_speed_limit)
}

// repeated .COWA.MapData.Id predecessor_id = 8;
inline int Lane::predecessor_id_size() const {
  return predecessor_id_.size();
}
inline void Lane::clear_predecessor_id() {
  predecessor_id_.Clear();
}
inline const ::COWA::MapData::Id& Lane::predecessor_id(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Lane.predecessor_id)
  return predecessor_id_.Get(index);
}
inline ::COWA::MapData::Id* Lane::mutable_predecessor_id(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Lane.predecessor_id)
  return predecessor_id_.Mutable(index);
}
inline ::COWA::MapData::Id* Lane::add_predecessor_id() {
  // @@protoc_insertion_point(field_add:COWA.MapData.Lane.predecessor_id)
  return predecessor_id_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >*
Lane::mutable_predecessor_id() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.Lane.predecessor_id)
  return &predecessor_id_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >&
Lane::predecessor_id() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.Lane.predecessor_id)
  return predecessor_id_;
}

// repeated .COWA.MapData.Id successor_id = 9;
inline int Lane::successor_id_size() const {
  return successor_id_.size();
}
inline void Lane::clear_successor_id() {
  successor_id_.Clear();
}
inline const ::COWA::MapData::Id& Lane::successor_id(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Lane.successor_id)
  return successor_id_.Get(index);
}
inline ::COWA::MapData::Id* Lane::mutable_successor_id(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Lane.successor_id)
  return successor_id_.Mutable(index);
}
inline ::COWA::MapData::Id* Lane::add_successor_id() {
  // @@protoc_insertion_point(field_add:COWA.MapData.Lane.successor_id)
  return successor_id_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >*
Lane::mutable_successor_id() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.Lane.successor_id)
  return &successor_id_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >&
Lane::successor_id() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.Lane.successor_id)
  return successor_id_;
}

// repeated .COWA.MapData.Id left_neighbor_forward_lane_id = 10;
inline int Lane::left_neighbor_forward_lane_id_size() const {
  return left_neighbor_forward_lane_id_.size();
}
inline void Lane::clear_left_neighbor_forward_lane_id() {
  left_neighbor_forward_lane_id_.Clear();
}
inline const ::COWA::MapData::Id& Lane::left_neighbor_forward_lane_id(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Lane.left_neighbor_forward_lane_id)
  return left_neighbor_forward_lane_id_.Get(index);
}
inline ::COWA::MapData::Id* Lane::mutable_left_neighbor_forward_lane_id(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Lane.left_neighbor_forward_lane_id)
  return left_neighbor_forward_lane_id_.Mutable(index);
}
inline ::COWA::MapData::Id* Lane::add_left_neighbor_forward_lane_id() {
  // @@protoc_insertion_point(field_add:COWA.MapData.Lane.left_neighbor_forward_lane_id)
  return left_neighbor_forward_lane_id_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >*
Lane::mutable_left_neighbor_forward_lane_id() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.Lane.left_neighbor_forward_lane_id)
  return &left_neighbor_forward_lane_id_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >&
Lane::left_neighbor_forward_lane_id() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.Lane.left_neighbor_forward_lane_id)
  return left_neighbor_forward_lane_id_;
}

// repeated .COWA.MapData.Id right_neighbor_forward_lane_id = 11;
inline int Lane::right_neighbor_forward_lane_id_size() const {
  return right_neighbor_forward_lane_id_.size();
}
inline void Lane::clear_right_neighbor_forward_lane_id() {
  right_neighbor_forward_lane_id_.Clear();
}
inline const ::COWA::MapData::Id& Lane::right_neighbor_forward_lane_id(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Lane.right_neighbor_forward_lane_id)
  return right_neighbor_forward_lane_id_.Get(index);
}
inline ::COWA::MapData::Id* Lane::mutable_right_neighbor_forward_lane_id(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Lane.right_neighbor_forward_lane_id)
  return right_neighbor_forward_lane_id_.Mutable(index);
}
inline ::COWA::MapData::Id* Lane::add_right_neighbor_forward_lane_id() {
  // @@protoc_insertion_point(field_add:COWA.MapData.Lane.right_neighbor_forward_lane_id)
  return right_neighbor_forward_lane_id_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >*
Lane::mutable_right_neighbor_forward_lane_id() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.Lane.right_neighbor_forward_lane_id)
  return &right_neighbor_forward_lane_id_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >&
Lane::right_neighbor_forward_lane_id() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.Lane.right_neighbor_forward_lane_id)
  return right_neighbor_forward_lane_id_;
}

// repeated .COWA.MapData.Id left_neighbor_reverse_lane_id = 12;
inline int Lane::left_neighbor_reverse_lane_id_size() const {
  return left_neighbor_reverse_lane_id_.size();
}
inline void Lane::clear_left_neighbor_reverse_lane_id() {
  left_neighbor_reverse_lane_id_.Clear();
}
inline const ::COWA::MapData::Id& Lane::left_neighbor_reverse_lane_id(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Lane.left_neighbor_reverse_lane_id)
  return left_neighbor_reverse_lane_id_.Get(index);
}
inline ::COWA::MapData::Id* Lane::mutable_left_neighbor_reverse_lane_id(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Lane.left_neighbor_reverse_lane_id)
  return left_neighbor_reverse_lane_id_.Mutable(index);
}
inline ::COWA::MapData::Id* Lane::add_left_neighbor_reverse_lane_id() {
  // @@protoc_insertion_point(field_add:COWA.MapData.Lane.left_neighbor_reverse_lane_id)
  return left_neighbor_reverse_lane_id_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >*
Lane::mutable_left_neighbor_reverse_lane_id() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.Lane.left_neighbor_reverse_lane_id)
  return &left_neighbor_reverse_lane_id_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >&
Lane::left_neighbor_reverse_lane_id() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.Lane.left_neighbor_reverse_lane_id)
  return left_neighbor_reverse_lane_id_;
}

// repeated .COWA.MapData.Id right_neighbor_reverse_lane_id = 13;
inline int Lane::right_neighbor_reverse_lane_id_size() const {
  return right_neighbor_reverse_lane_id_.size();
}
inline void Lane::clear_right_neighbor_reverse_lane_id() {
  right_neighbor_reverse_lane_id_.Clear();
}
inline const ::COWA::MapData::Id& Lane::right_neighbor_reverse_lane_id(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Lane.right_neighbor_reverse_lane_id)
  return right_neighbor_reverse_lane_id_.Get(index);
}
inline ::COWA::MapData::Id* Lane::mutable_right_neighbor_reverse_lane_id(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Lane.right_neighbor_reverse_lane_id)
  return right_neighbor_reverse_lane_id_.Mutable(index);
}
inline ::COWA::MapData::Id* Lane::add_right_neighbor_reverse_lane_id() {
  // @@protoc_insertion_point(field_add:COWA.MapData.Lane.right_neighbor_reverse_lane_id)
  return right_neighbor_reverse_lane_id_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >*
Lane::mutable_right_neighbor_reverse_lane_id() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.Lane.right_neighbor_reverse_lane_id)
  return &right_neighbor_reverse_lane_id_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >&
Lane::right_neighbor_reverse_lane_id() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.Lane.right_neighbor_reverse_lane_id)
  return right_neighbor_reverse_lane_id_;
}

// optional .COWA.MapData.Lane.LaneDirection direction = 14;
inline bool Lane::has_direction() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Lane::set_has_direction() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Lane::clear_has_direction() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Lane::clear_direction() {
  direction_ = 1;
  clear_has_direction();
}
inline ::COWA::MapData::Lane_LaneDirection Lane::direction() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Lane.direction)
  return static_cast< ::COWA::MapData::Lane_LaneDirection >(direction_);
}
inline void Lane::set_direction(::COWA::MapData::Lane_LaneDirection value) {
  assert(::COWA::MapData::Lane_LaneDirection_IsValid(value));
  set_has_direction();
  direction_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.Lane.direction)
}

// optional .COWA.MapData.Lane.LaneTurn turn = 15;
inline bool Lane::has_turn() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Lane::set_has_turn() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Lane::clear_has_turn() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Lane::clear_turn() {
  turn_ = 1;
  clear_has_turn();
}
inline ::COWA::MapData::Lane_LaneTurn Lane::turn() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Lane.turn)
  return static_cast< ::COWA::MapData::Lane_LaneTurn >(turn_);
}
inline void Lane::set_turn(::COWA::MapData::Lane_LaneTurn value) {
  assert(::COWA::MapData::Lane_LaneTurn_IsValid(value));
  set_has_turn();
  turn_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.Lane.turn)
}

// repeated .COWA.MapData.Lane.LaneMark mark = 17;
inline int Lane::mark_size() const {
  return mark_.size();
}
inline void Lane::clear_mark() {
  mark_.Clear();
}
inline const ::COWA::MapData::Lane_LaneMark& Lane::mark(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Lane.mark)
  return mark_.Get(index);
}
inline ::COWA::MapData::Lane_LaneMark* Lane::mutable_mark(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Lane.mark)
  return mark_.Mutable(index);
}
inline ::COWA::MapData::Lane_LaneMark* Lane::add_mark() {
  // @@protoc_insertion_point(field_add:COWA.MapData.Lane.mark)
  return mark_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Lane_LaneMark >*
Lane::mutable_mark() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.Lane.mark)
  return &mark_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Lane_LaneMark >&
Lane::mark() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.Lane.mark)
  return mark_;
}

// -------------------------------------------------------------------

// LaneTide_Item_Time

// optional float start_time = 1;
inline bool LaneTide_Item_Time::has_start_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaneTide_Item_Time::set_has_start_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LaneTide_Item_Time::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LaneTide_Item_Time::clear_start_time() {
  start_time_ = 0;
  clear_has_start_time();
}
inline float LaneTide_Item_Time::start_time() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.LaneTide.Item.Time.start_time)
  return start_time_;
}
inline void LaneTide_Item_Time::set_start_time(float value) {
  set_has_start_time();
  start_time_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.LaneTide.Item.Time.start_time)
}

// optional float end_time = 2;
inline bool LaneTide_Item_Time::has_end_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaneTide_Item_Time::set_has_end_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LaneTide_Item_Time::clear_has_end_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LaneTide_Item_Time::clear_end_time() {
  end_time_ = 0;
  clear_has_end_time();
}
inline float LaneTide_Item_Time::end_time() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.LaneTide.Item.Time.end_time)
  return end_time_;
}
inline void LaneTide_Item_Time::set_end_time(float value) {
  set_has_end_time();
  end_time_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.LaneTide.Item.Time.end_time)
}

// -------------------------------------------------------------------

// LaneTide_Item

// repeated .COWA.MapData.Id lane_id = 1;
inline int LaneTide_Item::lane_id_size() const {
  return lane_id_.size();
}
inline void LaneTide_Item::clear_lane_id() {
  lane_id_.Clear();
}
inline const ::COWA::MapData::Id& LaneTide_Item::lane_id(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.LaneTide.Item.lane_id)
  return lane_id_.Get(index);
}
inline ::COWA::MapData::Id* LaneTide_Item::mutable_lane_id(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.LaneTide.Item.lane_id)
  return lane_id_.Mutable(index);
}
inline ::COWA::MapData::Id* LaneTide_Item::add_lane_id() {
  // @@protoc_insertion_point(field_add:COWA.MapData.LaneTide.Item.lane_id)
  return lane_id_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >*
LaneTide_Item::mutable_lane_id() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.LaneTide.Item.lane_id)
  return &lane_id_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >&
LaneTide_Item::lane_id() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.LaneTide.Item.lane_id)
  return lane_id_;
}

// repeated .COWA.MapData.LaneTide.Item.Time time = 2;
inline int LaneTide_Item::time_size() const {
  return time_.size();
}
inline void LaneTide_Item::clear_time() {
  time_.Clear();
}
inline const ::COWA::MapData::LaneTide_Item_Time& LaneTide_Item::time(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.LaneTide.Item.time)
  return time_.Get(index);
}
inline ::COWA::MapData::LaneTide_Item_Time* LaneTide_Item::mutable_time(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.LaneTide.Item.time)
  return time_.Mutable(index);
}
inline ::COWA::MapData::LaneTide_Item_Time* LaneTide_Item::add_time() {
  // @@protoc_insertion_point(field_add:COWA.MapData.LaneTide.Item.time)
  return time_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::LaneTide_Item_Time >*
LaneTide_Item::mutable_time() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.LaneTide.Item.time)
  return &time_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::LaneTide_Item_Time >&
LaneTide_Item::time() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.LaneTide.Item.time)
  return time_;
}

// -------------------------------------------------------------------

// LaneTide

// optional .COWA.MapData.Id id = 1;
inline bool LaneTide::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaneTide::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LaneTide::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LaneTide::clear_id() {
  if (id_ != NULL) id_->::COWA::MapData::Id::Clear();
  clear_has_id();
}
inline const ::COWA::MapData::Id& LaneTide::id() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.LaneTide.id)
  return id_ != NULL ? *id_
                         : *::COWA::MapData::Id::internal_default_instance();
}
inline ::COWA::MapData::Id* LaneTide::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    id_ = new ::COWA::MapData::Id;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.LaneTide.id)
  return id_;
}
inline ::COWA::MapData::Id* LaneTide::release_id() {
  // @@protoc_insertion_point(field_release:COWA.MapData.LaneTide.id)
  clear_has_id();
  ::COWA::MapData::Id* temp = id_;
  id_ = NULL;
  return temp;
}
inline void LaneTide::set_allocated_id(::COWA::MapData::Id* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.LaneTide.id)
}

// optional .COWA.MapData.LaneTide.Item a = 2;
inline bool LaneTide::has_a() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaneTide::set_has_a() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LaneTide::clear_has_a() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LaneTide::clear_a() {
  if (a_ != NULL) a_->::COWA::MapData::LaneTide_Item::Clear();
  clear_has_a();
}
inline const ::COWA::MapData::LaneTide_Item& LaneTide::a() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.LaneTide.a)
  return a_ != NULL ? *a_
                         : *::COWA::MapData::LaneTide_Item::internal_default_instance();
}
inline ::COWA::MapData::LaneTide_Item* LaneTide::mutable_a() {
  set_has_a();
  if (a_ == NULL) {
    a_ = new ::COWA::MapData::LaneTide_Item;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.LaneTide.a)
  return a_;
}
inline ::COWA::MapData::LaneTide_Item* LaneTide::release_a() {
  // @@protoc_insertion_point(field_release:COWA.MapData.LaneTide.a)
  clear_has_a();
  ::COWA::MapData::LaneTide_Item* temp = a_;
  a_ = NULL;
  return temp;
}
inline void LaneTide::set_allocated_a(::COWA::MapData::LaneTide_Item* a) {
  delete a_;
  a_ = a;
  if (a) {
    set_has_a();
  } else {
    clear_has_a();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.LaneTide.a)
}

// optional .COWA.MapData.LaneTide.Item b = 3;
inline bool LaneTide::has_b() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LaneTide::set_has_b() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LaneTide::clear_has_b() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LaneTide::clear_b() {
  if (b_ != NULL) b_->::COWA::MapData::LaneTide_Item::Clear();
  clear_has_b();
}
inline const ::COWA::MapData::LaneTide_Item& LaneTide::b() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.LaneTide.b)
  return b_ != NULL ? *b_
                         : *::COWA::MapData::LaneTide_Item::internal_default_instance();
}
inline ::COWA::MapData::LaneTide_Item* LaneTide::mutable_b() {
  set_has_b();
  if (b_ == NULL) {
    b_ = new ::COWA::MapData::LaneTide_Item;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.LaneTide.b)
  return b_;
}
inline ::COWA::MapData::LaneTide_Item* LaneTide::release_b() {
  // @@protoc_insertion_point(field_release:COWA.MapData.LaneTide.b)
  clear_has_b();
  ::COWA::MapData::LaneTide_Item* temp = b_;
  b_ = NULL;
  return temp;
}
inline void LaneTide::set_allocated_b(::COWA::MapData::LaneTide_Item* b) {
  delete b_;
  b_ = b;
  if (b) {
    set_has_b();
  } else {
    clear_has_b();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.LaneTide.b)
}

// repeated .COWA.MapData.Id signal = 5;
inline int LaneTide::signal_size() const {
  return signal_.size();
}
inline void LaneTide::clear_signal() {
  signal_.Clear();
}
inline const ::COWA::MapData::Id& LaneTide::signal(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.LaneTide.signal)
  return signal_.Get(index);
}
inline ::COWA::MapData::Id* LaneTide::mutable_signal(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.LaneTide.signal)
  return signal_.Mutable(index);
}
inline ::COWA::MapData::Id* LaneTide::add_signal() {
  // @@protoc_insertion_point(field_add:COWA.MapData.LaneTide.signal)
  return signal_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >*
LaneTide::mutable_signal() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.LaneTide.signal)
  return &signal_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >&
LaneTide::signal() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.LaneTide.signal)
  return signal_;
}

// -------------------------------------------------------------------

// Road

// optional .COWA.MapData.Id id = 1;
inline bool Road::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Road::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Road::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Road::clear_id() {
  if (id_ != NULL) id_->::COWA::MapData::Id::Clear();
  clear_has_id();
}
inline const ::COWA::MapData::Id& Road::id() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Road.id)
  return id_ != NULL ? *id_
                         : *::COWA::MapData::Id::internal_default_instance();
}
inline ::COWA::MapData::Id* Road::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    id_ = new ::COWA::MapData::Id;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Road.id)
  return id_;
}
inline ::COWA::MapData::Id* Road::release_id() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Road.id)
  clear_has_id();
  ::COWA::MapData::Id* temp = id_;
  id_ = NULL;
  return temp;
}
inline void Road::set_allocated_id(::COWA::MapData::Id* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Road.id)
}

// optional .COWA.MapData.Road.RoadType type = 2;
inline bool Road::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Road::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Road::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Road::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::COWA::MapData::Road_RoadType Road::type() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Road.type)
  return static_cast< ::COWA::MapData::Road_RoadType >(type_);
}
inline void Road::set_type(::COWA::MapData::Road_RoadType value) {
  assert(::COWA::MapData::Road_RoadType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.Road.type)
}

// repeated .COWA.MapData.Id lane_id_a = 3;
inline int Road::lane_id_a_size() const {
  return lane_id_a_.size();
}
inline void Road::clear_lane_id_a() {
  lane_id_a_.Clear();
}
inline const ::COWA::MapData::Id& Road::lane_id_a(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Road.lane_id_a)
  return lane_id_a_.Get(index);
}
inline ::COWA::MapData::Id* Road::mutable_lane_id_a(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Road.lane_id_a)
  return lane_id_a_.Mutable(index);
}
inline ::COWA::MapData::Id* Road::add_lane_id_a() {
  // @@protoc_insertion_point(field_add:COWA.MapData.Road.lane_id_a)
  return lane_id_a_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >*
Road::mutable_lane_id_a() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.Road.lane_id_a)
  return &lane_id_a_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >&
Road::lane_id_a() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.Road.lane_id_a)
  return lane_id_a_;
}

// repeated .COWA.MapData.Id lane_id_b = 4;
inline int Road::lane_id_b_size() const {
  return lane_id_b_.size();
}
inline void Road::clear_lane_id_b() {
  lane_id_b_.Clear();
}
inline const ::COWA::MapData::Id& Road::lane_id_b(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Road.lane_id_b)
  return lane_id_b_.Get(index);
}
inline ::COWA::MapData::Id* Road::mutable_lane_id_b(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Road.lane_id_b)
  return lane_id_b_.Mutable(index);
}
inline ::COWA::MapData::Id* Road::add_lane_id_b() {
  // @@protoc_insertion_point(field_add:COWA.MapData.Road.lane_id_b)
  return lane_id_b_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >*
Road::mutable_lane_id_b() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.Road.lane_id_b)
  return &lane_id_b_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >&
Road::lane_id_b() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.Road.lane_id_b)
  return lane_id_b_;
}

// optional .COWA.MapData.LaneCurve boundary = 5;
inline bool Road::has_boundary() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Road::set_has_boundary() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Road::clear_has_boundary() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Road::clear_boundary() {
  if (boundary_ != NULL) boundary_->::COWA::MapData::LaneCurve::Clear();
  clear_has_boundary();
}
inline const ::COWA::MapData::LaneCurve& Road::boundary() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Road.boundary)
  return boundary_ != NULL ? *boundary_
                         : *::COWA::MapData::LaneCurve::internal_default_instance();
}
inline ::COWA::MapData::LaneCurve* Road::mutable_boundary() {
  set_has_boundary();
  if (boundary_ == NULL) {
    boundary_ = new ::COWA::MapData::LaneCurve;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Road.boundary)
  return boundary_;
}
inline ::COWA::MapData::LaneCurve* Road::release_boundary() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Road.boundary)
  clear_has_boundary();
  ::COWA::MapData::LaneCurve* temp = boundary_;
  boundary_ = NULL;
  return temp;
}
inline void Road::set_allocated_boundary(::COWA::MapData::LaneCurve* boundary) {
  delete boundary_;
  boundary_ = boundary;
  if (boundary) {
    set_has_boundary();
  } else {
    clear_has_boundary();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Road.boundary)
}

// -------------------------------------------------------------------

// Square

// optional .COWA.MapData.Id id = 1;
inline bool Square::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Square::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Square::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Square::clear_id() {
  if (id_ != NULL) id_->::COWA::MapData::Id::Clear();
  clear_has_id();
}
inline const ::COWA::MapData::Id& Square::id() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Square.id)
  return id_ != NULL ? *id_
                         : *::COWA::MapData::Id::internal_default_instance();
}
inline ::COWA::MapData::Id* Square::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    id_ = new ::COWA::MapData::Id;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Square.id)
  return id_;
}
inline ::COWA::MapData::Id* Square::release_id() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Square.id)
  clear_has_id();
  ::COWA::MapData::Id* temp = id_;
  id_ = NULL;
  return temp;
}
inline void Square::set_allocated_id(::COWA::MapData::Id* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Square.id)
}

// optional .COWA.MapData.Polygon polygon = 3;
inline bool Square::has_polygon() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Square::set_has_polygon() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Square::clear_has_polygon() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Square::clear_polygon() {
  if (polygon_ != NULL) polygon_->::COWA::MapData::Polygon::Clear();
  clear_has_polygon();
}
inline const ::COWA::MapData::Polygon& Square::polygon() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Square.polygon)
  return polygon_ != NULL ? *polygon_
                         : *::COWA::MapData::Polygon::internal_default_instance();
}
inline ::COWA::MapData::Polygon* Square::mutable_polygon() {
  set_has_polygon();
  if (polygon_ == NULL) {
    polygon_ = new ::COWA::MapData::Polygon;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Square.polygon)
  return polygon_;
}
inline ::COWA::MapData::Polygon* Square::release_polygon() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Square.polygon)
  clear_has_polygon();
  ::COWA::MapData::Polygon* temp = polygon_;
  polygon_ = NULL;
  return temp;
}
inline void Square::set_allocated_polygon(::COWA::MapData::Polygon* polygon) {
  delete polygon_;
  polygon_ = polygon;
  if (polygon) {
    set_has_polygon();
  } else {
    clear_has_polygon();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Square.polygon)
}

// -------------------------------------------------------------------

// Ramp

// optional .COWA.MapData.Id id = 1;
inline bool Ramp::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ramp::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ramp::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ramp::clear_id() {
  if (id_ != NULL) id_->::COWA::MapData::Id::Clear();
  clear_has_id();
}
inline const ::COWA::MapData::Id& Ramp::id() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Ramp.id)
  return id_ != NULL ? *id_
                         : *::COWA::MapData::Id::internal_default_instance();
}
inline ::COWA::MapData::Id* Ramp::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    id_ = new ::COWA::MapData::Id;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Ramp.id)
  return id_;
}
inline ::COWA::MapData::Id* Ramp::release_id() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Ramp.id)
  clear_has_id();
  ::COWA::MapData::Id* temp = id_;
  id_ = NULL;
  return temp;
}
inline void Ramp::set_allocated_id(::COWA::MapData::Id* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Ramp.id)
}

// optional .COWA.MapData.Polygon polygon = 2;
inline bool Ramp::has_polygon() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ramp::set_has_polygon() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Ramp::clear_has_polygon() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Ramp::clear_polygon() {
  if (polygon_ != NULL) polygon_->::COWA::MapData::Polygon::Clear();
  clear_has_polygon();
}
inline const ::COWA::MapData::Polygon& Ramp::polygon() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Ramp.polygon)
  return polygon_ != NULL ? *polygon_
                         : *::COWA::MapData::Polygon::internal_default_instance();
}
inline ::COWA::MapData::Polygon* Ramp::mutable_polygon() {
  set_has_polygon();
  if (polygon_ == NULL) {
    polygon_ = new ::COWA::MapData::Polygon;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Ramp.polygon)
  return polygon_;
}
inline ::COWA::MapData::Polygon* Ramp::release_polygon() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Ramp.polygon)
  clear_has_polygon();
  ::COWA::MapData::Polygon* temp = polygon_;
  polygon_ = NULL;
  return temp;
}
inline void Ramp::set_allocated_polygon(::COWA::MapData::Polygon* polygon) {
  delete polygon_;
  polygon_ = polygon;
  if (polygon) {
    set_has_polygon();
  } else {
    clear_has_polygon();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Ramp.polygon)
}

// optional float oriention = 3;
inline bool Ramp::has_oriention() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Ramp::set_has_oriention() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Ramp::clear_has_oriention() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Ramp::clear_oriention() {
  oriention_ = 0;
  clear_has_oriention();
}
inline float Ramp::oriention() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Ramp.oriention)
  return oriention_;
}
inline void Ramp::set_oriention(float value) {
  set_has_oriention();
  oriention_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.Ramp.oriention)
}

// -------------------------------------------------------------------

// Crosswalk

// optional .COWA.MapData.Id id = 1;
inline bool Crosswalk::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Crosswalk::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Crosswalk::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Crosswalk::clear_id() {
  if (id_ != NULL) id_->::COWA::MapData::Id::Clear();
  clear_has_id();
}
inline const ::COWA::MapData::Id& Crosswalk::id() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Crosswalk.id)
  return id_ != NULL ? *id_
                         : *::COWA::MapData::Id::internal_default_instance();
}
inline ::COWA::MapData::Id* Crosswalk::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    id_ = new ::COWA::MapData::Id;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Crosswalk.id)
  return id_;
}
inline ::COWA::MapData::Id* Crosswalk::release_id() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Crosswalk.id)
  clear_has_id();
  ::COWA::MapData::Id* temp = id_;
  id_ = NULL;
  return temp;
}
inline void Crosswalk::set_allocated_id(::COWA::MapData::Id* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Crosswalk.id)
}

// optional .COWA.MapData.Polygon polygon = 2;
inline bool Crosswalk::has_polygon() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Crosswalk::set_has_polygon() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Crosswalk::clear_has_polygon() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Crosswalk::clear_polygon() {
  if (polygon_ != NULL) polygon_->::COWA::MapData::Polygon::Clear();
  clear_has_polygon();
}
inline const ::COWA::MapData::Polygon& Crosswalk::polygon() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Crosswalk.polygon)
  return polygon_ != NULL ? *polygon_
                         : *::COWA::MapData::Polygon::internal_default_instance();
}
inline ::COWA::MapData::Polygon* Crosswalk::mutable_polygon() {
  set_has_polygon();
  if (polygon_ == NULL) {
    polygon_ = new ::COWA::MapData::Polygon;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Crosswalk.polygon)
  return polygon_;
}
inline ::COWA::MapData::Polygon* Crosswalk::release_polygon() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Crosswalk.polygon)
  clear_has_polygon();
  ::COWA::MapData::Polygon* temp = polygon_;
  polygon_ = NULL;
  return temp;
}
inline void Crosswalk::set_allocated_polygon(::COWA::MapData::Polygon* polygon) {
  delete polygon_;
  polygon_ = polygon;
  if (polygon) {
    set_has_polygon();
  } else {
    clear_has_polygon();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Crosswalk.polygon)
}

// optional float oriention = 3;
inline bool Crosswalk::has_oriention() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Crosswalk::set_has_oriention() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Crosswalk::clear_has_oriention() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Crosswalk::clear_oriention() {
  oriention_ = 0;
  clear_has_oriention();
}
inline float Crosswalk::oriention() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Crosswalk.oriention)
  return oriention_;
}
inline void Crosswalk::set_oriention(float value) {
  set_has_oriention();
  oriention_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.Crosswalk.oriention)
}

// optional bool hybrid = 4;
inline bool Crosswalk::has_hybrid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Crosswalk::set_has_hybrid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Crosswalk::clear_has_hybrid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Crosswalk::clear_hybrid() {
  hybrid_ = false;
  clear_has_hybrid();
}
inline bool Crosswalk::hybrid() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Crosswalk.hybrid)
  return hybrid_;
}
inline void Crosswalk::set_hybrid(bool value) {
  set_has_hybrid();
  hybrid_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.Crosswalk.hybrid)
}

// -------------------------------------------------------------------

// Roadmark

// optional .COWA.MapData.Id id = 1;
inline bool Roadmark::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Roadmark::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Roadmark::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Roadmark::clear_id() {
  if (id_ != NULL) id_->::COWA::MapData::Id::Clear();
  clear_has_id();
}
inline const ::COWA::MapData::Id& Roadmark::id() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Roadmark.id)
  return id_ != NULL ? *id_
                         : *::COWA::MapData::Id::internal_default_instance();
}
inline ::COWA::MapData::Id* Roadmark::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    id_ = new ::COWA::MapData::Id;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Roadmark.id)
  return id_;
}
inline ::COWA::MapData::Id* Roadmark::release_id() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Roadmark.id)
  clear_has_id();
  ::COWA::MapData::Id* temp = id_;
  id_ = NULL;
  return temp;
}
inline void Roadmark::set_allocated_id(::COWA::MapData::Id* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Roadmark.id)
}

// optional .COWA.MapData.Polygon polygon = 2;
inline bool Roadmark::has_polygon() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Roadmark::set_has_polygon() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Roadmark::clear_has_polygon() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Roadmark::clear_polygon() {
  if (polygon_ != NULL) polygon_->::COWA::MapData::Polygon::Clear();
  clear_has_polygon();
}
inline const ::COWA::MapData::Polygon& Roadmark::polygon() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Roadmark.polygon)
  return polygon_ != NULL ? *polygon_
                         : *::COWA::MapData::Polygon::internal_default_instance();
}
inline ::COWA::MapData::Polygon* Roadmark::mutable_polygon() {
  set_has_polygon();
  if (polygon_ == NULL) {
    polygon_ = new ::COWA::MapData::Polygon;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Roadmark.polygon)
  return polygon_;
}
inline ::COWA::MapData::Polygon* Roadmark::release_polygon() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Roadmark.polygon)
  clear_has_polygon();
  ::COWA::MapData::Polygon* temp = polygon_;
  polygon_ = NULL;
  return temp;
}
inline void Roadmark::set_allocated_polygon(::COWA::MapData::Polygon* polygon) {
  delete polygon_;
  polygon_ = polygon;
  if (polygon) {
    set_has_polygon();
  } else {
    clear_has_polygon();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Roadmark.polygon)
}

// optional .COWA.MapData.Roadmark.RoadmarkType type = 3;
inline bool Roadmark::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Roadmark::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Roadmark::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Roadmark::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::COWA::MapData::Roadmark_RoadmarkType Roadmark::type() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Roadmark.type)
  return static_cast< ::COWA::MapData::Roadmark_RoadmarkType >(type_);
}
inline void Roadmark::set_type(::COWA::MapData::Roadmark_RoadmarkType value) {
  assert(::COWA::MapData::Roadmark_RoadmarkType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.Roadmark.type)
}

// -------------------------------------------------------------------

// ParkingSpace

// optional .COWA.MapData.Id id = 1;
inline bool ParkingSpace::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParkingSpace::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParkingSpace::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParkingSpace::clear_id() {
  if (id_ != NULL) id_->::COWA::MapData::Id::Clear();
  clear_has_id();
}
inline const ::COWA::MapData::Id& ParkingSpace::id() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.ParkingSpace.id)
  return id_ != NULL ? *id_
                         : *::COWA::MapData::Id::internal_default_instance();
}
inline ::COWA::MapData::Id* ParkingSpace::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    id_ = new ::COWA::MapData::Id;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.ParkingSpace.id)
  return id_;
}
inline ::COWA::MapData::Id* ParkingSpace::release_id() {
  // @@protoc_insertion_point(field_release:COWA.MapData.ParkingSpace.id)
  clear_has_id();
  ::COWA::MapData::Id* temp = id_;
  id_ = NULL;
  return temp;
}
inline void ParkingSpace::set_allocated_id(::COWA::MapData::Id* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.ParkingSpace.id)
}

// optional .COWA.MapData.Polygon polygon = 2;
inline bool ParkingSpace::has_polygon() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ParkingSpace::set_has_polygon() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ParkingSpace::clear_has_polygon() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ParkingSpace::clear_polygon() {
  if (polygon_ != NULL) polygon_->::COWA::MapData::Polygon::Clear();
  clear_has_polygon();
}
inline const ::COWA::MapData::Polygon& ParkingSpace::polygon() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.ParkingSpace.polygon)
  return polygon_ != NULL ? *polygon_
                         : *::COWA::MapData::Polygon::internal_default_instance();
}
inline ::COWA::MapData::Polygon* ParkingSpace::mutable_polygon() {
  set_has_polygon();
  if (polygon_ == NULL) {
    polygon_ = new ::COWA::MapData::Polygon;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.ParkingSpace.polygon)
  return polygon_;
}
inline ::COWA::MapData::Polygon* ParkingSpace::release_polygon() {
  // @@protoc_insertion_point(field_release:COWA.MapData.ParkingSpace.polygon)
  clear_has_polygon();
  ::COWA::MapData::Polygon* temp = polygon_;
  polygon_ = NULL;
  return temp;
}
inline void ParkingSpace::set_allocated_polygon(::COWA::MapData::Polygon* polygon) {
  delete polygon_;
  polygon_ = polygon;
  if (polygon) {
    set_has_polygon();
  } else {
    clear_has_polygon();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.ParkingSpace.polygon)
}

// optional .COWA.MapData.Polygon boundary = 3;
inline bool ParkingSpace::has_boundary() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ParkingSpace::set_has_boundary() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ParkingSpace::clear_has_boundary() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ParkingSpace::clear_boundary() {
  if (boundary_ != NULL) boundary_->::COWA::MapData::Polygon::Clear();
  clear_has_boundary();
}
inline const ::COWA::MapData::Polygon& ParkingSpace::boundary() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.ParkingSpace.boundary)
  return boundary_ != NULL ? *boundary_
                         : *::COWA::MapData::Polygon::internal_default_instance();
}
inline ::COWA::MapData::Polygon* ParkingSpace::mutable_boundary() {
  set_has_boundary();
  if (boundary_ == NULL) {
    boundary_ = new ::COWA::MapData::Polygon;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.ParkingSpace.boundary)
  return boundary_;
}
inline ::COWA::MapData::Polygon* ParkingSpace::release_boundary() {
  // @@protoc_insertion_point(field_release:COWA.MapData.ParkingSpace.boundary)
  clear_has_boundary();
  ::COWA::MapData::Polygon* temp = boundary_;
  boundary_ = NULL;
  return temp;
}
inline void ParkingSpace::set_allocated_boundary(::COWA::MapData::Polygon* boundary) {
  delete boundary_;
  boundary_ = boundary;
  if (boundary) {
    set_has_boundary();
  } else {
    clear_has_boundary();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.ParkingSpace.boundary)
}

// optional float oriention = 4;
inline bool ParkingSpace::has_oriention() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ParkingSpace::set_has_oriention() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ParkingSpace::clear_has_oriention() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ParkingSpace::clear_oriention() {
  oriention_ = 0;
  clear_has_oriention();
}
inline float ParkingSpace::oriention() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.ParkingSpace.oriention)
  return oriention_;
}
inline void ParkingSpace::set_oriention(float value) {
  set_has_oriention();
  oriention_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.ParkingSpace.oriention)
}

// -------------------------------------------------------------------

// Object

// optional .COWA.MapData.Id id = 1;
inline bool Object::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Object::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Object::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Object::clear_id() {
  if (id_ != NULL) id_->::COWA::MapData::Id::Clear();
  clear_has_id();
}
inline const ::COWA::MapData::Id& Object::id() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Object.id)
  return id_ != NULL ? *id_
                         : *::COWA::MapData::Id::internal_default_instance();
}
inline ::COWA::MapData::Id* Object::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    id_ = new ::COWA::MapData::Id;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Object.id)
  return id_;
}
inline ::COWA::MapData::Id* Object::release_id() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Object.id)
  clear_has_id();
  ::COWA::MapData::Id* temp = id_;
  id_ = NULL;
  return temp;
}
inline void Object::set_allocated_id(::COWA::MapData::Id* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Object.id)
}

// optional .COWA.MapData.Object.Type type = 2;
inline bool Object::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Object::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Object::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Object::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::COWA::MapData::Object_Type Object::type() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Object.type)
  return static_cast< ::COWA::MapData::Object_Type >(type_);
}
inline void Object::set_type(::COWA::MapData::Object_Type value) {
  assert(::COWA::MapData::Object_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.Object.type)
}

// optional .COWA.MapData.Polygon polygon = 3;
inline bool Object::has_polygon() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Object::set_has_polygon() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Object::clear_has_polygon() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Object::clear_polygon() {
  if (polygon_ != NULL) polygon_->::COWA::MapData::Polygon::Clear();
  clear_has_polygon();
}
inline const ::COWA::MapData::Polygon& Object::polygon() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Object.polygon)
  return polygon_ != NULL ? *polygon_
                         : *::COWA::MapData::Polygon::internal_default_instance();
}
inline ::COWA::MapData::Polygon* Object::mutable_polygon() {
  set_has_polygon();
  if (polygon_ == NULL) {
    polygon_ = new ::COWA::MapData::Polygon;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Object.polygon)
  return polygon_;
}
inline ::COWA::MapData::Polygon* Object::release_polygon() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Object.polygon)
  clear_has_polygon();
  ::COWA::MapData::Polygon* temp = polygon_;
  polygon_ = NULL;
  return temp;
}
inline void Object::set_allocated_polygon(::COWA::MapData::Polygon* polygon) {
  delete polygon_;
  polygon_ = polygon;
  if (polygon) {
    set_has_polygon();
  } else {
    clear_has_polygon();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Object.polygon)
}

// optional .COWA.MapData.Cloud cloud = 4;
inline bool Object::has_cloud() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Object::set_has_cloud() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Object::clear_has_cloud() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Object::clear_cloud() {
  if (cloud_ != NULL) cloud_->::COWA::MapData::Cloud::Clear();
  clear_has_cloud();
}
inline const ::COWA::MapData::Cloud& Object::cloud() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Object.cloud)
  return cloud_ != NULL ? *cloud_
                         : *::COWA::MapData::Cloud::internal_default_instance();
}
inline ::COWA::MapData::Cloud* Object::mutable_cloud() {
  set_has_cloud();
  if (cloud_ == NULL) {
    cloud_ = new ::COWA::MapData::Cloud;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Object.cloud)
  return cloud_;
}
inline ::COWA::MapData::Cloud* Object::release_cloud() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Object.cloud)
  clear_has_cloud();
  ::COWA::MapData::Cloud* temp = cloud_;
  cloud_ = NULL;
  return temp;
}
inline void Object::set_allocated_cloud(::COWA::MapData::Cloud* cloud) {
  delete cloud_;
  cloud_ = cloud;
  if (cloud) {
    set_has_cloud();
  } else {
    clear_has_cloud();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Object.cloud)
}

// -------------------------------------------------------------------

// Subsignal

// optional .COWA.MapData.Id id = 1;
inline bool Subsignal::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Subsignal::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Subsignal::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Subsignal::clear_id() {
  if (id_ != NULL) id_->::COWA::MapData::Id::Clear();
  clear_has_id();
}
inline const ::COWA::MapData::Id& Subsignal::id() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Subsignal.id)
  return id_ != NULL ? *id_
                         : *::COWA::MapData::Id::internal_default_instance();
}
inline ::COWA::MapData::Id* Subsignal::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    id_ = new ::COWA::MapData::Id;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Subsignal.id)
  return id_;
}
inline ::COWA::MapData::Id* Subsignal::release_id() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Subsignal.id)
  clear_has_id();
  ::COWA::MapData::Id* temp = id_;
  id_ = NULL;
  return temp;
}
inline void Subsignal::set_allocated_id(::COWA::MapData::Id* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Subsignal.id)
}

// optional .COWA.MapData.Subsignal.Type type = 2;
inline bool Subsignal::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Subsignal::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Subsignal::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Subsignal::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::COWA::MapData::Subsignal_Type Subsignal::type() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Subsignal.type)
  return static_cast< ::COWA::MapData::Subsignal_Type >(type_);
}
inline void Subsignal::set_type(::COWA::MapData::Subsignal_Type value) {
  assert(::COWA::MapData::Subsignal_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.Subsignal.type)
}

// optional .COWA.MapData.Polygon boundary = 3;
inline bool Subsignal::has_boundary() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Subsignal::set_has_boundary() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Subsignal::clear_has_boundary() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Subsignal::clear_boundary() {
  if (boundary_ != NULL) boundary_->::COWA::MapData::Polygon::Clear();
  clear_has_boundary();
}
inline const ::COWA::MapData::Polygon& Subsignal::boundary() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Subsignal.boundary)
  return boundary_ != NULL ? *boundary_
                         : *::COWA::MapData::Polygon::internal_default_instance();
}
inline ::COWA::MapData::Polygon* Subsignal::mutable_boundary() {
  set_has_boundary();
  if (boundary_ == NULL) {
    boundary_ = new ::COWA::MapData::Polygon;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Subsignal.boundary)
  return boundary_;
}
inline ::COWA::MapData::Polygon* Subsignal::release_boundary() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Subsignal.boundary)
  clear_has_boundary();
  ::COWA::MapData::Polygon* temp = boundary_;
  boundary_ = NULL;
  return temp;
}
inline void Subsignal::set_allocated_boundary(::COWA::MapData::Polygon* boundary) {
  delete boundary_;
  boundary_ = boundary;
  if (boundary) {
    set_has_boundary();
  } else {
    clear_has_boundary();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Subsignal.boundary)
}

// -------------------------------------------------------------------

// Signal

// optional .COWA.MapData.Id id = 1;
inline bool Signal::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Signal::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Signal::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Signal::clear_id() {
  if (id_ != NULL) id_->::COWA::MapData::Id::Clear();
  clear_has_id();
}
inline const ::COWA::MapData::Id& Signal::id() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Signal.id)
  return id_ != NULL ? *id_
                         : *::COWA::MapData::Id::internal_default_instance();
}
inline ::COWA::MapData::Id* Signal::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    id_ = new ::COWA::MapData::Id;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Signal.id)
  return id_;
}
inline ::COWA::MapData::Id* Signal::release_id() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Signal.id)
  clear_has_id();
  ::COWA::MapData::Id* temp = id_;
  id_ = NULL;
  return temp;
}
inline void Signal::set_allocated_id(::COWA::MapData::Id* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Signal.id)
}

// repeated .COWA.MapData.Signal.Type type = 2;
inline int Signal::type_size() const {
  return type_.size();
}
inline void Signal::clear_type() {
  type_.Clear();
}
inline ::COWA::MapData::Signal_Type Signal::type(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Signal.type)
  return static_cast< ::COWA::MapData::Signal_Type >(type_.Get(index));
}
inline void Signal::set_type(int index, ::COWA::MapData::Signal_Type value) {
  assert(::COWA::MapData::Signal_Type_IsValid(value));
  type_.Set(index, value);
  // @@protoc_insertion_point(field_set:COWA.MapData.Signal.type)
}
inline void Signal::add_type(::COWA::MapData::Signal_Type value) {
  assert(::COWA::MapData::Signal_Type_IsValid(value));
  type_.Add(value);
  // @@protoc_insertion_point(field_add:COWA.MapData.Signal.type)
}
inline const ::google::protobuf::RepeatedField<int>&
Signal::type() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.Signal.type)
  return type_;
}
inline ::google::protobuf::RepeatedField<int>*
Signal::mutable_type() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.Signal.type)
  return &type_;
}

// repeated .COWA.MapData.Subsignal subsignal = 3;
inline int Signal::subsignal_size() const {
  return subsignal_.size();
}
inline void Signal::clear_subsignal() {
  subsignal_.Clear();
}
inline const ::COWA::MapData::Subsignal& Signal::subsignal(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Signal.subsignal)
  return subsignal_.Get(index);
}
inline ::COWA::MapData::Subsignal* Signal::mutable_subsignal(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Signal.subsignal)
  return subsignal_.Mutable(index);
}
inline ::COWA::MapData::Subsignal* Signal::add_subsignal() {
  // @@protoc_insertion_point(field_add:COWA.MapData.Signal.subsignal)
  return subsignal_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Subsignal >*
Signal::mutable_subsignal() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.Signal.subsignal)
  return &subsignal_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Subsignal >&
Signal::subsignal() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.Signal.subsignal)
  return subsignal_;
}

// repeated .COWA.MapData.PointENU stop_line = 5;
inline int Signal::stop_line_size() const {
  return stop_line_.size();
}
inline void Signal::clear_stop_line() {
  stop_line_.Clear();
}
inline const ::COWA::MapData::PointENU& Signal::stop_line(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Signal.stop_line)
  return stop_line_.Get(index);
}
inline ::COWA::MapData::PointENU* Signal::mutable_stop_line(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Signal.stop_line)
  return stop_line_.Mutable(index);
}
inline ::COWA::MapData::PointENU* Signal::add_stop_line() {
  // @@protoc_insertion_point(field_add:COWA.MapData.Signal.stop_line)
  return stop_line_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::PointENU >*
Signal::mutable_stop_line() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.Signal.stop_line)
  return &stop_line_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::PointENU >&
Signal::stop_line() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.Signal.stop_line)
  return stop_line_;
}

// repeated .COWA.MapData.Id wait_lane = 6;
inline int Signal::wait_lane_size() const {
  return wait_lane_.size();
}
inline void Signal::clear_wait_lane() {
  wait_lane_.Clear();
}
inline const ::COWA::MapData::Id& Signal::wait_lane(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Signal.wait_lane)
  return wait_lane_.Get(index);
}
inline ::COWA::MapData::Id* Signal::mutable_wait_lane(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Signal.wait_lane)
  return wait_lane_.Mutable(index);
}
inline ::COWA::MapData::Id* Signal::add_wait_lane() {
  // @@protoc_insertion_point(field_add:COWA.MapData.Signal.wait_lane)
  return wait_lane_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >*
Signal::mutable_wait_lane() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.Signal.wait_lane)
  return &wait_lane_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >&
Signal::wait_lane() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.Signal.wait_lane)
  return wait_lane_;
}

// optional .COWA.MapData.Id wait_signal = 7;
inline bool Signal::has_wait_signal() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Signal::set_has_wait_signal() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Signal::clear_has_wait_signal() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Signal::clear_wait_signal() {
  if (wait_signal_ != NULL) wait_signal_->::COWA::MapData::Id::Clear();
  clear_has_wait_signal();
}
inline const ::COWA::MapData::Id& Signal::wait_signal() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Signal.wait_signal)
  return wait_signal_ != NULL ? *wait_signal_
                         : *::COWA::MapData::Id::internal_default_instance();
}
inline ::COWA::MapData::Id* Signal::mutable_wait_signal() {
  set_has_wait_signal();
  if (wait_signal_ == NULL) {
    wait_signal_ = new ::COWA::MapData::Id;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Signal.wait_signal)
  return wait_signal_;
}
inline ::COWA::MapData::Id* Signal::release_wait_signal() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Signal.wait_signal)
  clear_has_wait_signal();
  ::COWA::MapData::Id* temp = wait_signal_;
  wait_signal_ = NULL;
  return temp;
}
inline void Signal::set_allocated_wait_signal(::COWA::MapData::Id* wait_signal) {
  delete wait_signal_;
  wait_signal_ = wait_signal;
  if (wait_signal) {
    set_has_wait_signal();
  } else {
    clear_has_wait_signal();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Signal.wait_signal)
}

// -------------------------------------------------------------------

// Crossroad_Line

// repeated .COWA.MapData.Id signals = 1;
inline int Crossroad_Line::signals_size() const {
  return signals_.size();
}
inline void Crossroad_Line::clear_signals() {
  signals_.Clear();
}
inline const ::COWA::MapData::Id& Crossroad_Line::signals(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Crossroad.Line.signals)
  return signals_.Get(index);
}
inline ::COWA::MapData::Id* Crossroad_Line::mutable_signals(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Crossroad.Line.signals)
  return signals_.Mutable(index);
}
inline ::COWA::MapData::Id* Crossroad_Line::add_signals() {
  // @@protoc_insertion_point(field_add:COWA.MapData.Crossroad.Line.signals)
  return signals_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >*
Crossroad_Line::mutable_signals() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.Crossroad.Line.signals)
  return &signals_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >&
Crossroad_Line::signals() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.Crossroad.Line.signals)
  return signals_;
}

// repeated .COWA.MapData.Id lane_in = 2;
inline int Crossroad_Line::lane_in_size() const {
  return lane_in_.size();
}
inline void Crossroad_Line::clear_lane_in() {
  lane_in_.Clear();
}
inline const ::COWA::MapData::Id& Crossroad_Line::lane_in(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Crossroad.Line.lane_in)
  return lane_in_.Get(index);
}
inline ::COWA::MapData::Id* Crossroad_Line::mutable_lane_in(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Crossroad.Line.lane_in)
  return lane_in_.Mutable(index);
}
inline ::COWA::MapData::Id* Crossroad_Line::add_lane_in() {
  // @@protoc_insertion_point(field_add:COWA.MapData.Crossroad.Line.lane_in)
  return lane_in_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >*
Crossroad_Line::mutable_lane_in() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.Crossroad.Line.lane_in)
  return &lane_in_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >&
Crossroad_Line::lane_in() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.Crossroad.Line.lane_in)
  return lane_in_;
}

// repeated .COWA.MapData.Id lane_out = 3;
inline int Crossroad_Line::lane_out_size() const {
  return lane_out_.size();
}
inline void Crossroad_Line::clear_lane_out() {
  lane_out_.Clear();
}
inline const ::COWA::MapData::Id& Crossroad_Line::lane_out(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Crossroad.Line.lane_out)
  return lane_out_.Get(index);
}
inline ::COWA::MapData::Id* Crossroad_Line::mutable_lane_out(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Crossroad.Line.lane_out)
  return lane_out_.Mutable(index);
}
inline ::COWA::MapData::Id* Crossroad_Line::add_lane_out() {
  // @@protoc_insertion_point(field_add:COWA.MapData.Crossroad.Line.lane_out)
  return lane_out_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >*
Crossroad_Line::mutable_lane_out() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.Crossroad.Line.lane_out)
  return &lane_out_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >&
Crossroad_Line::lane_out() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.Crossroad.Line.lane_out)
  return lane_out_;
}

// repeated .COWA.MapData.Id road = 4;
inline int Crossroad_Line::road_size() const {
  return road_.size();
}
inline void Crossroad_Line::clear_road() {
  road_.Clear();
}
inline const ::COWA::MapData::Id& Crossroad_Line::road(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Crossroad.Line.road)
  return road_.Get(index);
}
inline ::COWA::MapData::Id* Crossroad_Line::mutable_road(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Crossroad.Line.road)
  return road_.Mutable(index);
}
inline ::COWA::MapData::Id* Crossroad_Line::add_road() {
  // @@protoc_insertion_point(field_add:COWA.MapData.Crossroad.Line.road)
  return road_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >*
Crossroad_Line::mutable_road() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.Crossroad.Line.road)
  return &road_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >&
Crossroad_Line::road() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.Crossroad.Line.road)
  return road_;
}

// -------------------------------------------------------------------

// Crossroad

// optional .COWA.MapData.Id id = 1;
inline bool Crossroad::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Crossroad::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Crossroad::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Crossroad::clear_id() {
  if (id_ != NULL) id_->::COWA::MapData::Id::Clear();
  clear_has_id();
}
inline const ::COWA::MapData::Id& Crossroad::id() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Crossroad.id)
  return id_ != NULL ? *id_
                         : *::COWA::MapData::Id::internal_default_instance();
}
inline ::COWA::MapData::Id* Crossroad::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    id_ = new ::COWA::MapData::Id;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Crossroad.id)
  return id_;
}
inline ::COWA::MapData::Id* Crossroad::release_id() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Crossroad.id)
  clear_has_id();
  ::COWA::MapData::Id* temp = id_;
  id_ = NULL;
  return temp;
}
inline void Crossroad::set_allocated_id(::COWA::MapData::Id* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Crossroad.id)
}

// repeated .COWA.MapData.Crossroad.Line group = 2;
inline int Crossroad::group_size() const {
  return group_.size();
}
inline void Crossroad::clear_group() {
  group_.Clear();
}
inline const ::COWA::MapData::Crossroad_Line& Crossroad::group(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Crossroad.group)
  return group_.Get(index);
}
inline ::COWA::MapData::Crossroad_Line* Crossroad::mutable_group(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Crossroad.group)
  return group_.Mutable(index);
}
inline ::COWA::MapData::Crossroad_Line* Crossroad::add_group() {
  // @@protoc_insertion_point(field_add:COWA.MapData.Crossroad.group)
  return group_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Crossroad_Line >*
Crossroad::mutable_group() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.Crossroad.group)
  return &group_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Crossroad_Line >&
Crossroad::group() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.Crossroad.group)
  return group_;
}

// optional .COWA.MapData.Polygon boundary = 3;
inline bool Crossroad::has_boundary() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Crossroad::set_has_boundary() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Crossroad::clear_has_boundary() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Crossroad::clear_boundary() {
  if (boundary_ != NULL) boundary_->::COWA::MapData::Polygon::Clear();
  clear_has_boundary();
}
inline const ::COWA::MapData::Polygon& Crossroad::boundary() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Crossroad.boundary)
  return boundary_ != NULL ? *boundary_
                         : *::COWA::MapData::Polygon::internal_default_instance();
}
inline ::COWA::MapData::Polygon* Crossroad::mutable_boundary() {
  set_has_boundary();
  if (boundary_ == NULL) {
    boundary_ = new ::COWA::MapData::Polygon;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Crossroad.boundary)
  return boundary_;
}
inline ::COWA::MapData::Polygon* Crossroad::release_boundary() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Crossroad.boundary)
  clear_has_boundary();
  ::COWA::MapData::Polygon* temp = boundary_;
  boundary_ = NULL;
  return temp;
}
inline void Crossroad::set_allocated_boundary(::COWA::MapData::Polygon* boundary) {
  delete boundary_;
  boundary_ = boundary;
  if (boundary) {
    set_has_boundary();
  } else {
    clear_has_boundary();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Crossroad.boundary)
}

// optional .COWA.MapData.Crossroad.Type type = 4;
inline bool Crossroad::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Crossroad::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Crossroad::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Crossroad::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::COWA::MapData::Crossroad_Type Crossroad::type() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Crossroad.type)
  return static_cast< ::COWA::MapData::Crossroad_Type >(type_);
}
inline void Crossroad::set_type(::COWA::MapData::Crossroad_Type value) {
  assert(::COWA::MapData::Crossroad_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.Crossroad.type)
}

// -------------------------------------------------------------------

// LaneChange

// optional .COWA.MapData.Id id = 1;
inline bool LaneChange::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaneChange::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LaneChange::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LaneChange::clear_id() {
  if (id_ != NULL) id_->::COWA::MapData::Id::Clear();
  clear_has_id();
}
inline const ::COWA::MapData::Id& LaneChange::id() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.LaneChange.id)
  return id_ != NULL ? *id_
                         : *::COWA::MapData::Id::internal_default_instance();
}
inline ::COWA::MapData::Id* LaneChange::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    id_ = new ::COWA::MapData::Id;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.LaneChange.id)
  return id_;
}
inline ::COWA::MapData::Id* LaneChange::release_id() {
  // @@protoc_insertion_point(field_release:COWA.MapData.LaneChange.id)
  clear_has_id();
  ::COWA::MapData::Id* temp = id_;
  id_ = NULL;
  return temp;
}
inline void LaneChange::set_allocated_id(::COWA::MapData::Id* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.LaneChange.id)
}

// repeated .COWA.MapData.Id lane_in = 2;
inline int LaneChange::lane_in_size() const {
  return lane_in_.size();
}
inline void LaneChange::clear_lane_in() {
  lane_in_.Clear();
}
inline const ::COWA::MapData::Id& LaneChange::lane_in(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.LaneChange.lane_in)
  return lane_in_.Get(index);
}
inline ::COWA::MapData::Id* LaneChange::mutable_lane_in(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.LaneChange.lane_in)
  return lane_in_.Mutable(index);
}
inline ::COWA::MapData::Id* LaneChange::add_lane_in() {
  // @@protoc_insertion_point(field_add:COWA.MapData.LaneChange.lane_in)
  return lane_in_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >*
LaneChange::mutable_lane_in() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.LaneChange.lane_in)
  return &lane_in_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >&
LaneChange::lane_in() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.LaneChange.lane_in)
  return lane_in_;
}

// repeated .COWA.MapData.Id lane_out = 3;
inline int LaneChange::lane_out_size() const {
  return lane_out_.size();
}
inline void LaneChange::clear_lane_out() {
  lane_out_.Clear();
}
inline const ::COWA::MapData::Id& LaneChange::lane_out(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.LaneChange.lane_out)
  return lane_out_.Get(index);
}
inline ::COWA::MapData::Id* LaneChange::mutable_lane_out(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.LaneChange.lane_out)
  return lane_out_.Mutable(index);
}
inline ::COWA::MapData::Id* LaneChange::add_lane_out() {
  // @@protoc_insertion_point(field_add:COWA.MapData.LaneChange.lane_out)
  return lane_out_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >*
LaneChange::mutable_lane_out() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.LaneChange.lane_out)
  return &lane_out_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Id >&
LaneChange::lane_out() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.LaneChange.lane_out)
  return lane_out_;
}

// optional .COWA.MapData.Polygon boundary = 4;
inline bool LaneChange::has_boundary() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaneChange::set_has_boundary() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LaneChange::clear_has_boundary() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LaneChange::clear_boundary() {
  if (boundary_ != NULL) boundary_->::COWA::MapData::Polygon::Clear();
  clear_has_boundary();
}
inline const ::COWA::MapData::Polygon& LaneChange::boundary() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.LaneChange.boundary)
  return boundary_ != NULL ? *boundary_
                         : *::COWA::MapData::Polygon::internal_default_instance();
}
inline ::COWA::MapData::Polygon* LaneChange::mutable_boundary() {
  set_has_boundary();
  if (boundary_ == NULL) {
    boundary_ = new ::COWA::MapData::Polygon;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.LaneChange.boundary)
  return boundary_;
}
inline ::COWA::MapData::Polygon* LaneChange::release_boundary() {
  // @@protoc_insertion_point(field_release:COWA.MapData.LaneChange.boundary)
  clear_has_boundary();
  ::COWA::MapData::Polygon* temp = boundary_;
  boundary_ = NULL;
  return temp;
}
inline void LaneChange::set_allocated_boundary(::COWA::MapData::Polygon* boundary) {
  delete boundary_;
  boundary_ = boundary;
  if (boundary) {
    set_has_boundary();
  } else {
    clear_has_boundary();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.LaneChange.boundary)
}

// -------------------------------------------------------------------

// HdMap

// optional .COWA.MapData.Header header = 1;
inline bool HdMap::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HdMap::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HdMap::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HdMap::clear_header() {
  if (header_ != NULL) header_->::COWA::MapData::Header::Clear();
  clear_has_header();
}
inline const ::COWA::MapData::Header& HdMap::header() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.HdMap.header)
  return header_ != NULL ? *header_
                         : *::COWA::MapData::Header::internal_default_instance();
}
inline ::COWA::MapData::Header* HdMap::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::COWA::MapData::Header;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.HdMap.header)
  return header_;
}
inline ::COWA::MapData::Header* HdMap::release_header() {
  // @@protoc_insertion_point(field_release:COWA.MapData.HdMap.header)
  clear_has_header();
  ::COWA::MapData::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void HdMap::set_allocated_header(::COWA::MapData::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.HdMap.header)
}

// repeated .COWA.MapData.Road road = 7;
inline int HdMap::road_size() const {
  return road_.size();
}
inline void HdMap::clear_road() {
  road_.Clear();
}
inline const ::COWA::MapData::Road& HdMap::road(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.HdMap.road)
  return road_.Get(index);
}
inline ::COWA::MapData::Road* HdMap::mutable_road(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.HdMap.road)
  return road_.Mutable(index);
}
inline ::COWA::MapData::Road* HdMap::add_road() {
  // @@protoc_insertion_point(field_add:COWA.MapData.HdMap.road)
  return road_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Road >*
HdMap::mutable_road() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.HdMap.road)
  return &road_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Road >&
HdMap::road() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.HdMap.road)
  return road_;
}

// repeated .COWA.MapData.LaneCurve lane_curve = 11;
inline int HdMap::lane_curve_size() const {
  return lane_curve_.size();
}
inline void HdMap::clear_lane_curve() {
  lane_curve_.Clear();
}
inline const ::COWA::MapData::LaneCurve& HdMap::lane_curve(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.HdMap.lane_curve)
  return lane_curve_.Get(index);
}
inline ::COWA::MapData::LaneCurve* HdMap::mutable_lane_curve(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.HdMap.lane_curve)
  return lane_curve_.Mutable(index);
}
inline ::COWA::MapData::LaneCurve* HdMap::add_lane_curve() {
  // @@protoc_insertion_point(field_add:COWA.MapData.HdMap.lane_curve)
  return lane_curve_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::LaneCurve >*
HdMap::mutable_lane_curve() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.HdMap.lane_curve)
  return &lane_curve_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::LaneCurve >&
HdMap::lane_curve() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.HdMap.lane_curve)
  return lane_curve_;
}

// repeated .COWA.MapData.Lane lane = 2;
inline int HdMap::lane_size() const {
  return lane_.size();
}
inline void HdMap::clear_lane() {
  lane_.Clear();
}
inline const ::COWA::MapData::Lane& HdMap::lane(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.HdMap.lane)
  return lane_.Get(index);
}
inline ::COWA::MapData::Lane* HdMap::mutable_lane(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.HdMap.lane)
  return lane_.Mutable(index);
}
inline ::COWA::MapData::Lane* HdMap::add_lane() {
  // @@protoc_insertion_point(field_add:COWA.MapData.HdMap.lane)
  return lane_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Lane >*
HdMap::mutable_lane() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.HdMap.lane)
  return &lane_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Lane >&
HdMap::lane() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.HdMap.lane)
  return lane_;
}

// repeated .COWA.MapData.Crosswalk crosswalk = 3;
inline int HdMap::crosswalk_size() const {
  return crosswalk_.size();
}
inline void HdMap::clear_crosswalk() {
  crosswalk_.Clear();
}
inline const ::COWA::MapData::Crosswalk& HdMap::crosswalk(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.HdMap.crosswalk)
  return crosswalk_.Get(index);
}
inline ::COWA::MapData::Crosswalk* HdMap::mutable_crosswalk(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.HdMap.crosswalk)
  return crosswalk_.Mutable(index);
}
inline ::COWA::MapData::Crosswalk* HdMap::add_crosswalk() {
  // @@protoc_insertion_point(field_add:COWA.MapData.HdMap.crosswalk)
  return crosswalk_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Crosswalk >*
HdMap::mutable_crosswalk() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.HdMap.crosswalk)
  return &crosswalk_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Crosswalk >&
HdMap::crosswalk() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.HdMap.crosswalk)
  return crosswalk_;
}

// repeated .COWA.MapData.Signal signal = 4;
inline int HdMap::signal_size() const {
  return signal_.size();
}
inline void HdMap::clear_signal() {
  signal_.Clear();
}
inline const ::COWA::MapData::Signal& HdMap::signal(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.HdMap.signal)
  return signal_.Get(index);
}
inline ::COWA::MapData::Signal* HdMap::mutable_signal(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.HdMap.signal)
  return signal_.Mutable(index);
}
inline ::COWA::MapData::Signal* HdMap::add_signal() {
  // @@protoc_insertion_point(field_add:COWA.MapData.HdMap.signal)
  return signal_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Signal >*
HdMap::mutable_signal() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.HdMap.signal)
  return &signal_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Signal >&
HdMap::signal() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.HdMap.signal)
  return signal_;
}

// repeated .COWA.MapData.Crossroad crossroad = 5;
inline int HdMap::crossroad_size() const {
  return crossroad_.size();
}
inline void HdMap::clear_crossroad() {
  crossroad_.Clear();
}
inline const ::COWA::MapData::Crossroad& HdMap::crossroad(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.HdMap.crossroad)
  return crossroad_.Get(index);
}
inline ::COWA::MapData::Crossroad* HdMap::mutable_crossroad(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.HdMap.crossroad)
  return crossroad_.Mutable(index);
}
inline ::COWA::MapData::Crossroad* HdMap::add_crossroad() {
  // @@protoc_insertion_point(field_add:COWA.MapData.HdMap.crossroad)
  return crossroad_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Crossroad >*
HdMap::mutable_crossroad() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.HdMap.crossroad)
  return &crossroad_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Crossroad >&
HdMap::crossroad() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.HdMap.crossroad)
  return crossroad_;
}

// repeated .COWA.MapData.Ramp ramp = 6;
inline int HdMap::ramp_size() const {
  return ramp_.size();
}
inline void HdMap::clear_ramp() {
  ramp_.Clear();
}
inline const ::COWA::MapData::Ramp& HdMap::ramp(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.HdMap.ramp)
  return ramp_.Get(index);
}
inline ::COWA::MapData::Ramp* HdMap::mutable_ramp(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.HdMap.ramp)
  return ramp_.Mutable(index);
}
inline ::COWA::MapData::Ramp* HdMap::add_ramp() {
  // @@protoc_insertion_point(field_add:COWA.MapData.HdMap.ramp)
  return ramp_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Ramp >*
HdMap::mutable_ramp() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.HdMap.ramp)
  return &ramp_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Ramp >&
HdMap::ramp() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.HdMap.ramp)
  return ramp_;
}

// repeated .COWA.MapData.Roadmark roadmark = 8;
inline int HdMap::roadmark_size() const {
  return roadmark_.size();
}
inline void HdMap::clear_roadmark() {
  roadmark_.Clear();
}
inline const ::COWA::MapData::Roadmark& HdMap::roadmark(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.HdMap.roadmark)
  return roadmark_.Get(index);
}
inline ::COWA::MapData::Roadmark* HdMap::mutable_roadmark(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.HdMap.roadmark)
  return roadmark_.Mutable(index);
}
inline ::COWA::MapData::Roadmark* HdMap::add_roadmark() {
  // @@protoc_insertion_point(field_add:COWA.MapData.HdMap.roadmark)
  return roadmark_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Roadmark >*
HdMap::mutable_roadmark() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.HdMap.roadmark)
  return &roadmark_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Roadmark >&
HdMap::roadmark() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.HdMap.roadmark)
  return roadmark_;
}

// repeated .COWA.MapData.ParkingSpace parking_space = 9;
inline int HdMap::parking_space_size() const {
  return parking_space_.size();
}
inline void HdMap::clear_parking_space() {
  parking_space_.Clear();
}
inline const ::COWA::MapData::ParkingSpace& HdMap::parking_space(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.HdMap.parking_space)
  return parking_space_.Get(index);
}
inline ::COWA::MapData::ParkingSpace* HdMap::mutable_parking_space(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.HdMap.parking_space)
  return parking_space_.Mutable(index);
}
inline ::COWA::MapData::ParkingSpace* HdMap::add_parking_space() {
  // @@protoc_insertion_point(field_add:COWA.MapData.HdMap.parking_space)
  return parking_space_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::ParkingSpace >*
HdMap::mutable_parking_space() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.HdMap.parking_space)
  return &parking_space_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::ParkingSpace >&
HdMap::parking_space() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.HdMap.parking_space)
  return parking_space_;
}

// repeated .COWA.MapData.Overlap overlap = 10;
inline int HdMap::overlap_size() const {
  return overlap_.size();
}
inline void HdMap::clear_overlap() {
  overlap_.Clear();
}
inline const ::COWA::MapData::Overlap& HdMap::overlap(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.HdMap.overlap)
  return overlap_.Get(index);
}
inline ::COWA::MapData::Overlap* HdMap::mutable_overlap(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.HdMap.overlap)
  return overlap_.Mutable(index);
}
inline ::COWA::MapData::Overlap* HdMap::add_overlap() {
  // @@protoc_insertion_point(field_add:COWA.MapData.HdMap.overlap)
  return overlap_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Overlap >*
HdMap::mutable_overlap() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.HdMap.overlap)
  return &overlap_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Overlap >&
HdMap::overlap() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.HdMap.overlap)
  return overlap_;
}

// repeated .COWA.MapData.Object objects = 12;
inline int HdMap::objects_size() const {
  return objects_.size();
}
inline void HdMap::clear_objects() {
  objects_.Clear();
}
inline const ::COWA::MapData::Object& HdMap::objects(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.HdMap.objects)
  return objects_.Get(index);
}
inline ::COWA::MapData::Object* HdMap::mutable_objects(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.HdMap.objects)
  return objects_.Mutable(index);
}
inline ::COWA::MapData::Object* HdMap::add_objects() {
  // @@protoc_insertion_point(field_add:COWA.MapData.HdMap.objects)
  return objects_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Object >*
HdMap::mutable_objects() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.HdMap.objects)
  return &objects_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::Object >&
HdMap::objects() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.HdMap.objects)
  return objects_;
}

// repeated .COWA.MapData.LaneChange lane_change = 13;
inline int HdMap::lane_change_size() const {
  return lane_change_.size();
}
inline void HdMap::clear_lane_change() {
  lane_change_.Clear();
}
inline const ::COWA::MapData::LaneChange& HdMap::lane_change(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.HdMap.lane_change)
  return lane_change_.Get(index);
}
inline ::COWA::MapData::LaneChange* HdMap::mutable_lane_change(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.HdMap.lane_change)
  return lane_change_.Mutable(index);
}
inline ::COWA::MapData::LaneChange* HdMap::add_lane_change() {
  // @@protoc_insertion_point(field_add:COWA.MapData.HdMap.lane_change)
  return lane_change_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::LaneChange >*
HdMap::mutable_lane_change() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.HdMap.lane_change)
  return &lane_change_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::LaneChange >&
HdMap::lane_change() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.HdMap.lane_change)
  return lane_change_;
}

// repeated .COWA.MapData.LaneTide tide = 14;
inline int HdMap::tide_size() const {
  return tide_.size();
}
inline void HdMap::clear_tide() {
  tide_.Clear();
}
inline const ::COWA::MapData::LaneTide& HdMap::tide(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.HdMap.tide)
  return tide_.Get(index);
}
inline ::COWA::MapData::LaneTide* HdMap::mutable_tide(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.HdMap.tide)
  return tide_.Mutable(index);
}
inline ::COWA::MapData::LaneTide* HdMap::add_tide() {
  // @@protoc_insertion_point(field_add:COWA.MapData.HdMap.tide)
  return tide_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::COWA::MapData::LaneTide >*
HdMap::mutable_tide() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.HdMap.tide)
  return &tide_;
}
inline const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::LaneTide >&
HdMap::tide() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.HdMap.tide)
  return tide_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace MapData
}  // namespace COWA

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::COWA::MapData::LaneStrip_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::COWA::MapData::LaneStrip_Type>() {
  return ::COWA::MapData::LaneStrip_Type_descriptor();
}
template <> struct is_proto_enum< ::COWA::MapData::LanePoint_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::COWA::MapData::LanePoint_Type>() {
  return ::COWA::MapData::LanePoint_Type_descriptor();
}
template <> struct is_proto_enum< ::COWA::MapData::LaneCurve_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::COWA::MapData::LaneCurve_Type>() {
  return ::COWA::MapData::LaneCurve_Type_descriptor();
}
template <> struct is_proto_enum< ::COWA::MapData::Lane_LaneMark_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::COWA::MapData::Lane_LaneMark_Type>() {
  return ::COWA::MapData::Lane_LaneMark_Type_descriptor();
}
template <> struct is_proto_enum< ::COWA::MapData::Lane_LaneType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::COWA::MapData::Lane_LaneType>() {
  return ::COWA::MapData::Lane_LaneType_descriptor();
}
template <> struct is_proto_enum< ::COWA::MapData::Lane_LaneDirection> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::COWA::MapData::Lane_LaneDirection>() {
  return ::COWA::MapData::Lane_LaneDirection_descriptor();
}
template <> struct is_proto_enum< ::COWA::MapData::Lane_LaneTurn> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::COWA::MapData::Lane_LaneTurn>() {
  return ::COWA::MapData::Lane_LaneTurn_descriptor();
}
template <> struct is_proto_enum< ::COWA::MapData::Road_RoadType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::COWA::MapData::Road_RoadType>() {
  return ::COWA::MapData::Road_RoadType_descriptor();
}
template <> struct is_proto_enum< ::COWA::MapData::Roadmark_RoadmarkType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::COWA::MapData::Roadmark_RoadmarkType>() {
  return ::COWA::MapData::Roadmark_RoadmarkType_descriptor();
}
template <> struct is_proto_enum< ::COWA::MapData::Object_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::COWA::MapData::Object_Type>() {
  return ::COWA::MapData::Object_Type_descriptor();
}
template <> struct is_proto_enum< ::COWA::MapData::Subsignal_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::COWA::MapData::Subsignal_Type>() {
  return ::COWA::MapData::Subsignal_Type_descriptor();
}
template <> struct is_proto_enum< ::COWA::MapData::Signal_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::COWA::MapData::Signal_Type>() {
  return ::COWA::MapData::Signal_Type_descriptor();
}
template <> struct is_proto_enum< ::COWA::MapData::Crossroad_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::COWA::MapData::Crossroad_Type>() {
  return ::COWA::MapData::Crossroad_Type_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_hdmap_2eproto__INCLUDED
