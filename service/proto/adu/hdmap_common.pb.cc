// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: hdmap_common.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "hdmap_common.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace COWA {
namespace MapData {
class IdDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Id> {
} _Id_default_instance_;
class PointENUDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<PointENU> {
} _PointENU_default_instance_;
class PolygonDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Polygon> {
} _Polygon_default_instance_;
class CloudDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Cloud> {
} _Cloud_default_instance_;
class LaneOverlapInfoDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<LaneOverlapInfo> {
} _LaneOverlapInfo_default_instance_;
class SignalOverlapInfoDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<SignalOverlapInfo> {
} _SignalOverlapInfo_default_instance_;
class CrosswalkOverlapInfoDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<CrosswalkOverlapInfo> {
} _CrosswalkOverlapInfo_default_instance_;
class CrossroadOverlapInfoDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<CrossroadOverlapInfo> {
} _CrossroadOverlapInfo_default_instance_;
class RampOverlapInfoDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<RampOverlapInfo> {
} _RampOverlapInfo_default_instance_;
class RoadmarkOverlapInfoDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<RoadmarkOverlapInfo> {
} _RoadmarkOverlapInfo_default_instance_;
class RoadOverlapInfoDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<RoadOverlapInfo> {
} _RoadOverlapInfo_default_instance_;
class Overlap_ObjectOverlapInfoDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Overlap_ObjectOverlapInfo> {
  public:
  const ::COWA::MapData::LaneOverlapInfo* lane_;
  const ::COWA::MapData::SignalOverlapInfo* signal_;
  const ::COWA::MapData::CrossroadOverlapInfo* crossroad_;
  const ::COWA::MapData::CrosswalkOverlapInfo* crosswalk_;
  const ::COWA::MapData::RampOverlapInfo* ramp_;
  const ::COWA::MapData::RoadmarkOverlapInfo* roadmark_;
  const ::COWA::MapData::RoadOverlapInfo* road_;
} _Overlap_ObjectOverlapInfo_default_instance_;
class OverlapDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Overlap> {
} _Overlap_default_instance_;
class HeaderDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Header> {
} _Header_default_instance_;

namespace protobuf_hdmap_5fcommon_2eproto {


namespace {

::google::protobuf::Metadata file_level_metadata[14];

}  // namespace

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTableField
    const TableStruct::entries[] = {
  {0, 0, 0, ::google::protobuf::internal::kInvalidMask, 0, 0},
};

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::AuxillaryParseTableField
    const TableStruct::aux[] = {
  ::google::protobuf::internal::AuxillaryParseTableField(),
};
PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTable const
    TableStruct::schema[] = {
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
};

const ::google::protobuf::uint32 TableStruct::offsets[] = {
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Id, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Id, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Id, id_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointENU, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointENU, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointENU, x_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointENU, y_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointENU, z_),
  1,
  2,
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Polygon, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Polygon, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Polygon, point_),
  ~0u,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Cloud, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Cloud, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Cloud, xyz_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Cloud, offset_x_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Cloud, offset_y_),
  ~0u,
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaneOverlapInfo, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaneOverlapInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaneOverlapInfo, start_s_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaneOverlapInfo, end_s_),
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignalOverlapInfo, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignalOverlapInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignalOverlapInfo, reserved_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CrosswalkOverlapInfo, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CrosswalkOverlapInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CrosswalkOverlapInfo, reserved_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CrossroadOverlapInfo, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CrossroadOverlapInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CrossroadOverlapInfo, reserved_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RampOverlapInfo, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RampOverlapInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RampOverlapInfo, reserved_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RoadmarkOverlapInfo, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RoadmarkOverlapInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RoadmarkOverlapInfo, reserved_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RoadOverlapInfo, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RoadOverlapInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RoadOverlapInfo, reserved_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Overlap_ObjectOverlapInfo, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Overlap_ObjectOverlapInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Overlap_ObjectOverlapInfo, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Overlap_ObjectOverlapInfo, id_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_Overlap_ObjectOverlapInfo_default_instance_), lane_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_Overlap_ObjectOverlapInfo_default_instance_), signal_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_Overlap_ObjectOverlapInfo_default_instance_), crossroad_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_Overlap_ObjectOverlapInfo_default_instance_), crosswalk_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_Overlap_ObjectOverlapInfo_default_instance_), ramp_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_Overlap_ObjectOverlapInfo_default_instance_), roadmark_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_Overlap_ObjectOverlapInfo_default_instance_), road_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Overlap_ObjectOverlapInfo, overlap_info_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Overlap, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Overlap, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Overlap, first_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Overlap, second_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Overlap, polygon_),
  0,
  1,
  2,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Header, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Header, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Header, version_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Header, date_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Header, projection_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Header, generation_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Header, md5_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Header, log_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
};

static const ::google::protobuf::internal::MigrationSchema schemas[] = {
  { 0, 6, sizeof(Id)},
  { 7, 15, sizeof(PointENU)},
  { 18, 24, sizeof(Polygon)},
  { 25, 33, sizeof(Cloud)},
  { 36, 43, sizeof(LaneOverlapInfo)},
  { 45, 51, sizeof(SignalOverlapInfo)},
  { 52, 58, sizeof(CrosswalkOverlapInfo)},
  { 59, 65, sizeof(CrossroadOverlapInfo)},
  { 66, 72, sizeof(RampOverlapInfo)},
  { 73, 79, sizeof(RoadmarkOverlapInfo)},
  { 80, 86, sizeof(RoadOverlapInfo)},
  { 87, 101, sizeof(Overlap_ObjectOverlapInfo)},
  { 109, 117, sizeof(Overlap)},
  { 120, 131, sizeof(Header)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&_Id_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_PointENU_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Polygon_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Cloud_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_LaneOverlapInfo_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_SignalOverlapInfo_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_CrosswalkOverlapInfo_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_CrossroadOverlapInfo_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_RampOverlapInfo_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_RoadmarkOverlapInfo_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_RoadOverlapInfo_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Overlap_ObjectOverlapInfo_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Overlap_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Header_default_instance_),
};

namespace {

void protobuf_AssignDescriptors() {
  AddDescriptors();
  ::google::protobuf::MessageFactory* factory = NULL;
  AssignDescriptors(
      "hdmap_common.proto", schemas, file_default_instances, TableStruct::offsets, factory,
      file_level_metadata, NULL, NULL);
}

void protobuf_AssignDescriptorsOnce() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &protobuf_AssignDescriptors);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::internal::RegisterAllTypes(file_level_metadata, 14);
}

}  // namespace

void TableStruct::Shutdown() {
  _Id_default_instance_.Shutdown();
  delete file_level_metadata[0].reflection;
  _PointENU_default_instance_.Shutdown();
  delete file_level_metadata[1].reflection;
  _Polygon_default_instance_.Shutdown();
  delete file_level_metadata[2].reflection;
  _Cloud_default_instance_.Shutdown();
  delete file_level_metadata[3].reflection;
  _LaneOverlapInfo_default_instance_.Shutdown();
  delete file_level_metadata[4].reflection;
  _SignalOverlapInfo_default_instance_.Shutdown();
  delete file_level_metadata[5].reflection;
  _CrosswalkOverlapInfo_default_instance_.Shutdown();
  delete file_level_metadata[6].reflection;
  _CrossroadOverlapInfo_default_instance_.Shutdown();
  delete file_level_metadata[7].reflection;
  _RampOverlapInfo_default_instance_.Shutdown();
  delete file_level_metadata[8].reflection;
  _RoadmarkOverlapInfo_default_instance_.Shutdown();
  delete file_level_metadata[9].reflection;
  _RoadOverlapInfo_default_instance_.Shutdown();
  delete file_level_metadata[10].reflection;
  _Overlap_ObjectOverlapInfo_default_instance_.Shutdown();
  delete file_level_metadata[11].reflection;
  _Overlap_default_instance_.Shutdown();
  delete file_level_metadata[12].reflection;
  _Header_default_instance_.Shutdown();
  delete file_level_metadata[13].reflection;
}

void TableStruct::InitDefaultsImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::internal::InitProtobufDefaults();
  _Id_default_instance_.DefaultConstruct();
  _PointENU_default_instance_.DefaultConstruct();
  _Polygon_default_instance_.DefaultConstruct();
  _Cloud_default_instance_.DefaultConstruct();
  _LaneOverlapInfo_default_instance_.DefaultConstruct();
  _SignalOverlapInfo_default_instance_.DefaultConstruct();
  _CrosswalkOverlapInfo_default_instance_.DefaultConstruct();
  _CrossroadOverlapInfo_default_instance_.DefaultConstruct();
  _RampOverlapInfo_default_instance_.DefaultConstruct();
  _RoadmarkOverlapInfo_default_instance_.DefaultConstruct();
  _RoadOverlapInfo_default_instance_.DefaultConstruct();
  _Overlap_ObjectOverlapInfo_default_instance_.DefaultConstruct();
  _Overlap_default_instance_.DefaultConstruct();
  _Header_default_instance_.DefaultConstruct();
  _Overlap_ObjectOverlapInfo_default_instance_.get_mutable()->id_ = const_cast< ::COWA::MapData::Id*>(
      ::COWA::MapData::Id::internal_default_instance());
  _Overlap_ObjectOverlapInfo_default_instance_.lane_ = const_cast< ::COWA::MapData::LaneOverlapInfo*>(
      ::COWA::MapData::LaneOverlapInfo::internal_default_instance());
  _Overlap_ObjectOverlapInfo_default_instance_.signal_ = const_cast< ::COWA::MapData::SignalOverlapInfo*>(
      ::COWA::MapData::SignalOverlapInfo::internal_default_instance());
  _Overlap_ObjectOverlapInfo_default_instance_.crossroad_ = const_cast< ::COWA::MapData::CrossroadOverlapInfo*>(
      ::COWA::MapData::CrossroadOverlapInfo::internal_default_instance());
  _Overlap_ObjectOverlapInfo_default_instance_.crosswalk_ = const_cast< ::COWA::MapData::CrosswalkOverlapInfo*>(
      ::COWA::MapData::CrosswalkOverlapInfo::internal_default_instance());
  _Overlap_ObjectOverlapInfo_default_instance_.ramp_ = const_cast< ::COWA::MapData::RampOverlapInfo*>(
      ::COWA::MapData::RampOverlapInfo::internal_default_instance());
  _Overlap_ObjectOverlapInfo_default_instance_.roadmark_ = const_cast< ::COWA::MapData::RoadmarkOverlapInfo*>(
      ::COWA::MapData::RoadmarkOverlapInfo::internal_default_instance());
  _Overlap_ObjectOverlapInfo_default_instance_.road_ = const_cast< ::COWA::MapData::RoadOverlapInfo*>(
      ::COWA::MapData::RoadOverlapInfo::internal_default_instance());
  _Overlap_default_instance_.get_mutable()->first_ = const_cast< ::COWA::MapData::Overlap_ObjectOverlapInfo*>(
      ::COWA::MapData::Overlap_ObjectOverlapInfo::internal_default_instance());
  _Overlap_default_instance_.get_mutable()->second_ = const_cast< ::COWA::MapData::Overlap_ObjectOverlapInfo*>(
      ::COWA::MapData::Overlap_ObjectOverlapInfo::internal_default_instance());
  _Overlap_default_instance_.get_mutable()->polygon_ = const_cast< ::COWA::MapData::Polygon*>(
      ::COWA::MapData::Polygon::internal_default_instance());
}

void InitDefaults() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &TableStruct::InitDefaultsImpl);
}
void AddDescriptorsImpl() {
  InitDefaults();
  static const char descriptor[] = {
      "\n\022hdmap_common.proto\022\014COWA.MapData\"\020\n\002Id"
      "\022\n\n\002id\030\001 \001(\t\"8\n\010PointENU\022\016\n\001x\030\001 \001(\001:\003nan"
      "\022\016\n\001y\030\002 \001(\001:\003nan\022\014\n\001z\030\003 \001(\001:\0010\"0\n\007Polygo"
      "n\022%\n\005point\030\001 \003(\0132\026.COWA.MapData.PointENU"
      "\"8\n\005Cloud\022\013\n\003xyz\030\001 \003(\002\022\020\n\010offset_x\030\002 \001(\001"
      "\022\020\n\010offset_y\030\003 \001(\001\"1\n\017LaneOverlapInfo\022\017\n"
      "\007start_s\030\001 \001(\001\022\r\n\005end_s\030\002 \001(\001\"%\n\021SignalO"
      "verlapInfo\022\020\n\010reserved\030\001 \001(\005\"(\n\024Crosswal"
      "kOverlapInfo\022\020\n\010reserved\030\001 \001(\005\"(\n\024Crossr"
      "oadOverlapInfo\022\020\n\010reserved\030\001 \001(\005\"#\n\017Ramp"
      "OverlapInfo\022\020\n\010reserved\030\001 \001(\005\"\'\n\023Roadmar"
      "kOverlapInfo\022\020\n\010reserved\030\001 \001(\005\"#\n\017RoadOv"
      "erlapInfo\022\020\n\010reserved\030\001 \001(\005\"\317\004\n\007Overlap\022"
      "6\n\005first\030\002 \001(\0132\'.COWA.MapData.Overlap.Ob"
      "jectOverlapInfo\0227\n\006second\030\003 \001(\0132\'.COWA.M"
      "apData.Overlap.ObjectOverlapInfo\022&\n\007poly"
      "gon\030\004 \001(\0132\025.COWA.MapData.Polygon\032\252\003\n\021Obj"
      "ectOverlapInfo\022\034\n\002id\030\001 \001(\0132\020.COWA.MapDat"
      "a.Id\022-\n\004lane\030\002 \001(\0132\035.COWA.MapData.LaneOv"
      "erlapInfoH\000\0221\n\006signal\030\003 \001(\0132\037.COWA.MapDa"
      "ta.SignalOverlapInfoH\000\0227\n\tcrossroad\030\004 \001("
      "\0132\".COWA.MapData.CrossroadOverlapInfoH\000\022"
      "7\n\tcrosswalk\030\005 \001(\0132\".COWA.MapData.Crossw"
      "alkOverlapInfoH\000\022-\n\004ramp\030\006 \001(\0132\035.COWA.Ma"
      "pData.RampOverlapInfoH\000\0225\n\010roadmark\030\007 \001("
      "\0132!.COWA.MapData.RoadmarkOverlapInfoH\000\022-"
      "\n\004road\030\010 \001(\0132\035.COWA.MapData.RoadOverlapI"
      "nfoH\000B\016\n\014overlap_info\"i\n\006Header\022\017\n\007versi"
      "on\030\001 \001(\t\022\014\n\004date\030\002 \001(\t\022\022\n\nprojection\030\003 \001"
      "(\t\022\022\n\ngeneration\030\004 \001(\t\022\013\n\003md5\030\005 \001(\t\022\013\n\003l"
      "og\030\006 \003(\t"
  };
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
      descriptor, 1208);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "hdmap_common.proto", &protobuf_RegisterTypes);
  ::google::protobuf::internal::OnShutdown(&TableStruct::Shutdown);
}

void AddDescriptors() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &AddDescriptorsImpl);
}
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;

}  // namespace protobuf_hdmap_5fcommon_2eproto


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Id::kIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Id::Id()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_hdmap_5fcommon_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:COWA.MapData.Id)
}
Id::Id(const Id& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_id()) {
    id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.id_);
  }
  // @@protoc_insertion_point(copy_constructor:COWA.MapData.Id)
}

void Id::SharedCtor() {
  _cached_size_ = 0;
  id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

Id::~Id() {
  // @@protoc_insertion_point(destructor:COWA.MapData.Id)
  SharedDtor();
}

void Id::SharedDtor() {
  id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void Id::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Id::descriptor() {
  protobuf_hdmap_5fcommon_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_hdmap_5fcommon_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Id& Id::default_instance() {
  protobuf_hdmap_5fcommon_2eproto::InitDefaults();
  return *internal_default_instance();
}

Id* Id::New(::google::protobuf::Arena* arena) const {
  Id* n = new Id;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Id::Clear() {
// @@protoc_insertion_point(message_clear_start:COWA.MapData.Id)
  if (has_id()) {
    GOOGLE_DCHECK(!id_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*id_.UnsafeRawStringPointer())->clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Id::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:COWA.MapData.Id)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->id().data(), this->id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "COWA.MapData.Id.id");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:COWA.MapData.Id)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:COWA.MapData.Id)
  return false;
#undef DO_
}

void Id::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:COWA.MapData.Id)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->id().data(), this->id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "COWA.MapData.Id.id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->id(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:COWA.MapData.Id)
}

::google::protobuf::uint8* Id::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:COWA.MapData.Id)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->id().data(), this->id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "COWA.MapData.Id.id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->id(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:COWA.MapData.Id)
  return target;
}

size_t Id::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:COWA.MapData.Id)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // optional string id = 1;
  if (has_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->id());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Id::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:COWA.MapData.Id)
  GOOGLE_DCHECK_NE(&from, this);
  const Id* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Id>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:COWA.MapData.Id)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:COWA.MapData.Id)
    MergeFrom(*source);
  }
}

void Id::MergeFrom(const Id& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:COWA.MapData.Id)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_id()) {
    set_has_id();
    id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.id_);
  }
}

void Id::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:COWA.MapData.Id)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Id::CopyFrom(const Id& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:COWA.MapData.Id)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Id::IsInitialized() const {
  return true;
}

void Id::Swap(Id* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Id::InternalSwap(Id* other) {
  id_.Swap(&other->id_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Id::GetMetadata() const {
  protobuf_hdmap_5fcommon_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_hdmap_5fcommon_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Id

// optional string id = 1;
bool Id::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Id::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
void Id::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void Id::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
const ::std::string& Id::id() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Id.id)
  return id_.GetNoArena();
}
void Id::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:COWA.MapData.Id.id)
}
#if LANG_CXX11
void Id::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:COWA.MapData.Id.id)
}
#endif
void Id::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:COWA.MapData.Id.id)
}
void Id::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:COWA.MapData.Id.id)
}
::std::string* Id::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Id.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Id::release_id() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Id.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Id::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Id.id)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PointENU::kXFieldNumber;
const int PointENU::kYFieldNumber;
const int PointENU::kZFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PointENU::PointENU()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_hdmap_5fcommon_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:COWA.MapData.PointENU)
}
PointENU::PointENU(const PointENU& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&z_, &from.z_,
    reinterpret_cast<char*>(&y_) -
    reinterpret_cast<char*>(&z_) + sizeof(y_));
  // @@protoc_insertion_point(copy_constructor:COWA.MapData.PointENU)
}

void PointENU::SharedCtor() {
  _cached_size_ = 0;
  z_ = 0;
  x_ = ::google::protobuf::internal::NaN();
  y_ = ::google::protobuf::internal::NaN();
}

PointENU::~PointENU() {
  // @@protoc_insertion_point(destructor:COWA.MapData.PointENU)
  SharedDtor();
}

void PointENU::SharedDtor() {
}

void PointENU::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PointENU::descriptor() {
  protobuf_hdmap_5fcommon_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_hdmap_5fcommon_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const PointENU& PointENU::default_instance() {
  protobuf_hdmap_5fcommon_2eproto::InitDefaults();
  return *internal_default_instance();
}

PointENU* PointENU::New(::google::protobuf::Arena* arena) const {
  PointENU* n = new PointENU;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PointENU::Clear() {
// @@protoc_insertion_point(message_clear_start:COWA.MapData.PointENU)
  if (_has_bits_[0 / 32] & 7u) {
    z_ = 0;
    x_ = ::google::protobuf::internal::NaN();
    y_ = ::google::protobuf::internal::NaN();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool PointENU::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:COWA.MapData.PointENU)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double x = 1 [default = nan];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(9u)) {
          set_has_x();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double y = 2 [default = nan];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(17u)) {
          set_has_y();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double z = 3 [default = 0];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(25u)) {
          set_has_z();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &z_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:COWA.MapData.PointENU)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:COWA.MapData.PointENU)
  return false;
#undef DO_
}

void PointENU::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:COWA.MapData.PointENU)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double x = 1 [default = nan];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->x(), output);
  }

  // optional double y = 2 [default = nan];
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->y(), output);
  }

  // optional double z = 3 [default = 0];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->z(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:COWA.MapData.PointENU)
}

::google::protobuf::uint8* PointENU::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:COWA.MapData.PointENU)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double x = 1 [default = nan];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->x(), target);
  }

  // optional double y = 2 [default = nan];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->y(), target);
  }

  // optional double z = 3 [default = 0];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->z(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:COWA.MapData.PointENU)
  return target;
}

size_t PointENU::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:COWA.MapData.PointENU)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 7u) {
    // optional double z = 3 [default = 0];
    if (has_z()) {
      total_size += 1 + 8;
    }

    // optional double x = 1 [default = nan];
    if (has_x()) {
      total_size += 1 + 8;
    }

    // optional double y = 2 [default = nan];
    if (has_y()) {
      total_size += 1 + 8;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PointENU::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:COWA.MapData.PointENU)
  GOOGLE_DCHECK_NE(&from, this);
  const PointENU* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const PointENU>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:COWA.MapData.PointENU)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:COWA.MapData.PointENU)
    MergeFrom(*source);
  }
}

void PointENU::MergeFrom(const PointENU& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:COWA.MapData.PointENU)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      z_ = from.z_;
    }
    if (cached_has_bits & 0x00000002u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000004u) {
      y_ = from.y_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void PointENU::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:COWA.MapData.PointENU)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PointENU::CopyFrom(const PointENU& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:COWA.MapData.PointENU)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PointENU::IsInitialized() const {
  return true;
}

void PointENU::Swap(PointENU* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PointENU::InternalSwap(PointENU* other) {
  std::swap(z_, other->z_);
  std::swap(x_, other->x_);
  std::swap(y_, other->y_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PointENU::GetMetadata() const {
  protobuf_hdmap_5fcommon_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_hdmap_5fcommon_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PointENU

// optional double x = 1 [default = nan];
bool PointENU::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void PointENU::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
void PointENU::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
void PointENU::clear_x() {
  x_ = ::google::protobuf::internal::NaN();
  clear_has_x();
}
double PointENU::x() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.PointENU.x)
  return x_;
}
void PointENU::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.PointENU.x)
}

// optional double y = 2 [default = nan];
bool PointENU::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void PointENU::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
void PointENU::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
void PointENU::clear_y() {
  y_ = ::google::protobuf::internal::NaN();
  clear_has_y();
}
double PointENU::y() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.PointENU.y)
  return y_;
}
void PointENU::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.PointENU.y)
}

// optional double z = 3 [default = 0];
bool PointENU::has_z() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void PointENU::set_has_z() {
  _has_bits_[0] |= 0x00000001u;
}
void PointENU::clear_has_z() {
  _has_bits_[0] &= ~0x00000001u;
}
void PointENU::clear_z() {
  z_ = 0;
  clear_has_z();
}
double PointENU::z() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.PointENU.z)
  return z_;
}
void PointENU::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.PointENU.z)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Polygon::kPointFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Polygon::Polygon()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_hdmap_5fcommon_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:COWA.MapData.Polygon)
}
Polygon::Polygon(const Polygon& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      point_(from.point_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:COWA.MapData.Polygon)
}

void Polygon::SharedCtor() {
  _cached_size_ = 0;
}

Polygon::~Polygon() {
  // @@protoc_insertion_point(destructor:COWA.MapData.Polygon)
  SharedDtor();
}

void Polygon::SharedDtor() {
}

void Polygon::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Polygon::descriptor() {
  protobuf_hdmap_5fcommon_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_hdmap_5fcommon_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Polygon& Polygon::default_instance() {
  protobuf_hdmap_5fcommon_2eproto::InitDefaults();
  return *internal_default_instance();
}

Polygon* Polygon::New(::google::protobuf::Arena* arena) const {
  Polygon* n = new Polygon;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Polygon::Clear() {
// @@protoc_insertion_point(message_clear_start:COWA.MapData.Polygon)
  point_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Polygon::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:COWA.MapData.Polygon)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .COWA.MapData.PointENU point = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_point()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:COWA.MapData.Polygon)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:COWA.MapData.Polygon)
  return false;
#undef DO_
}

void Polygon::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:COWA.MapData.Polygon)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .COWA.MapData.PointENU point = 1;
  for (unsigned int i = 0, n = this->point_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->point(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:COWA.MapData.Polygon)
}

::google::protobuf::uint8* Polygon::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:COWA.MapData.Polygon)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .COWA.MapData.PointENU point = 1;
  for (unsigned int i = 0, n = this->point_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->point(i), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:COWA.MapData.Polygon)
  return target;
}

size_t Polygon::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:COWA.MapData.Polygon)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // repeated .COWA.MapData.PointENU point = 1;
  {
    unsigned int count = this->point_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->point(i));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Polygon::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:COWA.MapData.Polygon)
  GOOGLE_DCHECK_NE(&from, this);
  const Polygon* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Polygon>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:COWA.MapData.Polygon)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:COWA.MapData.Polygon)
    MergeFrom(*source);
  }
}

void Polygon::MergeFrom(const Polygon& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:COWA.MapData.Polygon)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  point_.MergeFrom(from.point_);
}

void Polygon::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:COWA.MapData.Polygon)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Polygon::CopyFrom(const Polygon& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:COWA.MapData.Polygon)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Polygon::IsInitialized() const {
  return true;
}

void Polygon::Swap(Polygon* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Polygon::InternalSwap(Polygon* other) {
  point_.InternalSwap(&other->point_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Polygon::GetMetadata() const {
  protobuf_hdmap_5fcommon_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_hdmap_5fcommon_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Polygon

// repeated .COWA.MapData.PointENU point = 1;
int Polygon::point_size() const {
  return point_.size();
}
void Polygon::clear_point() {
  point_.Clear();
}
const ::COWA::MapData::PointENU& Polygon::point(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Polygon.point)
  return point_.Get(index);
}
::COWA::MapData::PointENU* Polygon::mutable_point(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Polygon.point)
  return point_.Mutable(index);
}
::COWA::MapData::PointENU* Polygon::add_point() {
  // @@protoc_insertion_point(field_add:COWA.MapData.Polygon.point)
  return point_.Add();
}
::google::protobuf::RepeatedPtrField< ::COWA::MapData::PointENU >*
Polygon::mutable_point() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.Polygon.point)
  return &point_;
}
const ::google::protobuf::RepeatedPtrField< ::COWA::MapData::PointENU >&
Polygon::point() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.Polygon.point)
  return point_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Cloud::kXyzFieldNumber;
const int Cloud::kOffsetXFieldNumber;
const int Cloud::kOffsetYFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Cloud::Cloud()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_hdmap_5fcommon_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:COWA.MapData.Cloud)
}
Cloud::Cloud(const Cloud& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      xyz_(from.xyz_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&offset_x_, &from.offset_x_,
    reinterpret_cast<char*>(&offset_y_) -
    reinterpret_cast<char*>(&offset_x_) + sizeof(offset_y_));
  // @@protoc_insertion_point(copy_constructor:COWA.MapData.Cloud)
}

void Cloud::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&offset_x_, 0, reinterpret_cast<char*>(&offset_y_) -
    reinterpret_cast<char*>(&offset_x_) + sizeof(offset_y_));
}

Cloud::~Cloud() {
  // @@protoc_insertion_point(destructor:COWA.MapData.Cloud)
  SharedDtor();
}

void Cloud::SharedDtor() {
}

void Cloud::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Cloud::descriptor() {
  protobuf_hdmap_5fcommon_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_hdmap_5fcommon_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Cloud& Cloud::default_instance() {
  protobuf_hdmap_5fcommon_2eproto::InitDefaults();
  return *internal_default_instance();
}

Cloud* Cloud::New(::google::protobuf::Arena* arena) const {
  Cloud* n = new Cloud;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Cloud::Clear() {
// @@protoc_insertion_point(message_clear_start:COWA.MapData.Cloud)
  xyz_.Clear();
  if (_has_bits_[0 / 32] & 3u) {
    ::memset(&offset_x_, 0, reinterpret_cast<char*>(&offset_y_) -
      reinterpret_cast<char*>(&offset_x_) + sizeof(offset_y_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Cloud::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:COWA.MapData.Cloud)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated float xyz = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(13u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 13u, input, this->mutable_xyz())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) ==
                   static_cast< ::google::protobuf::uint8>(10u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_xyz())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double offset_x = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(17u)) {
          set_has_offset_x();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &offset_x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double offset_y = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(25u)) {
          set_has_offset_y();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &offset_y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:COWA.MapData.Cloud)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:COWA.MapData.Cloud)
  return false;
#undef DO_
}

void Cloud::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:COWA.MapData.Cloud)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated float xyz = 1;
  for (int i = 0, n = this->xyz_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      1, this->xyz(i), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional double offset_x = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->offset_x(), output);
  }

  // optional double offset_y = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->offset_y(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:COWA.MapData.Cloud)
}

::google::protobuf::uint8* Cloud::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:COWA.MapData.Cloud)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated float xyz = 1;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteFloatToArray(1, this->xyz_, target);

  cached_has_bits = _has_bits_[0];
  // optional double offset_x = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->offset_x(), target);
  }

  // optional double offset_y = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->offset_y(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:COWA.MapData.Cloud)
  return target;
}

size_t Cloud::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:COWA.MapData.Cloud)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // repeated float xyz = 1;
  {
    unsigned int count = this->xyz_size();
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->xyz_size());
    total_size += data_size;
  }

  if (_has_bits_[0 / 32] & 3u) {
    // optional double offset_x = 2;
    if (has_offset_x()) {
      total_size += 1 + 8;
    }

    // optional double offset_y = 3;
    if (has_offset_y()) {
      total_size += 1 + 8;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Cloud::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:COWA.MapData.Cloud)
  GOOGLE_DCHECK_NE(&from, this);
  const Cloud* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Cloud>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:COWA.MapData.Cloud)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:COWA.MapData.Cloud)
    MergeFrom(*source);
  }
}

void Cloud::MergeFrom(const Cloud& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:COWA.MapData.Cloud)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  xyz_.MergeFrom(from.xyz_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      offset_x_ = from.offset_x_;
    }
    if (cached_has_bits & 0x00000002u) {
      offset_y_ = from.offset_y_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Cloud::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:COWA.MapData.Cloud)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Cloud::CopyFrom(const Cloud& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:COWA.MapData.Cloud)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Cloud::IsInitialized() const {
  return true;
}

void Cloud::Swap(Cloud* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Cloud::InternalSwap(Cloud* other) {
  xyz_.InternalSwap(&other->xyz_);
  std::swap(offset_x_, other->offset_x_);
  std::swap(offset_y_, other->offset_y_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Cloud::GetMetadata() const {
  protobuf_hdmap_5fcommon_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_hdmap_5fcommon_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Cloud

// repeated float xyz = 1;
int Cloud::xyz_size() const {
  return xyz_.size();
}
void Cloud::clear_xyz() {
  xyz_.Clear();
}
float Cloud::xyz(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Cloud.xyz)
  return xyz_.Get(index);
}
void Cloud::set_xyz(int index, float value) {
  xyz_.Set(index, value);
  // @@protoc_insertion_point(field_set:COWA.MapData.Cloud.xyz)
}
void Cloud::add_xyz(float value) {
  xyz_.Add(value);
  // @@protoc_insertion_point(field_add:COWA.MapData.Cloud.xyz)
}
const ::google::protobuf::RepeatedField< float >&
Cloud::xyz() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.Cloud.xyz)
  return xyz_;
}
::google::protobuf::RepeatedField< float >*
Cloud::mutable_xyz() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.Cloud.xyz)
  return &xyz_;
}

// optional double offset_x = 2;
bool Cloud::has_offset_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Cloud::set_has_offset_x() {
  _has_bits_[0] |= 0x00000001u;
}
void Cloud::clear_has_offset_x() {
  _has_bits_[0] &= ~0x00000001u;
}
void Cloud::clear_offset_x() {
  offset_x_ = 0;
  clear_has_offset_x();
}
double Cloud::offset_x() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Cloud.offset_x)
  return offset_x_;
}
void Cloud::set_offset_x(double value) {
  set_has_offset_x();
  offset_x_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.Cloud.offset_x)
}

// optional double offset_y = 3;
bool Cloud::has_offset_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Cloud::set_has_offset_y() {
  _has_bits_[0] |= 0x00000002u;
}
void Cloud::clear_has_offset_y() {
  _has_bits_[0] &= ~0x00000002u;
}
void Cloud::clear_offset_y() {
  offset_y_ = 0;
  clear_has_offset_y();
}
double Cloud::offset_y() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Cloud.offset_y)
  return offset_y_;
}
void Cloud::set_offset_y(double value) {
  set_has_offset_y();
  offset_y_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.Cloud.offset_y)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int LaneOverlapInfo::kStartSFieldNumber;
const int LaneOverlapInfo::kEndSFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LaneOverlapInfo::LaneOverlapInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_hdmap_5fcommon_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:COWA.MapData.LaneOverlapInfo)
}
LaneOverlapInfo::LaneOverlapInfo(const LaneOverlapInfo& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&start_s_, &from.start_s_,
    reinterpret_cast<char*>(&end_s_) -
    reinterpret_cast<char*>(&start_s_) + sizeof(end_s_));
  // @@protoc_insertion_point(copy_constructor:COWA.MapData.LaneOverlapInfo)
}

void LaneOverlapInfo::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&start_s_, 0, reinterpret_cast<char*>(&end_s_) -
    reinterpret_cast<char*>(&start_s_) + sizeof(end_s_));
}

LaneOverlapInfo::~LaneOverlapInfo() {
  // @@protoc_insertion_point(destructor:COWA.MapData.LaneOverlapInfo)
  SharedDtor();
}

void LaneOverlapInfo::SharedDtor() {
}

void LaneOverlapInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LaneOverlapInfo::descriptor() {
  protobuf_hdmap_5fcommon_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_hdmap_5fcommon_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const LaneOverlapInfo& LaneOverlapInfo::default_instance() {
  protobuf_hdmap_5fcommon_2eproto::InitDefaults();
  return *internal_default_instance();
}

LaneOverlapInfo* LaneOverlapInfo::New(::google::protobuf::Arena* arena) const {
  LaneOverlapInfo* n = new LaneOverlapInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void LaneOverlapInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:COWA.MapData.LaneOverlapInfo)
  if (_has_bits_[0 / 32] & 3u) {
    ::memset(&start_s_, 0, reinterpret_cast<char*>(&end_s_) -
      reinterpret_cast<char*>(&start_s_) + sizeof(end_s_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool LaneOverlapInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:COWA.MapData.LaneOverlapInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double start_s = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(9u)) {
          set_has_start_s();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &start_s_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double end_s = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(17u)) {
          set_has_end_s();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &end_s_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:COWA.MapData.LaneOverlapInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:COWA.MapData.LaneOverlapInfo)
  return false;
#undef DO_
}

void LaneOverlapInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:COWA.MapData.LaneOverlapInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double start_s = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->start_s(), output);
  }

  // optional double end_s = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->end_s(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:COWA.MapData.LaneOverlapInfo)
}

::google::protobuf::uint8* LaneOverlapInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:COWA.MapData.LaneOverlapInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double start_s = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->start_s(), target);
  }

  // optional double end_s = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->end_s(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:COWA.MapData.LaneOverlapInfo)
  return target;
}

size_t LaneOverlapInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:COWA.MapData.LaneOverlapInfo)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 3u) {
    // optional double start_s = 1;
    if (has_start_s()) {
      total_size += 1 + 8;
    }

    // optional double end_s = 2;
    if (has_end_s()) {
      total_size += 1 + 8;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LaneOverlapInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:COWA.MapData.LaneOverlapInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const LaneOverlapInfo* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const LaneOverlapInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:COWA.MapData.LaneOverlapInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:COWA.MapData.LaneOverlapInfo)
    MergeFrom(*source);
  }
}

void LaneOverlapInfo::MergeFrom(const LaneOverlapInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:COWA.MapData.LaneOverlapInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      start_s_ = from.start_s_;
    }
    if (cached_has_bits & 0x00000002u) {
      end_s_ = from.end_s_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void LaneOverlapInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:COWA.MapData.LaneOverlapInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LaneOverlapInfo::CopyFrom(const LaneOverlapInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:COWA.MapData.LaneOverlapInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LaneOverlapInfo::IsInitialized() const {
  return true;
}

void LaneOverlapInfo::Swap(LaneOverlapInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LaneOverlapInfo::InternalSwap(LaneOverlapInfo* other) {
  std::swap(start_s_, other->start_s_);
  std::swap(end_s_, other->end_s_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata LaneOverlapInfo::GetMetadata() const {
  protobuf_hdmap_5fcommon_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_hdmap_5fcommon_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// LaneOverlapInfo

// optional double start_s = 1;
bool LaneOverlapInfo::has_start_s() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void LaneOverlapInfo::set_has_start_s() {
  _has_bits_[0] |= 0x00000001u;
}
void LaneOverlapInfo::clear_has_start_s() {
  _has_bits_[0] &= ~0x00000001u;
}
void LaneOverlapInfo::clear_start_s() {
  start_s_ = 0;
  clear_has_start_s();
}
double LaneOverlapInfo::start_s() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.LaneOverlapInfo.start_s)
  return start_s_;
}
void LaneOverlapInfo::set_start_s(double value) {
  set_has_start_s();
  start_s_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.LaneOverlapInfo.start_s)
}

// optional double end_s = 2;
bool LaneOverlapInfo::has_end_s() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void LaneOverlapInfo::set_has_end_s() {
  _has_bits_[0] |= 0x00000002u;
}
void LaneOverlapInfo::clear_has_end_s() {
  _has_bits_[0] &= ~0x00000002u;
}
void LaneOverlapInfo::clear_end_s() {
  end_s_ = 0;
  clear_has_end_s();
}
double LaneOverlapInfo::end_s() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.LaneOverlapInfo.end_s)
  return end_s_;
}
void LaneOverlapInfo::set_end_s(double value) {
  set_has_end_s();
  end_s_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.LaneOverlapInfo.end_s)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SignalOverlapInfo::kReservedFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SignalOverlapInfo::SignalOverlapInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_hdmap_5fcommon_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:COWA.MapData.SignalOverlapInfo)
}
SignalOverlapInfo::SignalOverlapInfo(const SignalOverlapInfo& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  reserved_ = from.reserved_;
  // @@protoc_insertion_point(copy_constructor:COWA.MapData.SignalOverlapInfo)
}

void SignalOverlapInfo::SharedCtor() {
  _cached_size_ = 0;
  reserved_ = 0;
}

SignalOverlapInfo::~SignalOverlapInfo() {
  // @@protoc_insertion_point(destructor:COWA.MapData.SignalOverlapInfo)
  SharedDtor();
}

void SignalOverlapInfo::SharedDtor() {
}

void SignalOverlapInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SignalOverlapInfo::descriptor() {
  protobuf_hdmap_5fcommon_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_hdmap_5fcommon_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const SignalOverlapInfo& SignalOverlapInfo::default_instance() {
  protobuf_hdmap_5fcommon_2eproto::InitDefaults();
  return *internal_default_instance();
}

SignalOverlapInfo* SignalOverlapInfo::New(::google::protobuf::Arena* arena) const {
  SignalOverlapInfo* n = new SignalOverlapInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SignalOverlapInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:COWA.MapData.SignalOverlapInfo)
  reserved_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool SignalOverlapInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:COWA.MapData.SignalOverlapInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 reserved = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          set_has_reserved();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &reserved_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:COWA.MapData.SignalOverlapInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:COWA.MapData.SignalOverlapInfo)
  return false;
#undef DO_
}

void SignalOverlapInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:COWA.MapData.SignalOverlapInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 reserved = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->reserved(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:COWA.MapData.SignalOverlapInfo)
}

::google::protobuf::uint8* SignalOverlapInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:COWA.MapData.SignalOverlapInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 reserved = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->reserved(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:COWA.MapData.SignalOverlapInfo)
  return target;
}

size_t SignalOverlapInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:COWA.MapData.SignalOverlapInfo)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // optional int32 reserved = 1;
  if (has_reserved()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->reserved());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SignalOverlapInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:COWA.MapData.SignalOverlapInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const SignalOverlapInfo* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const SignalOverlapInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:COWA.MapData.SignalOverlapInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:COWA.MapData.SignalOverlapInfo)
    MergeFrom(*source);
  }
}

void SignalOverlapInfo::MergeFrom(const SignalOverlapInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:COWA.MapData.SignalOverlapInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_reserved()) {
    set_reserved(from.reserved());
  }
}

void SignalOverlapInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:COWA.MapData.SignalOverlapInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SignalOverlapInfo::CopyFrom(const SignalOverlapInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:COWA.MapData.SignalOverlapInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignalOverlapInfo::IsInitialized() const {
  return true;
}

void SignalOverlapInfo::Swap(SignalOverlapInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SignalOverlapInfo::InternalSwap(SignalOverlapInfo* other) {
  std::swap(reserved_, other->reserved_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata SignalOverlapInfo::GetMetadata() const {
  protobuf_hdmap_5fcommon_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_hdmap_5fcommon_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SignalOverlapInfo

// optional int32 reserved = 1;
bool SignalOverlapInfo::has_reserved() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void SignalOverlapInfo::set_has_reserved() {
  _has_bits_[0] |= 0x00000001u;
}
void SignalOverlapInfo::clear_has_reserved() {
  _has_bits_[0] &= ~0x00000001u;
}
void SignalOverlapInfo::clear_reserved() {
  reserved_ = 0;
  clear_has_reserved();
}
::google::protobuf::int32 SignalOverlapInfo::reserved() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.SignalOverlapInfo.reserved)
  return reserved_;
}
void SignalOverlapInfo::set_reserved(::google::protobuf::int32 value) {
  set_has_reserved();
  reserved_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.SignalOverlapInfo.reserved)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CrosswalkOverlapInfo::kReservedFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CrosswalkOverlapInfo::CrosswalkOverlapInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_hdmap_5fcommon_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:COWA.MapData.CrosswalkOverlapInfo)
}
CrosswalkOverlapInfo::CrosswalkOverlapInfo(const CrosswalkOverlapInfo& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  reserved_ = from.reserved_;
  // @@protoc_insertion_point(copy_constructor:COWA.MapData.CrosswalkOverlapInfo)
}

void CrosswalkOverlapInfo::SharedCtor() {
  _cached_size_ = 0;
  reserved_ = 0;
}

CrosswalkOverlapInfo::~CrosswalkOverlapInfo() {
  // @@protoc_insertion_point(destructor:COWA.MapData.CrosswalkOverlapInfo)
  SharedDtor();
}

void CrosswalkOverlapInfo::SharedDtor() {
}

void CrosswalkOverlapInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CrosswalkOverlapInfo::descriptor() {
  protobuf_hdmap_5fcommon_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_hdmap_5fcommon_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const CrosswalkOverlapInfo& CrosswalkOverlapInfo::default_instance() {
  protobuf_hdmap_5fcommon_2eproto::InitDefaults();
  return *internal_default_instance();
}

CrosswalkOverlapInfo* CrosswalkOverlapInfo::New(::google::protobuf::Arena* arena) const {
  CrosswalkOverlapInfo* n = new CrosswalkOverlapInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CrosswalkOverlapInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:COWA.MapData.CrosswalkOverlapInfo)
  reserved_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool CrosswalkOverlapInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:COWA.MapData.CrosswalkOverlapInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 reserved = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          set_has_reserved();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &reserved_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:COWA.MapData.CrosswalkOverlapInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:COWA.MapData.CrosswalkOverlapInfo)
  return false;
#undef DO_
}

void CrosswalkOverlapInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:COWA.MapData.CrosswalkOverlapInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 reserved = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->reserved(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:COWA.MapData.CrosswalkOverlapInfo)
}

::google::protobuf::uint8* CrosswalkOverlapInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:COWA.MapData.CrosswalkOverlapInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 reserved = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->reserved(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:COWA.MapData.CrosswalkOverlapInfo)
  return target;
}

size_t CrosswalkOverlapInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:COWA.MapData.CrosswalkOverlapInfo)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // optional int32 reserved = 1;
  if (has_reserved()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->reserved());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CrosswalkOverlapInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:COWA.MapData.CrosswalkOverlapInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const CrosswalkOverlapInfo* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const CrosswalkOverlapInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:COWA.MapData.CrosswalkOverlapInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:COWA.MapData.CrosswalkOverlapInfo)
    MergeFrom(*source);
  }
}

void CrosswalkOverlapInfo::MergeFrom(const CrosswalkOverlapInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:COWA.MapData.CrosswalkOverlapInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_reserved()) {
    set_reserved(from.reserved());
  }
}

void CrosswalkOverlapInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:COWA.MapData.CrosswalkOverlapInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CrosswalkOverlapInfo::CopyFrom(const CrosswalkOverlapInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:COWA.MapData.CrosswalkOverlapInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CrosswalkOverlapInfo::IsInitialized() const {
  return true;
}

void CrosswalkOverlapInfo::Swap(CrosswalkOverlapInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CrosswalkOverlapInfo::InternalSwap(CrosswalkOverlapInfo* other) {
  std::swap(reserved_, other->reserved_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CrosswalkOverlapInfo::GetMetadata() const {
  protobuf_hdmap_5fcommon_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_hdmap_5fcommon_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CrosswalkOverlapInfo

// optional int32 reserved = 1;
bool CrosswalkOverlapInfo::has_reserved() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CrosswalkOverlapInfo::set_has_reserved() {
  _has_bits_[0] |= 0x00000001u;
}
void CrosswalkOverlapInfo::clear_has_reserved() {
  _has_bits_[0] &= ~0x00000001u;
}
void CrosswalkOverlapInfo::clear_reserved() {
  reserved_ = 0;
  clear_has_reserved();
}
::google::protobuf::int32 CrosswalkOverlapInfo::reserved() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.CrosswalkOverlapInfo.reserved)
  return reserved_;
}
void CrosswalkOverlapInfo::set_reserved(::google::protobuf::int32 value) {
  set_has_reserved();
  reserved_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.CrosswalkOverlapInfo.reserved)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CrossroadOverlapInfo::kReservedFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CrossroadOverlapInfo::CrossroadOverlapInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_hdmap_5fcommon_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:COWA.MapData.CrossroadOverlapInfo)
}
CrossroadOverlapInfo::CrossroadOverlapInfo(const CrossroadOverlapInfo& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  reserved_ = from.reserved_;
  // @@protoc_insertion_point(copy_constructor:COWA.MapData.CrossroadOverlapInfo)
}

void CrossroadOverlapInfo::SharedCtor() {
  _cached_size_ = 0;
  reserved_ = 0;
}

CrossroadOverlapInfo::~CrossroadOverlapInfo() {
  // @@protoc_insertion_point(destructor:COWA.MapData.CrossroadOverlapInfo)
  SharedDtor();
}

void CrossroadOverlapInfo::SharedDtor() {
}

void CrossroadOverlapInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CrossroadOverlapInfo::descriptor() {
  protobuf_hdmap_5fcommon_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_hdmap_5fcommon_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const CrossroadOverlapInfo& CrossroadOverlapInfo::default_instance() {
  protobuf_hdmap_5fcommon_2eproto::InitDefaults();
  return *internal_default_instance();
}

CrossroadOverlapInfo* CrossroadOverlapInfo::New(::google::protobuf::Arena* arena) const {
  CrossroadOverlapInfo* n = new CrossroadOverlapInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CrossroadOverlapInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:COWA.MapData.CrossroadOverlapInfo)
  reserved_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool CrossroadOverlapInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:COWA.MapData.CrossroadOverlapInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 reserved = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          set_has_reserved();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &reserved_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:COWA.MapData.CrossroadOverlapInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:COWA.MapData.CrossroadOverlapInfo)
  return false;
#undef DO_
}

void CrossroadOverlapInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:COWA.MapData.CrossroadOverlapInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 reserved = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->reserved(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:COWA.MapData.CrossroadOverlapInfo)
}

::google::protobuf::uint8* CrossroadOverlapInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:COWA.MapData.CrossroadOverlapInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 reserved = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->reserved(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:COWA.MapData.CrossroadOverlapInfo)
  return target;
}

size_t CrossroadOverlapInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:COWA.MapData.CrossroadOverlapInfo)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // optional int32 reserved = 1;
  if (has_reserved()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->reserved());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CrossroadOverlapInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:COWA.MapData.CrossroadOverlapInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const CrossroadOverlapInfo* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const CrossroadOverlapInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:COWA.MapData.CrossroadOverlapInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:COWA.MapData.CrossroadOverlapInfo)
    MergeFrom(*source);
  }
}

void CrossroadOverlapInfo::MergeFrom(const CrossroadOverlapInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:COWA.MapData.CrossroadOverlapInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_reserved()) {
    set_reserved(from.reserved());
  }
}

void CrossroadOverlapInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:COWA.MapData.CrossroadOverlapInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CrossroadOverlapInfo::CopyFrom(const CrossroadOverlapInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:COWA.MapData.CrossroadOverlapInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CrossroadOverlapInfo::IsInitialized() const {
  return true;
}

void CrossroadOverlapInfo::Swap(CrossroadOverlapInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CrossroadOverlapInfo::InternalSwap(CrossroadOverlapInfo* other) {
  std::swap(reserved_, other->reserved_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CrossroadOverlapInfo::GetMetadata() const {
  protobuf_hdmap_5fcommon_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_hdmap_5fcommon_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CrossroadOverlapInfo

// optional int32 reserved = 1;
bool CrossroadOverlapInfo::has_reserved() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CrossroadOverlapInfo::set_has_reserved() {
  _has_bits_[0] |= 0x00000001u;
}
void CrossroadOverlapInfo::clear_has_reserved() {
  _has_bits_[0] &= ~0x00000001u;
}
void CrossroadOverlapInfo::clear_reserved() {
  reserved_ = 0;
  clear_has_reserved();
}
::google::protobuf::int32 CrossroadOverlapInfo::reserved() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.CrossroadOverlapInfo.reserved)
  return reserved_;
}
void CrossroadOverlapInfo::set_reserved(::google::protobuf::int32 value) {
  set_has_reserved();
  reserved_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.CrossroadOverlapInfo.reserved)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RampOverlapInfo::kReservedFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RampOverlapInfo::RampOverlapInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_hdmap_5fcommon_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:COWA.MapData.RampOverlapInfo)
}
RampOverlapInfo::RampOverlapInfo(const RampOverlapInfo& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  reserved_ = from.reserved_;
  // @@protoc_insertion_point(copy_constructor:COWA.MapData.RampOverlapInfo)
}

void RampOverlapInfo::SharedCtor() {
  _cached_size_ = 0;
  reserved_ = 0;
}

RampOverlapInfo::~RampOverlapInfo() {
  // @@protoc_insertion_point(destructor:COWA.MapData.RampOverlapInfo)
  SharedDtor();
}

void RampOverlapInfo::SharedDtor() {
}

void RampOverlapInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RampOverlapInfo::descriptor() {
  protobuf_hdmap_5fcommon_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_hdmap_5fcommon_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const RampOverlapInfo& RampOverlapInfo::default_instance() {
  protobuf_hdmap_5fcommon_2eproto::InitDefaults();
  return *internal_default_instance();
}

RampOverlapInfo* RampOverlapInfo::New(::google::protobuf::Arena* arena) const {
  RampOverlapInfo* n = new RampOverlapInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RampOverlapInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:COWA.MapData.RampOverlapInfo)
  reserved_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool RampOverlapInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:COWA.MapData.RampOverlapInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 reserved = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          set_has_reserved();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &reserved_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:COWA.MapData.RampOverlapInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:COWA.MapData.RampOverlapInfo)
  return false;
#undef DO_
}

void RampOverlapInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:COWA.MapData.RampOverlapInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 reserved = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->reserved(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:COWA.MapData.RampOverlapInfo)
}

::google::protobuf::uint8* RampOverlapInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:COWA.MapData.RampOverlapInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 reserved = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->reserved(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:COWA.MapData.RampOverlapInfo)
  return target;
}

size_t RampOverlapInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:COWA.MapData.RampOverlapInfo)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // optional int32 reserved = 1;
  if (has_reserved()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->reserved());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RampOverlapInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:COWA.MapData.RampOverlapInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const RampOverlapInfo* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const RampOverlapInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:COWA.MapData.RampOverlapInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:COWA.MapData.RampOverlapInfo)
    MergeFrom(*source);
  }
}

void RampOverlapInfo::MergeFrom(const RampOverlapInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:COWA.MapData.RampOverlapInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_reserved()) {
    set_reserved(from.reserved());
  }
}

void RampOverlapInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:COWA.MapData.RampOverlapInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RampOverlapInfo::CopyFrom(const RampOverlapInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:COWA.MapData.RampOverlapInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RampOverlapInfo::IsInitialized() const {
  return true;
}

void RampOverlapInfo::Swap(RampOverlapInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RampOverlapInfo::InternalSwap(RampOverlapInfo* other) {
  std::swap(reserved_, other->reserved_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RampOverlapInfo::GetMetadata() const {
  protobuf_hdmap_5fcommon_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_hdmap_5fcommon_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RampOverlapInfo

// optional int32 reserved = 1;
bool RampOverlapInfo::has_reserved() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RampOverlapInfo::set_has_reserved() {
  _has_bits_[0] |= 0x00000001u;
}
void RampOverlapInfo::clear_has_reserved() {
  _has_bits_[0] &= ~0x00000001u;
}
void RampOverlapInfo::clear_reserved() {
  reserved_ = 0;
  clear_has_reserved();
}
::google::protobuf::int32 RampOverlapInfo::reserved() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.RampOverlapInfo.reserved)
  return reserved_;
}
void RampOverlapInfo::set_reserved(::google::protobuf::int32 value) {
  set_has_reserved();
  reserved_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.RampOverlapInfo.reserved)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RoadmarkOverlapInfo::kReservedFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RoadmarkOverlapInfo::RoadmarkOverlapInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_hdmap_5fcommon_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:COWA.MapData.RoadmarkOverlapInfo)
}
RoadmarkOverlapInfo::RoadmarkOverlapInfo(const RoadmarkOverlapInfo& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  reserved_ = from.reserved_;
  // @@protoc_insertion_point(copy_constructor:COWA.MapData.RoadmarkOverlapInfo)
}

void RoadmarkOverlapInfo::SharedCtor() {
  _cached_size_ = 0;
  reserved_ = 0;
}

RoadmarkOverlapInfo::~RoadmarkOverlapInfo() {
  // @@protoc_insertion_point(destructor:COWA.MapData.RoadmarkOverlapInfo)
  SharedDtor();
}

void RoadmarkOverlapInfo::SharedDtor() {
}

void RoadmarkOverlapInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RoadmarkOverlapInfo::descriptor() {
  protobuf_hdmap_5fcommon_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_hdmap_5fcommon_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const RoadmarkOverlapInfo& RoadmarkOverlapInfo::default_instance() {
  protobuf_hdmap_5fcommon_2eproto::InitDefaults();
  return *internal_default_instance();
}

RoadmarkOverlapInfo* RoadmarkOverlapInfo::New(::google::protobuf::Arena* arena) const {
  RoadmarkOverlapInfo* n = new RoadmarkOverlapInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RoadmarkOverlapInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:COWA.MapData.RoadmarkOverlapInfo)
  reserved_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool RoadmarkOverlapInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:COWA.MapData.RoadmarkOverlapInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 reserved = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          set_has_reserved();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &reserved_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:COWA.MapData.RoadmarkOverlapInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:COWA.MapData.RoadmarkOverlapInfo)
  return false;
#undef DO_
}

void RoadmarkOverlapInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:COWA.MapData.RoadmarkOverlapInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 reserved = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->reserved(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:COWA.MapData.RoadmarkOverlapInfo)
}

::google::protobuf::uint8* RoadmarkOverlapInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:COWA.MapData.RoadmarkOverlapInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 reserved = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->reserved(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:COWA.MapData.RoadmarkOverlapInfo)
  return target;
}

size_t RoadmarkOverlapInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:COWA.MapData.RoadmarkOverlapInfo)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // optional int32 reserved = 1;
  if (has_reserved()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->reserved());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RoadmarkOverlapInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:COWA.MapData.RoadmarkOverlapInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const RoadmarkOverlapInfo* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const RoadmarkOverlapInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:COWA.MapData.RoadmarkOverlapInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:COWA.MapData.RoadmarkOverlapInfo)
    MergeFrom(*source);
  }
}

void RoadmarkOverlapInfo::MergeFrom(const RoadmarkOverlapInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:COWA.MapData.RoadmarkOverlapInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_reserved()) {
    set_reserved(from.reserved());
  }
}

void RoadmarkOverlapInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:COWA.MapData.RoadmarkOverlapInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RoadmarkOverlapInfo::CopyFrom(const RoadmarkOverlapInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:COWA.MapData.RoadmarkOverlapInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RoadmarkOverlapInfo::IsInitialized() const {
  return true;
}

void RoadmarkOverlapInfo::Swap(RoadmarkOverlapInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RoadmarkOverlapInfo::InternalSwap(RoadmarkOverlapInfo* other) {
  std::swap(reserved_, other->reserved_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RoadmarkOverlapInfo::GetMetadata() const {
  protobuf_hdmap_5fcommon_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_hdmap_5fcommon_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RoadmarkOverlapInfo

// optional int32 reserved = 1;
bool RoadmarkOverlapInfo::has_reserved() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RoadmarkOverlapInfo::set_has_reserved() {
  _has_bits_[0] |= 0x00000001u;
}
void RoadmarkOverlapInfo::clear_has_reserved() {
  _has_bits_[0] &= ~0x00000001u;
}
void RoadmarkOverlapInfo::clear_reserved() {
  reserved_ = 0;
  clear_has_reserved();
}
::google::protobuf::int32 RoadmarkOverlapInfo::reserved() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.RoadmarkOverlapInfo.reserved)
  return reserved_;
}
void RoadmarkOverlapInfo::set_reserved(::google::protobuf::int32 value) {
  set_has_reserved();
  reserved_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.RoadmarkOverlapInfo.reserved)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RoadOverlapInfo::kReservedFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RoadOverlapInfo::RoadOverlapInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_hdmap_5fcommon_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:COWA.MapData.RoadOverlapInfo)
}
RoadOverlapInfo::RoadOverlapInfo(const RoadOverlapInfo& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  reserved_ = from.reserved_;
  // @@protoc_insertion_point(copy_constructor:COWA.MapData.RoadOverlapInfo)
}

void RoadOverlapInfo::SharedCtor() {
  _cached_size_ = 0;
  reserved_ = 0;
}

RoadOverlapInfo::~RoadOverlapInfo() {
  // @@protoc_insertion_point(destructor:COWA.MapData.RoadOverlapInfo)
  SharedDtor();
}

void RoadOverlapInfo::SharedDtor() {
}

void RoadOverlapInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RoadOverlapInfo::descriptor() {
  protobuf_hdmap_5fcommon_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_hdmap_5fcommon_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const RoadOverlapInfo& RoadOverlapInfo::default_instance() {
  protobuf_hdmap_5fcommon_2eproto::InitDefaults();
  return *internal_default_instance();
}

RoadOverlapInfo* RoadOverlapInfo::New(::google::protobuf::Arena* arena) const {
  RoadOverlapInfo* n = new RoadOverlapInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RoadOverlapInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:COWA.MapData.RoadOverlapInfo)
  reserved_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool RoadOverlapInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:COWA.MapData.RoadOverlapInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 reserved = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          set_has_reserved();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &reserved_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:COWA.MapData.RoadOverlapInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:COWA.MapData.RoadOverlapInfo)
  return false;
#undef DO_
}

void RoadOverlapInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:COWA.MapData.RoadOverlapInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 reserved = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->reserved(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:COWA.MapData.RoadOverlapInfo)
}

::google::protobuf::uint8* RoadOverlapInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:COWA.MapData.RoadOverlapInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 reserved = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->reserved(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:COWA.MapData.RoadOverlapInfo)
  return target;
}

size_t RoadOverlapInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:COWA.MapData.RoadOverlapInfo)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // optional int32 reserved = 1;
  if (has_reserved()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->reserved());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RoadOverlapInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:COWA.MapData.RoadOverlapInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const RoadOverlapInfo* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const RoadOverlapInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:COWA.MapData.RoadOverlapInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:COWA.MapData.RoadOverlapInfo)
    MergeFrom(*source);
  }
}

void RoadOverlapInfo::MergeFrom(const RoadOverlapInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:COWA.MapData.RoadOverlapInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_reserved()) {
    set_reserved(from.reserved());
  }
}

void RoadOverlapInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:COWA.MapData.RoadOverlapInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RoadOverlapInfo::CopyFrom(const RoadOverlapInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:COWA.MapData.RoadOverlapInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RoadOverlapInfo::IsInitialized() const {
  return true;
}

void RoadOverlapInfo::Swap(RoadOverlapInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RoadOverlapInfo::InternalSwap(RoadOverlapInfo* other) {
  std::swap(reserved_, other->reserved_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RoadOverlapInfo::GetMetadata() const {
  protobuf_hdmap_5fcommon_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_hdmap_5fcommon_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RoadOverlapInfo

// optional int32 reserved = 1;
bool RoadOverlapInfo::has_reserved() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RoadOverlapInfo::set_has_reserved() {
  _has_bits_[0] |= 0x00000001u;
}
void RoadOverlapInfo::clear_has_reserved() {
  _has_bits_[0] &= ~0x00000001u;
}
void RoadOverlapInfo::clear_reserved() {
  reserved_ = 0;
  clear_has_reserved();
}
::google::protobuf::int32 RoadOverlapInfo::reserved() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.RoadOverlapInfo.reserved)
  return reserved_;
}
void RoadOverlapInfo::set_reserved(::google::protobuf::int32 value) {
  set_has_reserved();
  reserved_ = value;
  // @@protoc_insertion_point(field_set:COWA.MapData.RoadOverlapInfo.reserved)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Overlap_ObjectOverlapInfo::kIdFieldNumber;
const int Overlap_ObjectOverlapInfo::kLaneFieldNumber;
const int Overlap_ObjectOverlapInfo::kSignalFieldNumber;
const int Overlap_ObjectOverlapInfo::kCrossroadFieldNumber;
const int Overlap_ObjectOverlapInfo::kCrosswalkFieldNumber;
const int Overlap_ObjectOverlapInfo::kRampFieldNumber;
const int Overlap_ObjectOverlapInfo::kRoadmarkFieldNumber;
const int Overlap_ObjectOverlapInfo::kRoadFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Overlap_ObjectOverlapInfo::Overlap_ObjectOverlapInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_hdmap_5fcommon_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:COWA.MapData.Overlap.ObjectOverlapInfo)
}
Overlap_ObjectOverlapInfo::Overlap_ObjectOverlapInfo(const Overlap_ObjectOverlapInfo& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_id()) {
    id_ = new ::COWA::MapData::Id(*from.id_);
  } else {
    id_ = NULL;
  }
  clear_has_overlap_info();
  switch (from.overlap_info_case()) {
    case kLane: {
      mutable_lane()->::COWA::MapData::LaneOverlapInfo::MergeFrom(from.lane());
      break;
    }
    case kSignal: {
      mutable_signal()->::COWA::MapData::SignalOverlapInfo::MergeFrom(from.signal());
      break;
    }
    case kCrossroad: {
      mutable_crossroad()->::COWA::MapData::CrossroadOverlapInfo::MergeFrom(from.crossroad());
      break;
    }
    case kCrosswalk: {
      mutable_crosswalk()->::COWA::MapData::CrosswalkOverlapInfo::MergeFrom(from.crosswalk());
      break;
    }
    case kRamp: {
      mutable_ramp()->::COWA::MapData::RampOverlapInfo::MergeFrom(from.ramp());
      break;
    }
    case kRoadmark: {
      mutable_roadmark()->::COWA::MapData::RoadmarkOverlapInfo::MergeFrom(from.roadmark());
      break;
    }
    case kRoad: {
      mutable_road()->::COWA::MapData::RoadOverlapInfo::MergeFrom(from.road());
      break;
    }
    case OVERLAP_INFO_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:COWA.MapData.Overlap.ObjectOverlapInfo)
}

void Overlap_ObjectOverlapInfo::SharedCtor() {
  _cached_size_ = 0;
  id_ = NULL;
  clear_has_overlap_info();
}

Overlap_ObjectOverlapInfo::~Overlap_ObjectOverlapInfo() {
  // @@protoc_insertion_point(destructor:COWA.MapData.Overlap.ObjectOverlapInfo)
  SharedDtor();
}

void Overlap_ObjectOverlapInfo::SharedDtor() {
  if (this != internal_default_instance()) {
    delete id_;
  }
  if (has_overlap_info()) {
    clear_overlap_info();
  }
}

void Overlap_ObjectOverlapInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Overlap_ObjectOverlapInfo::descriptor() {
  protobuf_hdmap_5fcommon_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_hdmap_5fcommon_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Overlap_ObjectOverlapInfo& Overlap_ObjectOverlapInfo::default_instance() {
  protobuf_hdmap_5fcommon_2eproto::InitDefaults();
  return *internal_default_instance();
}

Overlap_ObjectOverlapInfo* Overlap_ObjectOverlapInfo::New(::google::protobuf::Arena* arena) const {
  Overlap_ObjectOverlapInfo* n = new Overlap_ObjectOverlapInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Overlap_ObjectOverlapInfo::clear_overlap_info() {
// @@protoc_insertion_point(one_of_clear_start:COWA.MapData.Overlap.ObjectOverlapInfo)
  switch (overlap_info_case()) {
    case kLane: {
      delete overlap_info_.lane_;
      break;
    }
    case kSignal: {
      delete overlap_info_.signal_;
      break;
    }
    case kCrossroad: {
      delete overlap_info_.crossroad_;
      break;
    }
    case kCrosswalk: {
      delete overlap_info_.crosswalk_;
      break;
    }
    case kRamp: {
      delete overlap_info_.ramp_;
      break;
    }
    case kRoadmark: {
      delete overlap_info_.roadmark_;
      break;
    }
    case kRoad: {
      delete overlap_info_.road_;
      break;
    }
    case OVERLAP_INFO_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = OVERLAP_INFO_NOT_SET;
}


void Overlap_ObjectOverlapInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:COWA.MapData.Overlap.ObjectOverlapInfo)
  if (has_id()) {
    GOOGLE_DCHECK(id_ != NULL);
    id_->::COWA::MapData::Id::Clear();
  }
  clear_overlap_info();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Overlap_ObjectOverlapInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:COWA.MapData.Overlap.ObjectOverlapInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .COWA.MapData.Id id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_id()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .COWA.MapData.LaneOverlapInfo lane = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_lane()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .COWA.MapData.SignalOverlapInfo signal = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_signal()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .COWA.MapData.CrossroadOverlapInfo crossroad = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_crossroad()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .COWA.MapData.CrosswalkOverlapInfo crosswalk = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_crosswalk()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .COWA.MapData.RampOverlapInfo ramp = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ramp()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .COWA.MapData.RoadmarkOverlapInfo roadmark = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_roadmark()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .COWA.MapData.RoadOverlapInfo road = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(66u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_road()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:COWA.MapData.Overlap.ObjectOverlapInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:COWA.MapData.Overlap.ObjectOverlapInfo)
  return false;
#undef DO_
}

void Overlap_ObjectOverlapInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:COWA.MapData.Overlap.ObjectOverlapInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .COWA.MapData.Id id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->id_, output);
  }

  switch (overlap_info_case()) {
    case kLane:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        2, *overlap_info_.lane_, output);
      break;
    case kSignal:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        3, *overlap_info_.signal_, output);
      break;
    case kCrossroad:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        4, *overlap_info_.crossroad_, output);
      break;
    case kCrosswalk:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        5, *overlap_info_.crosswalk_, output);
      break;
    case kRamp:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        6, *overlap_info_.ramp_, output);
      break;
    case kRoadmark:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        7, *overlap_info_.roadmark_, output);
      break;
    case kRoad:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        8, *overlap_info_.road_, output);
      break;
    default: ;
  }
  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:COWA.MapData.Overlap.ObjectOverlapInfo)
}

::google::protobuf::uint8* Overlap_ObjectOverlapInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:COWA.MapData.Overlap.ObjectOverlapInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .COWA.MapData.Id id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->id_, deterministic, target);
  }

  switch (overlap_info_case()) {
    case kLane:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          2, *overlap_info_.lane_, deterministic, target);
      break;
    case kSignal:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          3, *overlap_info_.signal_, deterministic, target);
      break;
    case kCrossroad:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          4, *overlap_info_.crossroad_, deterministic, target);
      break;
    case kCrosswalk:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          5, *overlap_info_.crosswalk_, deterministic, target);
      break;
    case kRamp:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          6, *overlap_info_.ramp_, deterministic, target);
      break;
    case kRoadmark:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          7, *overlap_info_.roadmark_, deterministic, target);
      break;
    case kRoad:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          8, *overlap_info_.road_, deterministic, target);
      break;
    default: ;
  }
  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:COWA.MapData.Overlap.ObjectOverlapInfo)
  return target;
}

size_t Overlap_ObjectOverlapInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:COWA.MapData.Overlap.ObjectOverlapInfo)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // optional .COWA.MapData.Id id = 1;
  if (has_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->id_);
  }

  switch (overlap_info_case()) {
    // optional .COWA.MapData.LaneOverlapInfo lane = 2;
    case kLane: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *overlap_info_.lane_);
      break;
    }
    // optional .COWA.MapData.SignalOverlapInfo signal = 3;
    case kSignal: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *overlap_info_.signal_);
      break;
    }
    // optional .COWA.MapData.CrossroadOverlapInfo crossroad = 4;
    case kCrossroad: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *overlap_info_.crossroad_);
      break;
    }
    // optional .COWA.MapData.CrosswalkOverlapInfo crosswalk = 5;
    case kCrosswalk: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *overlap_info_.crosswalk_);
      break;
    }
    // optional .COWA.MapData.RampOverlapInfo ramp = 6;
    case kRamp: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *overlap_info_.ramp_);
      break;
    }
    // optional .COWA.MapData.RoadmarkOverlapInfo roadmark = 7;
    case kRoadmark: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *overlap_info_.roadmark_);
      break;
    }
    // optional .COWA.MapData.RoadOverlapInfo road = 8;
    case kRoad: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *overlap_info_.road_);
      break;
    }
    case OVERLAP_INFO_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Overlap_ObjectOverlapInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:COWA.MapData.Overlap.ObjectOverlapInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const Overlap_ObjectOverlapInfo* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Overlap_ObjectOverlapInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:COWA.MapData.Overlap.ObjectOverlapInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:COWA.MapData.Overlap.ObjectOverlapInfo)
    MergeFrom(*source);
  }
}

void Overlap_ObjectOverlapInfo::MergeFrom(const Overlap_ObjectOverlapInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:COWA.MapData.Overlap.ObjectOverlapInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_id()) {
    mutable_id()->::COWA::MapData::Id::MergeFrom(from.id());
  }
  switch (from.overlap_info_case()) {
    case kLane: {
      mutable_lane()->::COWA::MapData::LaneOverlapInfo::MergeFrom(from.lane());
      break;
    }
    case kSignal: {
      mutable_signal()->::COWA::MapData::SignalOverlapInfo::MergeFrom(from.signal());
      break;
    }
    case kCrossroad: {
      mutable_crossroad()->::COWA::MapData::CrossroadOverlapInfo::MergeFrom(from.crossroad());
      break;
    }
    case kCrosswalk: {
      mutable_crosswalk()->::COWA::MapData::CrosswalkOverlapInfo::MergeFrom(from.crosswalk());
      break;
    }
    case kRamp: {
      mutable_ramp()->::COWA::MapData::RampOverlapInfo::MergeFrom(from.ramp());
      break;
    }
    case kRoadmark: {
      mutable_roadmark()->::COWA::MapData::RoadmarkOverlapInfo::MergeFrom(from.roadmark());
      break;
    }
    case kRoad: {
      mutable_road()->::COWA::MapData::RoadOverlapInfo::MergeFrom(from.road());
      break;
    }
    case OVERLAP_INFO_NOT_SET: {
      break;
    }
  }
}

void Overlap_ObjectOverlapInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:COWA.MapData.Overlap.ObjectOverlapInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Overlap_ObjectOverlapInfo::CopyFrom(const Overlap_ObjectOverlapInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:COWA.MapData.Overlap.ObjectOverlapInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Overlap_ObjectOverlapInfo::IsInitialized() const {
  return true;
}

void Overlap_ObjectOverlapInfo::Swap(Overlap_ObjectOverlapInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Overlap_ObjectOverlapInfo::InternalSwap(Overlap_ObjectOverlapInfo* other) {
  std::swap(id_, other->id_);
  std::swap(overlap_info_, other->overlap_info_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Overlap_ObjectOverlapInfo::GetMetadata() const {
  protobuf_hdmap_5fcommon_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_hdmap_5fcommon_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Overlap_ObjectOverlapInfo

// optional .COWA.MapData.Id id = 1;
bool Overlap_ObjectOverlapInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Overlap_ObjectOverlapInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
void Overlap_ObjectOverlapInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void Overlap_ObjectOverlapInfo::clear_id() {
  if (id_ != NULL) id_->::COWA::MapData::Id::Clear();
  clear_has_id();
}
const ::COWA::MapData::Id& Overlap_ObjectOverlapInfo::id() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Overlap.ObjectOverlapInfo.id)
  return id_ != NULL ? *id_
                         : *::COWA::MapData::Id::internal_default_instance();
}
::COWA::MapData::Id* Overlap_ObjectOverlapInfo::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    id_ = new ::COWA::MapData::Id;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Overlap.ObjectOverlapInfo.id)
  return id_;
}
::COWA::MapData::Id* Overlap_ObjectOverlapInfo::release_id() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Overlap.ObjectOverlapInfo.id)
  clear_has_id();
  ::COWA::MapData::Id* temp = id_;
  id_ = NULL;
  return temp;
}
void Overlap_ObjectOverlapInfo::set_allocated_id(::COWA::MapData::Id* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Overlap.ObjectOverlapInfo.id)
}

// optional .COWA.MapData.LaneOverlapInfo lane = 2;
bool Overlap_ObjectOverlapInfo::has_lane() const {
  return overlap_info_case() == kLane;
}
void Overlap_ObjectOverlapInfo::set_has_lane() {
  _oneof_case_[0] = kLane;
}
void Overlap_ObjectOverlapInfo::clear_lane() {
  if (has_lane()) {
    delete overlap_info_.lane_;
    clear_has_overlap_info();
  }
}
 const ::COWA::MapData::LaneOverlapInfo& Overlap_ObjectOverlapInfo::lane() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Overlap.ObjectOverlapInfo.lane)
  return has_lane()
      ? *overlap_info_.lane_
      : ::COWA::MapData::LaneOverlapInfo::default_instance();
}
::COWA::MapData::LaneOverlapInfo* Overlap_ObjectOverlapInfo::mutable_lane() {
  if (!has_lane()) {
    clear_overlap_info();
    set_has_lane();
    overlap_info_.lane_ = new ::COWA::MapData::LaneOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Overlap.ObjectOverlapInfo.lane)
  return overlap_info_.lane_;
}
::COWA::MapData::LaneOverlapInfo* Overlap_ObjectOverlapInfo::release_lane() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Overlap.ObjectOverlapInfo.lane)
  if (has_lane()) {
    clear_has_overlap_info();
    ::COWA::MapData::LaneOverlapInfo* temp = overlap_info_.lane_;
    overlap_info_.lane_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Overlap_ObjectOverlapInfo::set_allocated_lane(::COWA::MapData::LaneOverlapInfo* lane) {
  clear_overlap_info();
  if (lane) {
    set_has_lane();
    overlap_info_.lane_ = lane;
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Overlap.ObjectOverlapInfo.lane)
}

// optional .COWA.MapData.SignalOverlapInfo signal = 3;
bool Overlap_ObjectOverlapInfo::has_signal() const {
  return overlap_info_case() == kSignal;
}
void Overlap_ObjectOverlapInfo::set_has_signal() {
  _oneof_case_[0] = kSignal;
}
void Overlap_ObjectOverlapInfo::clear_signal() {
  if (has_signal()) {
    delete overlap_info_.signal_;
    clear_has_overlap_info();
  }
}
 const ::COWA::MapData::SignalOverlapInfo& Overlap_ObjectOverlapInfo::signal() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Overlap.ObjectOverlapInfo.signal)
  return has_signal()
      ? *overlap_info_.signal_
      : ::COWA::MapData::SignalOverlapInfo::default_instance();
}
::COWA::MapData::SignalOverlapInfo* Overlap_ObjectOverlapInfo::mutable_signal() {
  if (!has_signal()) {
    clear_overlap_info();
    set_has_signal();
    overlap_info_.signal_ = new ::COWA::MapData::SignalOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Overlap.ObjectOverlapInfo.signal)
  return overlap_info_.signal_;
}
::COWA::MapData::SignalOverlapInfo* Overlap_ObjectOverlapInfo::release_signal() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Overlap.ObjectOverlapInfo.signal)
  if (has_signal()) {
    clear_has_overlap_info();
    ::COWA::MapData::SignalOverlapInfo* temp = overlap_info_.signal_;
    overlap_info_.signal_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Overlap_ObjectOverlapInfo::set_allocated_signal(::COWA::MapData::SignalOverlapInfo* signal) {
  clear_overlap_info();
  if (signal) {
    set_has_signal();
    overlap_info_.signal_ = signal;
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Overlap.ObjectOverlapInfo.signal)
}

// optional .COWA.MapData.CrossroadOverlapInfo crossroad = 4;
bool Overlap_ObjectOverlapInfo::has_crossroad() const {
  return overlap_info_case() == kCrossroad;
}
void Overlap_ObjectOverlapInfo::set_has_crossroad() {
  _oneof_case_[0] = kCrossroad;
}
void Overlap_ObjectOverlapInfo::clear_crossroad() {
  if (has_crossroad()) {
    delete overlap_info_.crossroad_;
    clear_has_overlap_info();
  }
}
 const ::COWA::MapData::CrossroadOverlapInfo& Overlap_ObjectOverlapInfo::crossroad() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Overlap.ObjectOverlapInfo.crossroad)
  return has_crossroad()
      ? *overlap_info_.crossroad_
      : ::COWA::MapData::CrossroadOverlapInfo::default_instance();
}
::COWA::MapData::CrossroadOverlapInfo* Overlap_ObjectOverlapInfo::mutable_crossroad() {
  if (!has_crossroad()) {
    clear_overlap_info();
    set_has_crossroad();
    overlap_info_.crossroad_ = new ::COWA::MapData::CrossroadOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Overlap.ObjectOverlapInfo.crossroad)
  return overlap_info_.crossroad_;
}
::COWA::MapData::CrossroadOverlapInfo* Overlap_ObjectOverlapInfo::release_crossroad() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Overlap.ObjectOverlapInfo.crossroad)
  if (has_crossroad()) {
    clear_has_overlap_info();
    ::COWA::MapData::CrossroadOverlapInfo* temp = overlap_info_.crossroad_;
    overlap_info_.crossroad_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Overlap_ObjectOverlapInfo::set_allocated_crossroad(::COWA::MapData::CrossroadOverlapInfo* crossroad) {
  clear_overlap_info();
  if (crossroad) {
    set_has_crossroad();
    overlap_info_.crossroad_ = crossroad;
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Overlap.ObjectOverlapInfo.crossroad)
}

// optional .COWA.MapData.CrosswalkOverlapInfo crosswalk = 5;
bool Overlap_ObjectOverlapInfo::has_crosswalk() const {
  return overlap_info_case() == kCrosswalk;
}
void Overlap_ObjectOverlapInfo::set_has_crosswalk() {
  _oneof_case_[0] = kCrosswalk;
}
void Overlap_ObjectOverlapInfo::clear_crosswalk() {
  if (has_crosswalk()) {
    delete overlap_info_.crosswalk_;
    clear_has_overlap_info();
  }
}
 const ::COWA::MapData::CrosswalkOverlapInfo& Overlap_ObjectOverlapInfo::crosswalk() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Overlap.ObjectOverlapInfo.crosswalk)
  return has_crosswalk()
      ? *overlap_info_.crosswalk_
      : ::COWA::MapData::CrosswalkOverlapInfo::default_instance();
}
::COWA::MapData::CrosswalkOverlapInfo* Overlap_ObjectOverlapInfo::mutable_crosswalk() {
  if (!has_crosswalk()) {
    clear_overlap_info();
    set_has_crosswalk();
    overlap_info_.crosswalk_ = new ::COWA::MapData::CrosswalkOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Overlap.ObjectOverlapInfo.crosswalk)
  return overlap_info_.crosswalk_;
}
::COWA::MapData::CrosswalkOverlapInfo* Overlap_ObjectOverlapInfo::release_crosswalk() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Overlap.ObjectOverlapInfo.crosswalk)
  if (has_crosswalk()) {
    clear_has_overlap_info();
    ::COWA::MapData::CrosswalkOverlapInfo* temp = overlap_info_.crosswalk_;
    overlap_info_.crosswalk_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Overlap_ObjectOverlapInfo::set_allocated_crosswalk(::COWA::MapData::CrosswalkOverlapInfo* crosswalk) {
  clear_overlap_info();
  if (crosswalk) {
    set_has_crosswalk();
    overlap_info_.crosswalk_ = crosswalk;
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Overlap.ObjectOverlapInfo.crosswalk)
}

// optional .COWA.MapData.RampOverlapInfo ramp = 6;
bool Overlap_ObjectOverlapInfo::has_ramp() const {
  return overlap_info_case() == kRamp;
}
void Overlap_ObjectOverlapInfo::set_has_ramp() {
  _oneof_case_[0] = kRamp;
}
void Overlap_ObjectOverlapInfo::clear_ramp() {
  if (has_ramp()) {
    delete overlap_info_.ramp_;
    clear_has_overlap_info();
  }
}
 const ::COWA::MapData::RampOverlapInfo& Overlap_ObjectOverlapInfo::ramp() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Overlap.ObjectOverlapInfo.ramp)
  return has_ramp()
      ? *overlap_info_.ramp_
      : ::COWA::MapData::RampOverlapInfo::default_instance();
}
::COWA::MapData::RampOverlapInfo* Overlap_ObjectOverlapInfo::mutable_ramp() {
  if (!has_ramp()) {
    clear_overlap_info();
    set_has_ramp();
    overlap_info_.ramp_ = new ::COWA::MapData::RampOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Overlap.ObjectOverlapInfo.ramp)
  return overlap_info_.ramp_;
}
::COWA::MapData::RampOverlapInfo* Overlap_ObjectOverlapInfo::release_ramp() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Overlap.ObjectOverlapInfo.ramp)
  if (has_ramp()) {
    clear_has_overlap_info();
    ::COWA::MapData::RampOverlapInfo* temp = overlap_info_.ramp_;
    overlap_info_.ramp_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Overlap_ObjectOverlapInfo::set_allocated_ramp(::COWA::MapData::RampOverlapInfo* ramp) {
  clear_overlap_info();
  if (ramp) {
    set_has_ramp();
    overlap_info_.ramp_ = ramp;
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Overlap.ObjectOverlapInfo.ramp)
}

// optional .COWA.MapData.RoadmarkOverlapInfo roadmark = 7;
bool Overlap_ObjectOverlapInfo::has_roadmark() const {
  return overlap_info_case() == kRoadmark;
}
void Overlap_ObjectOverlapInfo::set_has_roadmark() {
  _oneof_case_[0] = kRoadmark;
}
void Overlap_ObjectOverlapInfo::clear_roadmark() {
  if (has_roadmark()) {
    delete overlap_info_.roadmark_;
    clear_has_overlap_info();
  }
}
 const ::COWA::MapData::RoadmarkOverlapInfo& Overlap_ObjectOverlapInfo::roadmark() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Overlap.ObjectOverlapInfo.roadmark)
  return has_roadmark()
      ? *overlap_info_.roadmark_
      : ::COWA::MapData::RoadmarkOverlapInfo::default_instance();
}
::COWA::MapData::RoadmarkOverlapInfo* Overlap_ObjectOverlapInfo::mutable_roadmark() {
  if (!has_roadmark()) {
    clear_overlap_info();
    set_has_roadmark();
    overlap_info_.roadmark_ = new ::COWA::MapData::RoadmarkOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Overlap.ObjectOverlapInfo.roadmark)
  return overlap_info_.roadmark_;
}
::COWA::MapData::RoadmarkOverlapInfo* Overlap_ObjectOverlapInfo::release_roadmark() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Overlap.ObjectOverlapInfo.roadmark)
  if (has_roadmark()) {
    clear_has_overlap_info();
    ::COWA::MapData::RoadmarkOverlapInfo* temp = overlap_info_.roadmark_;
    overlap_info_.roadmark_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Overlap_ObjectOverlapInfo::set_allocated_roadmark(::COWA::MapData::RoadmarkOverlapInfo* roadmark) {
  clear_overlap_info();
  if (roadmark) {
    set_has_roadmark();
    overlap_info_.roadmark_ = roadmark;
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Overlap.ObjectOverlapInfo.roadmark)
}

// optional .COWA.MapData.RoadOverlapInfo road = 8;
bool Overlap_ObjectOverlapInfo::has_road() const {
  return overlap_info_case() == kRoad;
}
void Overlap_ObjectOverlapInfo::set_has_road() {
  _oneof_case_[0] = kRoad;
}
void Overlap_ObjectOverlapInfo::clear_road() {
  if (has_road()) {
    delete overlap_info_.road_;
    clear_has_overlap_info();
  }
}
 const ::COWA::MapData::RoadOverlapInfo& Overlap_ObjectOverlapInfo::road() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Overlap.ObjectOverlapInfo.road)
  return has_road()
      ? *overlap_info_.road_
      : ::COWA::MapData::RoadOverlapInfo::default_instance();
}
::COWA::MapData::RoadOverlapInfo* Overlap_ObjectOverlapInfo::mutable_road() {
  if (!has_road()) {
    clear_overlap_info();
    set_has_road();
    overlap_info_.road_ = new ::COWA::MapData::RoadOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Overlap.ObjectOverlapInfo.road)
  return overlap_info_.road_;
}
::COWA::MapData::RoadOverlapInfo* Overlap_ObjectOverlapInfo::release_road() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Overlap.ObjectOverlapInfo.road)
  if (has_road()) {
    clear_has_overlap_info();
    ::COWA::MapData::RoadOverlapInfo* temp = overlap_info_.road_;
    overlap_info_.road_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Overlap_ObjectOverlapInfo::set_allocated_road(::COWA::MapData::RoadOverlapInfo* road) {
  clear_overlap_info();
  if (road) {
    set_has_road();
    overlap_info_.road_ = road;
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Overlap.ObjectOverlapInfo.road)
}

bool Overlap_ObjectOverlapInfo::has_overlap_info() const {
  return overlap_info_case() != OVERLAP_INFO_NOT_SET;
}
void Overlap_ObjectOverlapInfo::clear_has_overlap_info() {
  _oneof_case_[0] = OVERLAP_INFO_NOT_SET;
}
Overlap_ObjectOverlapInfo::OverlapInfoCase Overlap_ObjectOverlapInfo::overlap_info_case() const {
  return Overlap_ObjectOverlapInfo::OverlapInfoCase(_oneof_case_[0]);
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Overlap::kFirstFieldNumber;
const int Overlap::kSecondFieldNumber;
const int Overlap::kPolygonFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Overlap::Overlap()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_hdmap_5fcommon_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:COWA.MapData.Overlap)
}
Overlap::Overlap(const Overlap& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_first()) {
    first_ = new ::COWA::MapData::Overlap_ObjectOverlapInfo(*from.first_);
  } else {
    first_ = NULL;
  }
  if (from.has_second()) {
    second_ = new ::COWA::MapData::Overlap_ObjectOverlapInfo(*from.second_);
  } else {
    second_ = NULL;
  }
  if (from.has_polygon()) {
    polygon_ = new ::COWA::MapData::Polygon(*from.polygon_);
  } else {
    polygon_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:COWA.MapData.Overlap)
}

void Overlap::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&first_, 0, reinterpret_cast<char*>(&polygon_) -
    reinterpret_cast<char*>(&first_) + sizeof(polygon_));
}

Overlap::~Overlap() {
  // @@protoc_insertion_point(destructor:COWA.MapData.Overlap)
  SharedDtor();
}

void Overlap::SharedDtor() {
  if (this != internal_default_instance()) {
    delete first_;
  }
  if (this != internal_default_instance()) {
    delete second_;
  }
  if (this != internal_default_instance()) {
    delete polygon_;
  }
}

void Overlap::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Overlap::descriptor() {
  protobuf_hdmap_5fcommon_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_hdmap_5fcommon_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Overlap& Overlap::default_instance() {
  protobuf_hdmap_5fcommon_2eproto::InitDefaults();
  return *internal_default_instance();
}

Overlap* Overlap::New(::google::protobuf::Arena* arena) const {
  Overlap* n = new Overlap;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Overlap::Clear() {
// @@protoc_insertion_point(message_clear_start:COWA.MapData.Overlap)
  if (_has_bits_[0 / 32] & 7u) {
    if (has_first()) {
      GOOGLE_DCHECK(first_ != NULL);
      first_->::COWA::MapData::Overlap_ObjectOverlapInfo::Clear();
    }
    if (has_second()) {
      GOOGLE_DCHECK(second_ != NULL);
      second_->::COWA::MapData::Overlap_ObjectOverlapInfo::Clear();
    }
    if (has_polygon()) {
      GOOGLE_DCHECK(polygon_ != NULL);
      polygon_->::COWA::MapData::Polygon::Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Overlap::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:COWA.MapData.Overlap)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .COWA.MapData.Overlap.ObjectOverlapInfo first = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_first()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .COWA.MapData.Overlap.ObjectOverlapInfo second = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_second()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .COWA.MapData.Polygon polygon = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_polygon()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:COWA.MapData.Overlap)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:COWA.MapData.Overlap)
  return false;
#undef DO_
}

void Overlap::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:COWA.MapData.Overlap)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .COWA.MapData.Overlap.ObjectOverlapInfo first = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->first_, output);
  }

  // optional .COWA.MapData.Overlap.ObjectOverlapInfo second = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->second_, output);
  }

  // optional .COWA.MapData.Polygon polygon = 4;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->polygon_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:COWA.MapData.Overlap)
}

::google::protobuf::uint8* Overlap::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:COWA.MapData.Overlap)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .COWA.MapData.Overlap.ObjectOverlapInfo first = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->first_, deterministic, target);
  }

  // optional .COWA.MapData.Overlap.ObjectOverlapInfo second = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->second_, deterministic, target);
  }

  // optional .COWA.MapData.Polygon polygon = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->polygon_, deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:COWA.MapData.Overlap)
  return target;
}

size_t Overlap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:COWA.MapData.Overlap)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 7u) {
    // optional .COWA.MapData.Overlap.ObjectOverlapInfo first = 2;
    if (has_first()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->first_);
    }

    // optional .COWA.MapData.Overlap.ObjectOverlapInfo second = 3;
    if (has_second()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->second_);
    }

    // optional .COWA.MapData.Polygon polygon = 4;
    if (has_polygon()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->polygon_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Overlap::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:COWA.MapData.Overlap)
  GOOGLE_DCHECK_NE(&from, this);
  const Overlap* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Overlap>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:COWA.MapData.Overlap)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:COWA.MapData.Overlap)
    MergeFrom(*source);
  }
}

void Overlap::MergeFrom(const Overlap& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:COWA.MapData.Overlap)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_first()->::COWA::MapData::Overlap_ObjectOverlapInfo::MergeFrom(from.first());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_second()->::COWA::MapData::Overlap_ObjectOverlapInfo::MergeFrom(from.second());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_polygon()->::COWA::MapData::Polygon::MergeFrom(from.polygon());
    }
  }
}

void Overlap::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:COWA.MapData.Overlap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Overlap::CopyFrom(const Overlap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:COWA.MapData.Overlap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Overlap::IsInitialized() const {
  return true;
}

void Overlap::Swap(Overlap* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Overlap::InternalSwap(Overlap* other) {
  std::swap(first_, other->first_);
  std::swap(second_, other->second_);
  std::swap(polygon_, other->polygon_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Overlap::GetMetadata() const {
  protobuf_hdmap_5fcommon_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_hdmap_5fcommon_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Overlap

// optional .COWA.MapData.Overlap.ObjectOverlapInfo first = 2;
bool Overlap::has_first() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Overlap::set_has_first() {
  _has_bits_[0] |= 0x00000001u;
}
void Overlap::clear_has_first() {
  _has_bits_[0] &= ~0x00000001u;
}
void Overlap::clear_first() {
  if (first_ != NULL) first_->::COWA::MapData::Overlap_ObjectOverlapInfo::Clear();
  clear_has_first();
}
const ::COWA::MapData::Overlap_ObjectOverlapInfo& Overlap::first() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Overlap.first)
  return first_ != NULL ? *first_
                         : *::COWA::MapData::Overlap_ObjectOverlapInfo::internal_default_instance();
}
::COWA::MapData::Overlap_ObjectOverlapInfo* Overlap::mutable_first() {
  set_has_first();
  if (first_ == NULL) {
    first_ = new ::COWA::MapData::Overlap_ObjectOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Overlap.first)
  return first_;
}
::COWA::MapData::Overlap_ObjectOverlapInfo* Overlap::release_first() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Overlap.first)
  clear_has_first();
  ::COWA::MapData::Overlap_ObjectOverlapInfo* temp = first_;
  first_ = NULL;
  return temp;
}
void Overlap::set_allocated_first(::COWA::MapData::Overlap_ObjectOverlapInfo* first) {
  delete first_;
  first_ = first;
  if (first) {
    set_has_first();
  } else {
    clear_has_first();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Overlap.first)
}

// optional .COWA.MapData.Overlap.ObjectOverlapInfo second = 3;
bool Overlap::has_second() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Overlap::set_has_second() {
  _has_bits_[0] |= 0x00000002u;
}
void Overlap::clear_has_second() {
  _has_bits_[0] &= ~0x00000002u;
}
void Overlap::clear_second() {
  if (second_ != NULL) second_->::COWA::MapData::Overlap_ObjectOverlapInfo::Clear();
  clear_has_second();
}
const ::COWA::MapData::Overlap_ObjectOverlapInfo& Overlap::second() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Overlap.second)
  return second_ != NULL ? *second_
                         : *::COWA::MapData::Overlap_ObjectOverlapInfo::internal_default_instance();
}
::COWA::MapData::Overlap_ObjectOverlapInfo* Overlap::mutable_second() {
  set_has_second();
  if (second_ == NULL) {
    second_ = new ::COWA::MapData::Overlap_ObjectOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Overlap.second)
  return second_;
}
::COWA::MapData::Overlap_ObjectOverlapInfo* Overlap::release_second() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Overlap.second)
  clear_has_second();
  ::COWA::MapData::Overlap_ObjectOverlapInfo* temp = second_;
  second_ = NULL;
  return temp;
}
void Overlap::set_allocated_second(::COWA::MapData::Overlap_ObjectOverlapInfo* second) {
  delete second_;
  second_ = second;
  if (second) {
    set_has_second();
  } else {
    clear_has_second();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Overlap.second)
}

// optional .COWA.MapData.Polygon polygon = 4;
bool Overlap::has_polygon() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Overlap::set_has_polygon() {
  _has_bits_[0] |= 0x00000004u;
}
void Overlap::clear_has_polygon() {
  _has_bits_[0] &= ~0x00000004u;
}
void Overlap::clear_polygon() {
  if (polygon_ != NULL) polygon_->::COWA::MapData::Polygon::Clear();
  clear_has_polygon();
}
const ::COWA::MapData::Polygon& Overlap::polygon() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Overlap.polygon)
  return polygon_ != NULL ? *polygon_
                         : *::COWA::MapData::Polygon::internal_default_instance();
}
::COWA::MapData::Polygon* Overlap::mutable_polygon() {
  set_has_polygon();
  if (polygon_ == NULL) {
    polygon_ = new ::COWA::MapData::Polygon;
  }
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Overlap.polygon)
  return polygon_;
}
::COWA::MapData::Polygon* Overlap::release_polygon() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Overlap.polygon)
  clear_has_polygon();
  ::COWA::MapData::Polygon* temp = polygon_;
  polygon_ = NULL;
  return temp;
}
void Overlap::set_allocated_polygon(::COWA::MapData::Polygon* polygon) {
  delete polygon_;
  polygon_ = polygon;
  if (polygon) {
    set_has_polygon();
  } else {
    clear_has_polygon();
  }
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Overlap.polygon)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Header::kVersionFieldNumber;
const int Header::kDateFieldNumber;
const int Header::kProjectionFieldNumber;
const int Header::kGenerationFieldNumber;
const int Header::kMd5FieldNumber;
const int Header::kLogFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Header::Header()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_hdmap_5fcommon_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:COWA.MapData.Header)
}
Header::Header(const Header& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      log_(from.log_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  version_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_version()) {
    version_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.version_);
  }
  date_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_date()) {
    date_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.date_);
  }
  projection_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_projection()) {
    projection_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.projection_);
  }
  generation_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_generation()) {
    generation_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.generation_);
  }
  md5_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_md5()) {
    md5_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.md5_);
  }
  // @@protoc_insertion_point(copy_constructor:COWA.MapData.Header)
}

void Header::SharedCtor() {
  _cached_size_ = 0;
  version_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  date_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  projection_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  generation_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  md5_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

Header::~Header() {
  // @@protoc_insertion_point(destructor:COWA.MapData.Header)
  SharedDtor();
}

void Header::SharedDtor() {
  version_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  date_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  projection_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  generation_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  md5_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void Header::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Header::descriptor() {
  protobuf_hdmap_5fcommon_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_hdmap_5fcommon_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Header& Header::default_instance() {
  protobuf_hdmap_5fcommon_2eproto::InitDefaults();
  return *internal_default_instance();
}

Header* Header::New(::google::protobuf::Arena* arena) const {
  Header* n = new Header;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Header::Clear() {
// @@protoc_insertion_point(message_clear_start:COWA.MapData.Header)
  log_.Clear();
  if (_has_bits_[0 / 32] & 31u) {
    if (has_version()) {
      GOOGLE_DCHECK(!version_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*version_.UnsafeRawStringPointer())->clear();
    }
    if (has_date()) {
      GOOGLE_DCHECK(!date_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*date_.UnsafeRawStringPointer())->clear();
    }
    if (has_projection()) {
      GOOGLE_DCHECK(!projection_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*projection_.UnsafeRawStringPointer())->clear();
    }
    if (has_generation()) {
      GOOGLE_DCHECK(!generation_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*generation_.UnsafeRawStringPointer())->clear();
    }
    if (has_md5()) {
      GOOGLE_DCHECK(!md5_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*md5_.UnsafeRawStringPointer())->clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Header::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:COWA.MapData.Header)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string version = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "COWA.MapData.Header.version");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string date = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_date()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->date().data(), this->date().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "COWA.MapData.Header.date");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string projection = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_projection()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->projection().data(), this->projection().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "COWA.MapData.Header.projection");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string generation = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_generation()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->generation().data(), this->generation().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "COWA.MapData.Header.generation");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string md5 = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_md5()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->md5().data(), this->md5().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "COWA.MapData.Header.md5");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated string log = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_log()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->log(this->log_size() - 1).data(),
            this->log(this->log_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "COWA.MapData.Header.log");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:COWA.MapData.Header)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:COWA.MapData.Header)
  return false;
#undef DO_
}

void Header::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:COWA.MapData.Header)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string version = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "COWA.MapData.Header.version");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->version(), output);
  }

  // optional string date = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->date().data(), this->date().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "COWA.MapData.Header.date");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->date(), output);
  }

  // optional string projection = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->projection().data(), this->projection().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "COWA.MapData.Header.projection");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->projection(), output);
  }

  // optional string generation = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->generation().data(), this->generation().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "COWA.MapData.Header.generation");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->generation(), output);
  }

  // optional string md5 = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->md5().data(), this->md5().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "COWA.MapData.Header.md5");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->md5(), output);
  }

  // repeated string log = 6;
  for (int i = 0, n = this->log_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->log(i).data(), this->log(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "COWA.MapData.Header.log");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->log(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:COWA.MapData.Header)
}

::google::protobuf::uint8* Header::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:COWA.MapData.Header)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string version = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "COWA.MapData.Header.version");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->version(), target);
  }

  // optional string date = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->date().data(), this->date().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "COWA.MapData.Header.date");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->date(), target);
  }

  // optional string projection = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->projection().data(), this->projection().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "COWA.MapData.Header.projection");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->projection(), target);
  }

  // optional string generation = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->generation().data(), this->generation().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "COWA.MapData.Header.generation");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->generation(), target);
  }

  // optional string md5 = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->md5().data(), this->md5().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "COWA.MapData.Header.md5");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->md5(), target);
  }

  // repeated string log = 6;
  for (int i = 0, n = this->log_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->log(i).data(), this->log(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "COWA.MapData.Header.log");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(6, this->log(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:COWA.MapData.Header)
  return target;
}

size_t Header::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:COWA.MapData.Header)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // repeated string log = 6;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->log_size());
  for (int i = 0, n = this->log_size(); i < n; i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->log(i));
  }

  if (_has_bits_[0 / 32] & 31u) {
    // optional string version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }

    // optional string date = 2;
    if (has_date()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->date());
    }

    // optional string projection = 3;
    if (has_projection()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->projection());
    }

    // optional string generation = 4;
    if (has_generation()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->generation());
    }

    // optional string md5 = 5;
    if (has_md5()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->md5());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Header::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:COWA.MapData.Header)
  GOOGLE_DCHECK_NE(&from, this);
  const Header* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Header>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:COWA.MapData.Header)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:COWA.MapData.Header)
    MergeFrom(*source);
  }
}

void Header::MergeFrom(const Header& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:COWA.MapData.Header)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  log_.MergeFrom(from.log_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 31u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_version();
      version_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.version_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_date();
      date_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.date_);
    }
    if (cached_has_bits & 0x00000004u) {
      set_has_projection();
      projection_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.projection_);
    }
    if (cached_has_bits & 0x00000008u) {
      set_has_generation();
      generation_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.generation_);
    }
    if (cached_has_bits & 0x00000010u) {
      set_has_md5();
      md5_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.md5_);
    }
  }
}

void Header::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:COWA.MapData.Header)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Header::CopyFrom(const Header& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:COWA.MapData.Header)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Header::IsInitialized() const {
  return true;
}

void Header::Swap(Header* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Header::InternalSwap(Header* other) {
  log_.InternalSwap(&other->log_);
  version_.Swap(&other->version_);
  date_.Swap(&other->date_);
  projection_.Swap(&other->projection_);
  generation_.Swap(&other->generation_);
  md5_.Swap(&other->md5_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Header::GetMetadata() const {
  protobuf_hdmap_5fcommon_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_hdmap_5fcommon_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Header

// optional string version = 1;
bool Header::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Header::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
void Header::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
void Header::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_version();
}
const ::std::string& Header::version() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Header.version)
  return version_.GetNoArena();
}
void Header::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:COWA.MapData.Header.version)
}
#if LANG_CXX11
void Header::set_version(::std::string&& value) {
  set_has_version();
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:COWA.MapData.Header.version)
}
#endif
void Header::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:COWA.MapData.Header.version)
}
void Header::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:COWA.MapData.Header.version)
}
::std::string* Header::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Header.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Header::release_version() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Header.version)
  clear_has_version();
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Header::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Header.version)
}

// optional string date = 2;
bool Header::has_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Header::set_has_date() {
  _has_bits_[0] |= 0x00000002u;
}
void Header::clear_has_date() {
  _has_bits_[0] &= ~0x00000002u;
}
void Header::clear_date() {
  date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_date();
}
const ::std::string& Header::date() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Header.date)
  return date_.GetNoArena();
}
void Header::set_date(const ::std::string& value) {
  set_has_date();
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:COWA.MapData.Header.date)
}
#if LANG_CXX11
void Header::set_date(::std::string&& value) {
  set_has_date();
  date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:COWA.MapData.Header.date)
}
#endif
void Header::set_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_date();
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:COWA.MapData.Header.date)
}
void Header::set_date(const char* value, size_t size) {
  set_has_date();
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:COWA.MapData.Header.date)
}
::std::string* Header::mutable_date() {
  set_has_date();
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Header.date)
  return date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Header::release_date() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Header.date)
  clear_has_date();
  return date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Header::set_allocated_date(::std::string* date) {
  if (date != NULL) {
    set_has_date();
  } else {
    clear_has_date();
  }
  date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), date);
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Header.date)
}

// optional string projection = 3;
bool Header::has_projection() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Header::set_has_projection() {
  _has_bits_[0] |= 0x00000004u;
}
void Header::clear_has_projection() {
  _has_bits_[0] &= ~0x00000004u;
}
void Header::clear_projection() {
  projection_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_projection();
}
const ::std::string& Header::projection() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Header.projection)
  return projection_.GetNoArena();
}
void Header::set_projection(const ::std::string& value) {
  set_has_projection();
  projection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:COWA.MapData.Header.projection)
}
#if LANG_CXX11
void Header::set_projection(::std::string&& value) {
  set_has_projection();
  projection_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:COWA.MapData.Header.projection)
}
#endif
void Header::set_projection(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_projection();
  projection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:COWA.MapData.Header.projection)
}
void Header::set_projection(const char* value, size_t size) {
  set_has_projection();
  projection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:COWA.MapData.Header.projection)
}
::std::string* Header::mutable_projection() {
  set_has_projection();
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Header.projection)
  return projection_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Header::release_projection() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Header.projection)
  clear_has_projection();
  return projection_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Header::set_allocated_projection(::std::string* projection) {
  if (projection != NULL) {
    set_has_projection();
  } else {
    clear_has_projection();
  }
  projection_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), projection);
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Header.projection)
}

// optional string generation = 4;
bool Header::has_generation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Header::set_has_generation() {
  _has_bits_[0] |= 0x00000008u;
}
void Header::clear_has_generation() {
  _has_bits_[0] &= ~0x00000008u;
}
void Header::clear_generation() {
  generation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_generation();
}
const ::std::string& Header::generation() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Header.generation)
  return generation_.GetNoArena();
}
void Header::set_generation(const ::std::string& value) {
  set_has_generation();
  generation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:COWA.MapData.Header.generation)
}
#if LANG_CXX11
void Header::set_generation(::std::string&& value) {
  set_has_generation();
  generation_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:COWA.MapData.Header.generation)
}
#endif
void Header::set_generation(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_generation();
  generation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:COWA.MapData.Header.generation)
}
void Header::set_generation(const char* value, size_t size) {
  set_has_generation();
  generation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:COWA.MapData.Header.generation)
}
::std::string* Header::mutable_generation() {
  set_has_generation();
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Header.generation)
  return generation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Header::release_generation() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Header.generation)
  clear_has_generation();
  return generation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Header::set_allocated_generation(::std::string* generation) {
  if (generation != NULL) {
    set_has_generation();
  } else {
    clear_has_generation();
  }
  generation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), generation);
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Header.generation)
}

// optional string md5 = 5;
bool Header::has_md5() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Header::set_has_md5() {
  _has_bits_[0] |= 0x00000010u;
}
void Header::clear_has_md5() {
  _has_bits_[0] &= ~0x00000010u;
}
void Header::clear_md5() {
  md5_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_md5();
}
const ::std::string& Header::md5() const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Header.md5)
  return md5_.GetNoArena();
}
void Header::set_md5(const ::std::string& value) {
  set_has_md5();
  md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:COWA.MapData.Header.md5)
}
#if LANG_CXX11
void Header::set_md5(::std::string&& value) {
  set_has_md5();
  md5_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:COWA.MapData.Header.md5)
}
#endif
void Header::set_md5(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_md5();
  md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:COWA.MapData.Header.md5)
}
void Header::set_md5(const char* value, size_t size) {
  set_has_md5();
  md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:COWA.MapData.Header.md5)
}
::std::string* Header::mutable_md5() {
  set_has_md5();
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Header.md5)
  return md5_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Header::release_md5() {
  // @@protoc_insertion_point(field_release:COWA.MapData.Header.md5)
  clear_has_md5();
  return md5_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Header::set_allocated_md5(::std::string* md5) {
  if (md5 != NULL) {
    set_has_md5();
  } else {
    clear_has_md5();
  }
  md5_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), md5);
  // @@protoc_insertion_point(field_set_allocated:COWA.MapData.Header.md5)
}

// repeated string log = 6;
int Header::log_size() const {
  return log_.size();
}
void Header::clear_log() {
  log_.Clear();
}
const ::std::string& Header::log(int index) const {
  // @@protoc_insertion_point(field_get:COWA.MapData.Header.log)
  return log_.Get(index);
}
::std::string* Header::mutable_log(int index) {
  // @@protoc_insertion_point(field_mutable:COWA.MapData.Header.log)
  return log_.Mutable(index);
}
void Header::set_log(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:COWA.MapData.Header.log)
  log_.Mutable(index)->assign(value);
}
#if LANG_CXX11
void Header::set_log(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:COWA.MapData.Header.log)
  log_.Mutable(index)->assign(std::move(value));
}
#endif
void Header::set_log(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  log_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:COWA.MapData.Header.log)
}
void Header::set_log(int index, const char* value, size_t size) {
  log_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:COWA.MapData.Header.log)
}
::std::string* Header::add_log() {
  // @@protoc_insertion_point(field_add_mutable:COWA.MapData.Header.log)
  return log_.Add();
}
void Header::add_log(const ::std::string& value) {
  log_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:COWA.MapData.Header.log)
}
#if LANG_CXX11
void Header::add_log(::std::string&& value) {
  log_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:COWA.MapData.Header.log)
}
#endif
void Header::add_log(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  log_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:COWA.MapData.Header.log)
}
void Header::add_log(const char* value, size_t size) {
  log_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:COWA.MapData.Header.log)
}
const ::google::protobuf::RepeatedPtrField< ::std::string>&
Header::log() const {
  // @@protoc_insertion_point(field_list:COWA.MapData.Header.log)
  return log_;
}
::google::protobuf::RepeatedPtrField< ::std::string>*
Header::mutable_log() {
  // @@protoc_insertion_point(field_mutable_list:COWA.MapData.Header.log)
  return &log_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace MapData
}  // namespace COWA

// @@protoc_insertion_point(global_scope)
